
<title>Frequently asked questions</title>
<h1>Frequently asked questions</h2>


<h2>Introduction</h2>

<h3>What is LilyPond?</h3>
<p>
We like to call LilyPond an "automated engraving system." It will
format music notation beautifully without requiring typographical
expertise of its users.

<p>


<h3>Automatic notation, so that means I can play the music, and then
it rolls out of the printer?</h3>
<p>

No.  Our system assumes that the input data is available in an exact,
abstract form.  Printing music is difficult enough as it is, so we do
not wish to add another problem.  Translating what a human plays to
exact form is hard. Even if you get the correct pitch data from a MIDI
keyboard (as opposed to a sound recording), one has to get the rhythms
correct. For example, how is a computer supposed to distinguish
between a staccato quarter note and an eighth note?  Moreover, how
would you print a piece that you cannot play in such a system?

<p>

<h3>There are other program that do notation. What's so special about
yours?</h3>

<p>
Yes, there are many other programs that "do" notation.  However,
anyone who plays both from recent editions and old (pre 1970) can
attest that modern computer printouts do not look nice: they have a
bland, mechanical look.  By contrast, we try to mimic traditional
plate engraving in the general impression, layout algorithms, and
the font design. Consequently, our output often beats our competitors
when it comes to good looks.
<p>

<h3>What is wrong with other computer printed scores?</h3>
<p>
Computer printed scores often lack subtle variations in spacing, which
results in mechanical appearance. To prevent clashes between different
symbols, they are spaced very widely, which leads to an "airy"
look. The heaviness of the layout is matched to that airy look: the
symbols are usually too light, and the lines are too thin.  The wide
spacing also causes a piece of music to take up more pages. Beams
often do not cover stafflines entirely, while slurs and ties do touch
them, leading to distracting clusters of black and wedges of white
around these places.
<p>

 Normally, one notices these details only subconsiously. The best way
to become conscious of these differences is to compare a traditionally
printed and a computer printed edition of the same piece, preferably
with a magnifying glass.  If you are not sure: traditional engraving
is photographically reproduced hand-work, and can be recognized by
slight irregularities in symbol placement, and small blotches due to
the reproduction process.

<p>

<h3>What is engraving?</h3>
<p>
Originally, music was printed by stamping and engraving symbols
mirrored into metal plates. The plates were inked, and paper was
pressed to it, yielding a left-to-right printing.  Hence, professional
music typography is now known as engraving, even when it is done with
computers today. People who do this are called engravers or copyists.

<p>

<h3>Why do you care about engraving?</h3>
<p>
We think that beautiful music deserves to be printed with a beautiful
layout.
<p>

<h3>Why would I care about engraving?</h3>
<p>
Typography is art, but is foremost a "useful art": good engraving
helps to read the music, making it is easier to play from.  For
example, if the layout reflects the character of a piece, then it is
easier to interpret.  If it is tightly spaced, it will take less
pages, reducing the number of page-turns. If a system (a &ldquo;line&rdquo) has a
unique horizontal layout, then it is more easily found back after
looking away at the conductor. A part which is printed with heavy
symbols and thick lines will be easier to read from a distance.
<p>

<p>
<h3>You say your program is special; you must be trying to sell
it?</h3>

<p>
No.  We give it away for free. You can download it <a
href=../download/>here</a>.

<h3>It's free now, but then you will start charging in the future?</h3>

<p>
No.  Not only do we give it away for free, but we also deliver it with
full source code, and permission to distribute, modify, sell or
mutilate it.  In other words, LilyPond is libre software; it is part
of the GNU project, and distributed under the terms of the
<a href="http://www.gnu.org/copyleft/gpl.html">GNU General Public
License.</a> 
<p>
In fact we think that this is much more important than cost. It means
that you have the freedom to fix, modify and extend the program, or
you can pay someone else to do so. We will not force you to upgrade
when your system is abandoned, and you are not lost when we abandon
the program.

<p>

<h3>How do you make a living?</h3>

<p>
Good question. We started LilyPond in 1996, and we always did it as an
unpaid hobby. We would like to change that.  Since we are not selling
the program, we sell our expertise. Practically speaking, you can pay
us for implementing features, or you can hire us for engraving music
or doing typography research. Contact us privately if you are
interested.
<p>


<h3>How can I thank you for LilyPond?</h2>

You can do three things:
<ul>
<li>
Tell us how much you like LilyPond, we always appreciate hearing
it: send us e-mail, or send a postcard:

<blockquote>
Jan &amp; Han-Wen<br>
p/a Han-Wen Nienhuys<br>
Spinozaweg 68<br>
3532 SH Utrecht,<br>
The Netherlands
</blockquote>
<p>
We also warmly welcome samples of the beverage or music of your choice
:-).
<p>
<li> Support development directly by giving us a <a
href="doneet.html">donation</a>.

<p>

<li>  Tell others how much you like LilyPond: promotion means more
users, and more users is always better. So,

<ul>
<li> tell your friends about LilyPond,

<li> don't remove the "Engraved by LilyPond" tagline, and

<li> mention LilyPond if you use it in theses and books, or cite us
in papers.

</ul>
</ul>

<h3>Who are you guys anyway?</h3>

<p>
We are Jan and Han-Wen, from the Netherlands. We met in a youth
orchestra, where Jan was tinkering with MusicTeX preprocessors. When
Han-Wen joined in it was decided that we should start afresh with a
completely different approach. What we created is now known as
LilyPond.
<p>
Jan is currently working as a programmer developing
web-applications. Han-Wen just finished his PhD. and is currently
looking for a LilyPond-related job.
<p>

<h3>Why the weird name?</h3>

Han-Wen: I started Lily (our affectionate name for LilyPond) in
1996. Back then, I was in an amateur symphonic orchestra together with
Jan.  I had a crush on this magnificent girl in the orchestra: her
name was Suzanne, she played both the flute and the cello, and (of
course) I thought she was very pretty.
<p>
At the time, Jan was dating Roos (Dutch for &lsquo;Rose&rsquo; -- she
also played the cello). I also knew about about a package Rosegarden
(a GUI MIDI sequencer and notation editor).  When I found out that
&lsquo;Susan&rsquo; is Hebrew for &lsquo;lily&rsquo;, I decided that
calling the package &lsquo;LilyPond&rsquo; would match make the
nomenclature of the rest of my life perfectly.
<p>
Some things don't last---the two girls, the cellos and the orchestra,
all have disappeared from our lives.  LilyPond however has survived
over time.  It is a big, mature program with a healthy user-base and
good prospects.  Best of all is, that we still have a good time
hacking on it
<p>



<h2>About the program.</h2>

<h3>Will run on my computer? </h3>

<p>
LilyPond is written for Unix, so it should run on any modern Unix
variant, including Linux/GNU and MacOS X. There is also a MS Windows
port, which uses the Cygwin environment. 
<p>

<h3>It's open source, so I should compile it from source?</h3>
<p>
No. Building LilyPond is a rather involved process. Unless you really
know what you are doing, it is better to use a binary package.
<p>

<h3>Which version should I use?</h3>
<p>
We use the version numbering scheme that is also used for the Linux
kernel. This means that even minor versions (1.4, 1.6, etc.) are
stable, and active development is done on the uneven minor versions
(1.5, 1.7).  Unless you have special needs, it is best to stick to the
stable branch.
<p>

<h3>How is LilyPond used?</h3>

<p>
LilyPond is a compiler: the music is encoded in a <tt>.ly</tt> file.
Then LilyPond is run on it by invoking the <tt>lilypond</tt>, scripts
which takes run the actual <tt>lilypond-bin</tt> program to format the
music, and adds titling information and page layout.  The resulting
PS, PDF and DVI can be viewed with T<sub>E</sub>X's DVI tools or
standard Postscript/PDF viewers.
<p>


<h3>What is the input format?</h3>
<p>
We have designed our own input format, the <tt>.ly</tt> format.  It is
a language that encodes music using expressions. These music
expressions are composed of simpler music expressions, where the
simplest expressions are notes and rests. This is analogous to how
arithmetical expressions can be broken down in simpler expressions,
where the simplest expressions are numbers, operators.
<p>


<h3>There are lots of good formats, why not use ABC, MusicXML or
NIFF or DARMS?</h3>

<p>
We have the following requirements:
<ul>
<li>
 the format must use ASCII,
 <li>it must be
concise enough to type by hand,
<li> it must have a  concise formal
specification,
<li> it must be expressive enough to support many types of notation and
printed formats.
</ul>

We believe that none of the existing formats address all these
requirements. For example, MusicXML cannot be typed by hand, DARMS is
limited in its application, ABC has no strict formal definition, and
NIFF is binary.  Nevertheless, this does not restrict you for using
those formats: there are filters that convert from various formats to
<tt>.ly</tt>.

<p>

<h3>LilyPond input has backslashes and braces, so it is TeX,
right?</h3>

<p>
No. The syntax is completely different. TeX is a macro language, where
the meaning of each command and each character can be
redefined. LilyPond has a structured input syntax, in the form of an
context-free grammar. As such, it is less flexible, but it is also
harder to make entry errors.
<p>
LilyPond does make use of TeX: TeX is the default output format, LaTeX
is used for formatting the titles, and it is possible to enter TeX
macros in texts (such as lyrics).
<p>

<h3>LilyPond is about music and is related to TeX, so it is
MusicTeX?</h3>

<p>
No. There is a family of TeX macro packages (MusicTeX, MusixTeX,
OpusTeX, MuTex) for typesetting music. There is no relation between
LilyPond and any of these packages: they are not needed to run
LilyPond.
<p>
We once have developed MPP, a predecessor to LilyPond, which was a
MusiXTeX preprocessor. However, this approach was abandoned in 1996
when we concluded that good automated typography is impossible to
achieve with MusiXTeX.
 
<p>

<h3>Why are you using TeX for LilyPond?</h3>
<p>
There are a couple of reasons:

<ul>
<li>LilyPond has no  mechanism for handling page breaks. This is
conveniently provided by TeX

<li>TeX is very powerful when it comes to setting text. The text for
lyrics or titling is set with TeX, so it allows for a lot of
formatting options. For example, it is possible to use foreign scripts
for the lyrics.

</ul>

Of course, the output obtained through TeX can be converted to usable
PostScript, and PDF which renders nicely on screen. This PostScript
can be rendered as PNG images for use on webservers.

<! LilyPond is in fact not limited to TeX. The program design allows
for other output formats. In particular, LilyPond has direct
PostScript output, but for the reasons listed here, it is not
practical for real use. >

<p>

<h3>How do I learn the syntax?</h3>
<p>
Take a look at the
<a href="http://lilypond.org/doc/v1.8/Documentation/user/out-www/lilypond/lilypond.html#Tutorial">tutorial</a>.
It is pretty short, chopped in easily digestible chunks,
and we've spent a lot of time polishing it.
If you like to learn by fiddling around, then you can get input
examples, by clicking the music images in the tutorial.

<p>

<h3>Please add parameters to the input macros</h3>

<p>
LilyPond input does not have macros. It does support identifiers:
parts of the input can be given a name, and when referencing that name
contents of the identifier are substituted. However this is not a
textual substitution, rather the internal representation of that
object is pasted into the contents being parsed.
<p>

<h3>Please add macros to the syntax.</h3>
<p>
No, we won't. Programming with text substitution (macros) lead to
horrible syntax problems. A macro programming interface is extremely
sensitive to irrelevant naming and formatting details.
<p>

<h3>
But I only need macros for simple repetitive tasks.
</h3>
<p>
Perhaps, but remember that you will probably spend more time reading
the .ly than writing. Often, a little verbosity is not such a bad
idea.  If it is only for simple things, you could just as well use
simple existing preprocessors such as CPP or M4.
<p>
Alternatively, you can use the <tt>\apply</tt> feature. This lets you
manipulate music expressions in their internal representation using the
built-in Scheme programming language.
<p>

<h3>Stop changing the syntax all the time!</h3>
<p>
We try to make LilyPond as good as possible, and that implies that we
continually improve the input format. We change the syntax whenever we
feel that it will simplify the language as a whole, or ease the
learning curve.  Keep in mind that the syntax is as great as it is now
because we also did this in the past.
<p>
Most of the language changes can be handled by running the program
<tt>convert-ly</tt>, which is supplied with LilyPond.  However,
<tt>convert-ly</tt> can only do its job if it knows what version the
original file was written for. Therefore, it is important to add
<code>version</code> statements to your files like this: <xmp>
\version "1.3.17" </xmp>
<p>
Changes that cannot be handled by simple edits are marked by a bump in
the major version number: converting 1.8 to 2.0 files will need
overseeing.
<p>

<h3>How quick is entering music with LilyPond?</h3>

<p>
There is no single answer to this, as the time spent depends on the
complexity of the music, and your fluency in LilyPond. Music with
complicated constructs (cross-staff beaming, collisions) takes longer
to enter than simple monophonic music.  Experienced users have
reported average times of 3.5 pages per hour for typing
straightforward music monophonic with an editor only. This time
includes corrections and minor layout tweaks.
<p>


<h3>I want to use my MIDI keyboard for entry</h3>


Try the following:

<ul>
<li>Hans Lub's

<a href="http://mail.gnu.org/archive/html/gnu-music-discuss/2001-10/msg00018.html">
emacs/MIDI input mode</a>

 <li>   Nicholas Sceaux'
<a href="http://nicolas.sceaux.free.fr/lilypond">Emacs/MIDI input mode</a>

<li><a
href=http://klobouk.fsv.cvut.cz/~xsmilauv/rumor/index.html>RUMOR</a>
a command line monophonic MIDI/lilypond entry tool.

<li><a href=http://lilycomp.sf.net>LilyComp</a> a graphic entry tool,
for those that don't read music well.  </ul>



<h3>I don't want to learn another syntax. Now what?</h3>
<p>
There are other options: it is possible to create the music in another
format. Supported formats include 

<ul>
<li> MIDI: LilyPond includes midi2ly, a program that translates a MIDI
file to LilyPond.

<li> ETF: LilyPond includes etf2ly, a convertor for the Finale ETF
format (<a href="../devel/misc/etfformat.html">about ETF</a>)

<li> ABC: LilyPond includes abc2ly, a convertor for the popular ABC
format (<a href="http://www.gre.ac.uk/~c.walshaw/abc/">about ABC</a>)

<li>MusicXML. Guido Amoruso's <a href=>xml2ly</a> will convert
MusicXML to LilyPond.  (<a href=http://www.musicxml.org/>About
MusicXML.</a>).

</ul>
<p>


<h3>I want to have an Graphical User Interface!</h3>
<p>
We have no time to also make a graphical user interface. Luckily,
other people have filled the gap. The following programs have
competent LilyPond export functions and are actively being developed.

<ul>
<li>
 <a href="http://rnvs.informatik.tu-chemnitz.de/~jan/noteedit/noteedit.html">
NoteEdit</a>
<li><a href="http://www.all-day-breakfast.com/rosegarden/">RoseGarden</a>
</ul>
There are also different, non-graphical interfaces:

<ul>
<li> <a href="http://klobouk.fsv.cvut.cz/~xsmilauv/rumor/">RUMOR</a>
is an interface to generate LilyPond input with a MIDI keyboard.

<li> <a
href="http://nicolas.sceaux.free.fr/lilypond/lyqi.html">LyQI</a>
provides a piano-like keyboard interface using the normal keyboard in
emacs. It can also use RUMOR.

</ul>


<h2>Support</h2>

<p>
<h3>Help, I can't get it to install or compile. Where do I get help?</h3>
<p>
If you have a binary package which does not install correctly, or if
you have trouble while following the instructions, then send a full
bug-report to <a href="mailto:bug-lilypond@gnu.org">bug-lilypond@gnu.org</a>.
Of course you can also write to the <a
href="http://mail.gnu.org/mailman/listinfo/lilypond-user">lilypond-user</a>
list for help.

<p>

<h3>Help, I can't get it to do something. Where do I get help?</h3>
<p>
You can write to the lilypond-user mailing list (which is at <a
href="http://mail.gnu.org/mailman/listinfo/lilypond-user">http://mail.gnu.org/mailman/listinfo/lilypond-user</a>).
It is also a good idea to check the archives of the mailing list,
which are at <a
href="http://mail.gnu.org/archive/html/lilypond-user/">http://mail.gnu.org/archive/html/lilypond-user/</a>.
<p>

<a name="bugreport"></a>

<h3>I found a bug.</h3>
<p>
If you have input that results in a crash or an erroneous output, then
that is a bug. We try respond to bug-reports promptly, and fix them as
soon as possible. For this, we need to replicate and isolate the
problem. Please help us by sending a good bug-report: an input file
that will reproduce the problem.  Please make it small, so we can
easily isolate the problem. Don't forget to tell which version you
use, and on which platform you run it. Send your report to <a
href="bug-lilypond@gnu.org">bug-lilypond@gnu.org</a>.

<p>

<h3>Could you add this feature for me?</h3>
<p>

We will definitely read your request and think about it, 
but we set our own priorities for implementing features. If you
want us to give more attention to your request, it helps to explain
why you need it, why it is such a good idea.
<p>
If you really need something, you can also hire one of the developers
to implement it.



<p>
<h3>But it is very easy, just extend the syntax like this...</h3>
<p>

It is a tempting to think that inventing the syntax solves the
problem. In practice, less than 10% of the program is involved with
handling input and the syntax.  Almost always, adding features
involves a lot more than syntax, and is also much more complicated.
<p>


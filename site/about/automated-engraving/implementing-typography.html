

<h2>Implementing typography</h2>


<p>

How do we go about implementing typography?  Answering the "music
notation" problem left us with a bunch of graphic objects
representings note heads, the staff, stems, etc.


<p>
If craftsmen need over ten years to become true masters, how could we
simple hackers ever write a program to take over their jobs?
<p>
The answer is: we cannot!  Since typography relies on human judgement
of appearance, people cannot be replaced. However, much of their dull
work can be automated: if LilyPond solves most of the common
situations correctly, than this will be a huge improvement over
existing software. The remaining cases can be tuned by hand.
Over the course of years, the software can be refined to do
more and more automatically, so manual overrides are necessary less
and less.

<p>

How do we go about building such a system?  When we started, we wrote
the program in C++. Essentially, this means that the program
functionality is set in stone by us developers. That proved to be
unsatisfactory:

<ul>
<li> If things must be tuned by hand, then the user must access to the
  formatting engine. Hence, data structures and variables cannot be
  fixed at compile time, but they must be accessible for the user.

<li> Engraving is a matter of visual judgement, and hence it is a
  matter of taste. As knowledgeable as we are, users can disagree with
  our personal decision. Therefore, the definitions of typographical
  style must also be accessible to the user.

<li> Finally, we continually refine the formatting algorithms, so we
 need a flexible approach to rules.  C++ forces us to group and apply
 rules that do not match how music notation works.

</ul>

Clearly, there is a need for a flexible architecture. The architecture
should encompass formatting rules, typographical style and individual
formatting decisions.

<p align=right>
Next: <a href="formatting-architecture.html">Program architecture,
your flexible friend</a>: tuning, tweaking and developing  typography
rules.

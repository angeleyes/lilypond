#!/usr/bin/env perl

### texi2html customization script for Lilypond
### Author: Reinhold Kainhofer <reinhold@kainhofer.com>, 2008.
###         Some code parts copied from texi2html and adapted.
### License: GPLv2+
###
###
### Features implemented here:
### -) For split manuals, the main page is index.html.
### -) All @unnumbered* sections are placed into the same file
###    (implemented by split_at_numbered_sections)
### -) Use our custom CSS file, with IE-specific fixes in another CSS file,
###    impelmented by lilypond_css_lines
### -) TOC (folded, with the current page highlighted) in an iframe is added
###    to every page; implemented by:
###           lilypond_print_element_header -- building of the TOC
###           lilypond_toc_body -- generation of customized TOC output
###           print_lilypond_page_foot -- output of the TOC
### -) External refs are formatted only as "Text of the node" (not as >>see
###    "NODE" section "SECTION" in "BOOK"<< like with default texi2html). Also,
###    the leading "(book-name)" is removed.
###    Implemented by overriding lilypond_external_ref
### -) Navigation bars on top/bottom of the page and between sections are not
###    left-aligned, but use a combination of left/center/right aligned table
###    cells; For this, I heavily extend the texi2html code to allow for
###    differently aligned cells and for multi-line tables);
###    Implemented in lilypond_print_navigation
### -) Allow translated section titles: All section titles can be translated,
###    the original (English) title is associated with @translationof. This is
###    needed, because the file name / anchor is generated from the original
###    English title, since otherwise language-autoselection would break with
###    posted links.
###    Since it is then no longer possible to obtain the file name from the
###    section title, I keep a sectionname<=>filename/anchor around and write
###    it out to disk at the end of the conversion. This way, xrefs from
###    other manuals can simply load that map and retrieve the correct file
###    name for the link. Implemented in:
###           lilypond_unknown (handling of @translationof)
###           split_at_numbered_sections (correct file name, build the map)
###           lilypond_finish_out (write out the map to disk)
###           lilypond_external_href (load the map, use the correct link target)
###
###
### Useful helper functions:
### -) texinfo_file_name($node_name): returns a texinfo-compatible file name
###    for the given string $node_name (whitespace trimmed/replaced by -,
###    non-standard chars replaced by _xxxx (ascii char code) and forced to
###    start with a letter by prepending t_g if necessary)


package Texi2HTML::Config;





#############################################################################
###  SETTINGS FOR TEXI2HTML
#############################################################################

@Texi2HTML::Config::CSS_REFS      = ("lilypond.css");
$Texi2HTML::Config::USE_ACCESSKEY = 1;
$Texi2HTML::Config::USE_LINKS     = 1;
$Texi2HTML::Config::USE_REL_REV   = 1;
$Texi2HTML::Config::element_file_name    = \&split_at_numbered_sections;
$Texi2HTML::Config::print_element_header = \&lilypond_print_element_header;
$Texi2HTML::Config::print_page_foot      = \&print_lilypond_page_foot;
$Texi2HTML::Config::print_navigation     = \&lilypond_print_navigation;
$Texi2HTML::Config::external_ref         = \&lilypond_external_ref;
$Texi2HTML::Config::external_href        = \&lilypond_external_href;
$Texi2HTML::Config::toc_body             = \&lilypond_toc_body;
$Texi2HTML::Config::css_lines            = \&lilypond_css_lines;
$Texi2HTML::Config::finish_out           = \&lilypond_finish_out;
$Texi2HTML::Config::unknown              = \&lilypond_unknown;


my $lastfilename;
my $docnr = 0;
my $page_toc_depth = 2;
my @default_toc = [];
my @section_to_filename;





#############################################################################
###  DEBUGGING
#############################################################################

use Data::Dumper;
$Data::Dumper::Maxdepth = 2;

sub print_element_info($)
{
  my $element = shift;
  print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
  print "Element: $element\n";
  print Dumper($element);
}





#############################################################################
###  HELPER FUNCTIONS
#############################################################################

# Convert a given node name to its proper file name (normalization as explained
# in the texinfo manual:
# http://www.gnu.org/software/texinfo/manual/texinfo/html_node/HTML-Xref-Node-Name-Expansion.html
sub texinfo_file_name($)
{
  my $str = shift;
  # File name normalization by texinfo:
  # 1/2: letters and numbers are left unchanged
  # 3/4: multiple, leading and trailing whitespace is removed
  $str = main::normalise_space($str);
  # 5/6: all remaining spaces are converted to '-', all other 7- or 8-bit
  #      chars are replaced by _xxxx (xxxx=ascii character code)
  my @chars = split(//, $str);
  my $str = '';
  foreach my $char (@chars) {
    if ( $char eq ' ' ) { # space -> '-'
      $str .= '-';
    } elsif ( ('0' le $char and $char le '9' ) or
              ('A' le $char and $char le 'Z' ) or
              ('a' le $char and $char le 'z' ) ) { # number or letter
      $str .= $char;
    } else {
      my $ccode = ord($char);
      my $addstr;
      if ( ord($char)<= 0xFFFF ) {
        $addstr = sprintf("_%4x", $ccode);
      } else {
        $addstr = sprintf("__%6x", $ccode);
      }
      # padding is done by spaces, replace by '0'
      $addstr =~ s/\ /0/g;
      $str .= $addstr;
    }
  }
  # 7: if name begins with number, prepend 't_g' (so it starts with a letter)
  if ($str =~ /^[0-9]/) {
    $str = 't_g' . $str;
  }
  # DONE
  return $str
}





#############################################################################
###  CSS HANDLING
#############################################################################

# Include our standard CSS file, not hard-coded CSS code directly in the HTML!
# For IE, conditionally include the lilypond-ie-fixes.css style sheet
sub lilypond_css_lines ($$)
{
    my $import_lines = shift;
    my $rule_lines = shift;
    return if (defined($CSS_LINES));
    if (@$rule_lines or @$import_lines)
    {
        $CSS_LINES = "<style type=\"text/css\">\n<!--\n";
        $CSS_LINES .= join('',@$import_lines) . "\n" if (@$import_lines);
        $CSS_LINES .= join('',@$rule_lines) . "\n" if (@$rule_lines);
        $CSS_LINES .= "-->\n</style>\n";
    }
    foreach my $ref (@CSS_REFS)
    {
        $CSS_LINES .= "<link rel=\"stylesheet\" type=\"text/css\" href=\"$ref\">\n";
    }
    $CSS_LINES .= "<!--[if lte IE 7]>\n<link href=\"lilypond-ie-fixes.css\" rel=\"stylesheet\" type=\"text/css\">\n<![endif]-->\n";
}





#############################################################################
###  SPLITTING BASED ON NUMBERED SECTIONS
#############################################################################

# This function makes sure that files are only generated for numbered sections,
# but not for unnumbered ones. It is called after texi2html has done its own
# splitting and simply returns the filename for the node given as first argument
# Nodes with the same filename will be printed out to the same filename, so
# this really all we need. Also, make sure that the file names for sections
# are derived from the section title. We also might want to name the anchors
# according to node titles, which works by simply overriding the id element of
# the $element hash. Store the file name for each section in a hash (written
# out to disk in lilypond_finish_out), so that other manuals can retrieve
# the correct filename/anchor from the section title.
sub split_at_numbered_sections($$$)
{
  my $element = shift;
  my $type = shift;
  my $docu_name = shift;
  my $docu_ext = $Texi2HTML::Config::EXTENSION;

  # TOC, footer, about etc. are called with undefined $element and $type == "toc"|"stoc"|"foot"|"about"
  if ($type eq "toc" or $type eq "stoc" or $type eq "foot" or $type eq "about") {
    return;
  } else {
    # derive the name of the anchor (i.e. the part after # in the links!),
    # don't use texi2html's SECx.x default!
    my $sec_name = main::remove_texi($$element{texi});
    my $anchor = $sec_name;
    if ($$element{translationof}) {
      $anchor = main::remove_texi($$element{translationof});
    }
    # normalize to the same file name as texinfo
    $anchor = texinfo_file_name($anchor);
    $$element{id} = $anchor;
    # Numbered sections will get a filename Node_title, unnumbered sections will use
    # the file name of the previous numbered section:
    if ($$element{number}) {
      my $filename = $anchor;
      $filename .= ".$docu_ext" if (defined($docu_ext));
      $docnr += 1;
      $$element{doc_nr} = $docnr;
      $lastfilename = $filename;
      push (@section_to_filename, [$sec_name, $filename, $anchor]);
      return $filename;
    } else {
      $$element{doc_nr} = $docnr;
      push (@section_to_filename, [$sec_name, $lastfilename, $anchor]);
      return $lastfilename;
    }
  }

  return;
}





#############################################################################
###  CLEANER LINK TITLE FOR EXTERNAL REFS
#############################################################################

# The default formatting of external refs returns e.g.
# "(lilypond-internals)Timing_translator", so we remove all (...) from the
# file_and_node argument. Also, we want only a very simple format, so we don't
# even call the default handler!
sub lilypond_external_ref($$$$$$)
{
  my $type = shift;
  my $section = shift;
  my $book = shift;
  my $file_node = shift;
  my $href = shift;
  my $cross_ref = shift;

  $file_node =~ s/\(.*\)//;
  $file_node = &$anchor('', $href, $file_node) if ($file_node ne '');
  return &$I('%{node_file_href}', { 'node_file_href' => $file_node });

#  Default: format as "see <a ..>NODE</a> section 'SECTION' in BOOK". We don't want this!
#   return t2h_default_external_ref($type, $section, $book, $file_node, $href, $cross_ref);
}





#############################################################################
###  HANDLING TRANSLATED SECTIONS: handle @translationof, secname<->filename
###                  map stored on disk, xrefs in other manuals load that map
#############################################################################


# Try to make use of @translationof to generate files according to the original
# English section title...
sub lilypond_unknown($$$$$)
{
    my $macro = shift;
    my $line = shift;
    my $pass = shift;
    my $stack = shift;
    my $state = shift;

    # the @translationof macro provides the original English section title,
    # which should be used for file/anchor naming, while the title will be
    # translated to each language
    if ($pass == 1 and $macro eq "translationof") {
      if (ref($state->{'element'})=='HASH') {
        $state->{'element'}->{'translationof'} = main::normalise_space($line);
      }
      return ('', true, undef, undef);
    } else {
      return t2h_default_unknown($macro, $line, $pass, $stack, $state);
    }
}


# Print out the sectionName<=>filename association to the file basename_xref.map
# so that cross-references from other manuals can load it and retrieve the
# correct filenames/anchors for each section title.
sub lilypond_finish_out()
{
  my $map_filename = "$Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'file_base_name'}_xref.map";
  if (open(XREFFILE, ">$map_filename")) {
    foreach (@section_to_filename) {
      my ($sec, $file, $anchor) = @$_;
      print XREFFILE "$sec\t$file\t$anchor\n";
    }
    close XREFFILE;
  } else {
    print "Can't open $map_filename for writing: $! The map of X-refs will not be written out\n";
  }
}



my %translated_books = ();
# Construct a href to an external source of information.
# node is the node with texinfo @-commands
# node_id is the node transliterated and transformed as explained in the
#         texinfo manual
# node_xhtml_id is the node transformed such that it is unique and can
#     be used to make an html cross ref as explained in the texinfo manual
# file is the file in '(file)node'
sub lilypond_external_href($$$)
{
  my $node = shift;
  my $node_id = shift;
  my $node_xhtml_id = shift;
  my $file = shift;
  my $original_func = \&t2h_default_external_href;

  # TODO:
  # 1) Keep a hash of book->section_map
  # 2) if not file in keys hash => try to load the map (assign empty map is non-existent => will load only once!)
  # 3) if node in the section=>(file, anchor) map, replace node_id and node_xhtml_id by the map's values
  # 4) call the t2h_default_external_href with these values (or the old ones if not found)
  print STDERR "lilypond_external_href: texi_node='$node', node_file='$node_id', node_xhtml_id='$node_xhtml_id', file='$file'\n";
  if (($node_id ne '') and defined($file)) {
    if (!exists($translated_books{$file})) {
      print STDERR "Map for book $file not yet loaded, trying to initialize\n";
      # TODO: Load the file...
      $translated_books{$file}={};
    }
    my $section_name_map = $translated_books{$file};
    if (exists($section_name_map->{$node_id})) {
      print STDERR "Found key $node_id in section_name_map\n";
      # TODO: Assign the new values to $file, $node_id and $node_xhtml_id!
    } else {
      print STDERR "Unable to find key $node_id in section_name_map\n";
    }
  }
  print STDERR "\n";
#
#     $file = '' if (!defined($file));
#     my $default_target_split = $EXTERNAL_CROSSREF_SPLIT;
#     my $target_split;
#     my $target_mono;
#     my $href_split;
#     my $href_mono;
#     if ($file ne '')
#     {
#          if ($NEW_CROSSREF_STYLE)
#          {
#              $file =~ s/\.[^\.]*$//;
#              $file =~ s/^.*\///;
#              my $href;
#              if (exists($Texi2HTML::THISDOC{'htmlxref'}->{$file}))
#              {
#                   if (exists($Texi2HTML::THISDOC{'htmlxref'}->{$file}->{'split'}))
#                   {
#                        $target_split = 1;
#                        $href_split =  $Texi2HTML::THISDOC{'htmlxref'}->{$file}->{'split'}->{'href'};
#                   }
#                   if (exists($Texi2HTML::THISDOC{'htmlxref'}->{$file}->{'mono'}))
#                   {
#                        $target_mono = 1;
#                        $href_mono =  $Texi2HTML::THISDOC{'htmlxref'}->{$file}->{'mono'}->{'href'};
#                   }
#              }
#
#              if ((not $target_mono) and (not $target_split))
#              { # nothing specified for that manual, use default
#                   $target_split = $default_target_split;
#              }
#              elsif ($target_split and $target_mono)
#              { # depends on the splitting of the manual
#                   $target_split = $SPLIT;
#              }
#              elsif ($target_mono)
#              { # only mono specified
#                   $target_split = 0;
#              }
#
#              if ($target_split)
#              {
#                   if (defined($href_split))
#                   {
#                        $file = "$href_split";
#                   }
#                   elsif (defined($EXTERNAL_DIR))
#                   {
#                        $file = "$EXTERNAL_DIR/$file";
#                   }
#                   elsif ($SPLIT)
#                   {
#                        $file = "../$file";
#                   }
#                   $file .= "/";
#              }
#              else
#              {# target not split
#                   if (defined($href_mono))
#                   {
#                        $file = "$href_mono";
#                   }
#                   else
#                   {
#                        if (defined($EXTERNAL_DIR))
#                        {
#                             $file = "$EXTERNAL_DIR/$file";
#                        }
#                        elsif ($SPLIT)
#                        {
#                            $file = "../$file";
#                        }
#                        $file .= "." . $NODE_FILE_EXTENSION;
#                   }
#              }
#          }
#          else
#          {
#              $file .= "/";
#              if (defined($EXTERNAL_DIR))
#              {
#                  $file = $EXTERNAL_DIR . $file;
#              }
#              else
#              {
#                  $file = '../' . $file;
#              }
#          }
#     }
#     else
#     {
#         $target_split = $default_target_split;
#     }
#     if ($node eq '')
#     {
#          if ($NEW_CROSSREF_STYLE)
#          {
#              if ($target_split)
#              {
#                  return $file . $TOP_NODE_FILE . '.' . $NODE_FILE_EXTENSION . '#Top';
#                  # or ?
#                  #return $file . '#Top';
#              }
#              else
#              {
#                   return $file . '#Top';
#              }
#          }
#          else
#          {
#              return $file;
#          }
#     }
#     my $target;
#     if ($NEW_CROSSREF_STYLE)
#     {
#          $node = $node_id;
#          $target = $node_xhtml_id;
#     }
#     else
#     {
#          $node = main::remove_texi($node);
#          $node =~ s/[^\w\.\-]/-/g;
#     }
#     my $file_basename = $node;
#     $file_basename = $TOP_NODE_FILE if ($node =~ /^top$/i);
#     if ($NEW_CROSSREF_STYLE)
#     {
#         if ($target_split)
#         {
#             return $file . $file_basename . ".$NODE_FILE_EXTENSION" . '#' . $target;
#         }
#         else
#         {
#             return $file . '#' . $target;
#         }
#     }
#     else
#     {
#         return $file . $file_basename . ".$NODE_FILE_EXTENSION";
#     }
  if (defined $file) {
    return &$original_func($node, $node_id, $node_hxmlt_id, $file);
  } else {
    return &$original_func($node, $node_id, $node_hxmlt_id);
  }
}





#############################################################################
###  CUSTOM TOC FOR EACH PAGE (in a frame on the left)
#############################################################################

# recursively generate the TOC entries for the element and its children (which
# are only shown up to maxlevel. All ancestors of the current element are also
# shown with their immediate children, irrespective of their level.
sub generate_ly_toc_entries($$$)
{
  my $element = shift;
  my $element_path = shift;
  my $maxlevel = shift;
  # Skip undefined sections, plus all sections generated by index splitting
  return() if (not defined($element) or exists($element->{'index_page'}));
  my @result = ();
  my $level = $element->{'toc_level'};
  my $is_parent_of_current = $element_path->{$element->{'number'}};
  my $print_children = ( ($level < $maxlevel) or $is_parent_of_current );
  my $ind = '  ' x $level;
  my $this_css_class = $is_parent_of_current ? " class=\"toc_current\"" : "";

  my $entry = "$ind<li$this_css_class>" . &$anchor ($element->{'tocid'}, "$element->{'file'}#$element->{'id'}",$element->{'text'});

  my $children = $element->{'section_childs'};
  if ( $print_children and defined($children) and (ref($children) eq "ARRAY") ) {
    push (@result, $entry);
    my @child_result = ();
    foreach (@$children) {
      push (@child_result, generate_ly_toc_entries($_, $element_path, $maxlevel));
    }
    # if no child nodes were generated, e.g. for the index, where expanded pages
    # are ignored, don't generate a list at all...
    if (@child_result) {
      push (@result, "$ind<ul$NO_BULLET_LIST_ATTRIBUTE>");
      push (@result, @child_result);
      push (@result, "$ind</ul></li>\n");
    }
  } else {
    push (@result, $entry . "</li>\n");
  }
  return @result;
}


# Print a customized TOC, containing only the first two levels plus the whole
# path to the current page
sub lilypond_generate_page_toc_body($)
{
    my $element = shift;
    my $current_element = $element;
    my %parentelements;
    $parentelements{$element->{'number'}} = 1;
    # Find the path to the current element
    while ( defined($current_element->{'sectionup'}) and
           ($current_element->{'sectionup'} ne $current_element) )
    {
      $parentelements{$current_element->{'sectionup'}->{'number'}} = 1
              if ($current_element->{'sectionup'}->{'number'} ne '');
      $current_element = $current_element->{'sectionup'};
    }
    return () if not defined($current_element);
    # Create the toc entries recursively
    my @toc_entries = ("<div class=\"contents\">", "<ul$NO_BULLET_LIST_ATTRIBUTE>");
    my $children = $current_element->{'section_childs'};
    foreach ( @$children ) {
      push (@toc_entries, generate_ly_toc_entries($_, \%parentelements, $page_toc_depth));
    }
    push (@toc_entries, "</ul>");
    push (@toc_entries, "</div>");
    return @toc_entries;
}


# Create the custom TOC for this page (partially folded, current page is
# highlighted) and store it in a global variable. The TOC is written out after
# the html contents (but positioned correctly using CSS), so that browsers with
# css turned off still show the contents first.
my @this_page_toc = ();
sub lilypond_print_element_header
{
  my $fh = shift;
  my $first_in_page = shift;
  my $previous_is_top = shift;
  if ($first_in_page and not @this_page_toc) {
    if (defined($Texi2HTML::THIS_ELEMENT)) {
      # Create the TOC for this page
      @this_page_toc = lilypond_generate_page_toc_body($Texi2HTML::THIS_ELEMENT);
    }
  }
  return T2H_DEFAULT_print_element_header( $fh, $first_in_page, $previous_is_top);
}

# Generate the HTML output for the TOC
sub lilypond_toc_body($)
{
    my $elements_list = shift;
    # Generate a default TOC for pages without THIS_ELEMENT
    @default_toc = lilypond_generate_page_toc_body(@$elements_list[0]);
    return T2H_GPL_toc_body($elements_list);
}


# Print out the TOC in a <div> at the end of th page, which will be formatted as a
# sidebar mimicking a TOC frame
sub print_lilypond_page_foot($)
{
  my $fh = shift;
  my $program_string = &$program_string();
  print $fh "<p><font size='-1'>$program_string</font><br>$PRE_BODY_CLOSE</p>\n";

  # Print the TOC frame:
  my @lines = @this_page_toc;
  # use default TOC if no custom lines have been generated
  @lines = @default_toc if (not @lines);
  if (@lines) {
    print $fh "\n\n<div id=\"tocframe\">";
    print $fh '<h4> ' . $Texi2HTML::NAME{'Contents'}  . "</h4>\n";
    foreach my $line (@lines) {
      print $fh $line;
    }
    print $fh "</div>";
    @this_page_toc = ();
  }

  # Close the page:
  print $fh "</body>\n</html>\n";
}





#############################################################################
###  NICER / MORE FLEXIBLE NAVIGATION PANELS
#############################################################################

sub get_navigation_text
{
  my $button = shift;
  my $text = $NAVIGATION_TEXT{$button};
  if ( ($button eq 'Back') or ($button eq 'FastBack') ) {
    $text = $text . $Texi2HTML::NODE{$button} . "&nbsp;";
  } elsif ( ($button eq 'Forward') or ($button eq 'FastForward') ) {
    $text = "&nbsp;" . $Texi2HTML::NODE{$button} . $text;
  } elsif ( $button eq 'Up' ) {
    $text = "&nbsp;".$text.":&nbsp;" . $Texi2HTML::NODE{$button} . "&nbsp;";
  }
  return $text;
}


# Don't automatically create left-aligned table cells for every link, but
# instead create a <td> only on an appropriate '(left|right|center)-aligned-cell-n'
# button text. It's alignment as well as the colspan will be taken from the
# name of the button. Also, add 'newline' button text to create a new table
# row. The texts of the buttons are generated by get_navigation_text and
# will contain the name of the next/previous section/chapter.
sub lilypond_print_navigation
{
    my $fh = shift;
    my $buttons = shift;
    my $vertical = shift;
    my $spacing = 1;
#     print $fh '<table cellpadding="', $spacing, '" cellspacing="', $spacing,
#       "\" border=\"0\" class=\"nav_table\">\n";
    print $fh "<table class=\"nav_table\">\n";

    print $fh "<tr>" unless $vertical;
    my $beginofline = 1;
    foreach my $button (@$buttons)
    {
        print $fh qq{<tr valign="top" align="left">\n} if $vertical;
        # Allow (left|right|center)-aligned-cell and newline as buttons!
        if ( $button =~ /^(.*)-aligned-cell-(.*)$/ )
        {
          print $fh qq{</td>} unless $beginofline;
          print $fh qq{<td valign="middle" align="$1" colspan="$2">};
          $beginofline = 0;
        }
        elsif ( $button eq 'newline' )
        {
          print $fh qq{</td>} unless $beginofline;
          print $fh qq{</tr>};
          print $fh qq{<tr>};
          $beginofline = 1;

        }
        elsif (ref($button) eq 'CODE')
        {
            &$button($fh, $vertical);
        }
        elsif (ref($button) eq 'SCALAR')
        {
            print $fh "$$button" if defined($$button);
        }
        elsif (ref($button) eq 'ARRAY')
        {
            my $text = $button->[1];
            my $button_href = $button->[0];
            # verify that $button_href is simple text and text is a reference
            if (defined($button_href) and !ref($button_href)
               and defined($text) and (ref($text) eq 'SCALAR') and defined($$text))
            {             # use given text
                if ($Texi2HTML::HREF{$button_href})
                {
                  my $anchor_attributes = '';
                  if ($USE_ACCESSKEY and (defined($BUTTONS_ACCESSKEY{$button_href})) and ($BUTTONS_ACCESSKEY{$button_href} ne ''))
                  {
                      $anchor_attributes = "accesskey=\"$BUTTONS_ACCESSKEY{$button_href}\"";
                  }
                  if ($USE_REL_REV and (defined($BUTTONS_REL{$button_href})) and ($BUTTONS_REL{$button_href} ne ''))
                  {
                      $anchor_attributes .= " rel=\"$BUTTONS_REL{$button_href}\"";
                  }
                  print $fh "" .
                        &$anchor('',
                                    $Texi2HTML::HREF{$button_href},
                                    get_navigation_text($$text),
                                    $anchor_attributes
                                   );
                }
                else
                {
                  print $fh get_navigation_text($$text);
                }
            }
        }
        elsif ($button eq ' ')
        {                       # handle space button
            print $fh
                ($ICONS && $ACTIVE_ICONS{' '}) ?
                    &$button_icon_img($BUTTONS_NAME{$button}, $ACTIVE_ICONS{' '}) :
                        $NAVIGATION_TEXT{' '};
            #next;
        }
        elsif ($Texi2HTML::HREF{$button})
        {                       # button is active
            my $btitle = $BUTTONS_GOTO{$button} ?
                'title="' . $BUTTONS_GOTO{$button} . '"' : '';
            if ($USE_ACCESSKEY and (defined($BUTTONS_ACCESSKEY{$button})) and ($BUTTONS_ACCESSKEY{$button} ne ''))
            {
                $btitle .= " accesskey=\"$BUTTONS_ACCESSKEY{$button}\"";
            }
            if ($USE_REL_REV and (defined($BUTTONS_REL{$button})) and ($BUTTONS_REL{$button} ne ''))
            {
                $btitle .= " rel=\"$BUTTONS_REL{$button}\"";
            }
            if ($ICONS && $ACTIVE_ICONS{$button})
            {                   # use icon
                print $fh '' .
                    &$anchor('',
                        $Texi2HTML::HREF{$button},
                        &$button_icon_img($BUTTONS_NAME{$button},
                                   $ACTIVE_ICONS{$button},
                                   $Texi2HTML::SIMPLE_TEXT{$button}),
                        $btitle
                      );
            }
            else
            {                   # use text
                print $fh
                    '[' .
                        &$anchor('',
                                    $Texi2HTML::HREF{$button},
                                    get_navigation_text ($button),
                                    $btitle
                                   ) .
                                       ']';
            }
        }
        else
        {                       # button is passive
            print $fh
                $ICONS && $PASSIVE_ICONS{$button} ?
                    &$button_icon_img($BUTTONS_NAME{$button},
                                          $PASSIVE_ICONS{$button},
                                          $Texi2HTML::SIMPLE_TEXT{$button}) :

                                              "[" . get_navigation_text($button) . "]";
        }
        print $fh "</td>\n" if $vertical;
        print $fh "</tr>\n" if $vertical;
    }
    print $fh "</td>" unless $beginofline;
    print $fh "</tr>" unless $vertical;
    print $fh "</table>\n";
}


@Texi2HTML::Config::SECTION_BUTTONS =
    ('left-aligned-cell-1', 'FastBack',
     'center-aligned-cell-3', 'Top', 'Contents', 'Index', 'About',
     'right-aligned-cell-1', 'FastForward',
     'newline',
     'left-aligned-cell-2', 'Back',
     'center-aligned-cell-1', 'Up',
     'right-aligned-cell-2', 'Forward'
    );

# buttons for misc stuff
@Texi2HTML::Config::MISC_BUTTONS = ('center-aligned-cell-3', 'Top', 'Contents', 'Index', 'About');

# buttons for chapter file footers
# (and headers but only if SECTION_NAVIGATION is false)
@Texi2HTML::Config::CHAPTER_BUTTONS =
    ('left-aligned-cell-1', 'FastBack',
     'center-aligned-cell-3', 'Top', 'Contents', 'Index', 'About',
     'right-aligned-cell-1', 'FastForward',
    );

# buttons for section file footers
@Texi2HTML::Config::SECTION_FOOTER_BUTTONS =
    ('left-aligned-cell-1', 'FastBack',
     'center-aligned-cell-3', 'Top', 'Contents', 'Index', 'About',
     'right-aligned-cell-1', 'FastForward',
     'newline',
     'left-aligned-cell-2', 'Back',
     'center-aligned-cell-1', 'Up',
     'right-aligned-cell-2', 'Forward'
    );

@Texi2HTML::Config::NODE_FOOTER_BUTTONS =
    ('left-aligned-cell-1', 'FastBack',
     'center-aligned-cell-3', 'Top', 'Contents', 'Index', 'About',
     'right-aligned-cell-1', 'FastForward',
     'newline',
     'left-aligned-cell-2', 'Back',
     'center-aligned-cell-1', 'Up',
     'right-aligned-cell-2', 'Forward'
    );





#############################################################################
###  OTHER SETTINGS
#############################################################################

# For split pages, use index.html as start page!
if ($Texi2HTML::Config::SPLIT == 'section') {
  $Texi2HTML::Config::TOP_FILE = 'index.html';
}


return 1;

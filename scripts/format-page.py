#!/usr/bin/python

import __main__
import getopt
import gettext
import os
import re
import string
import sys

# The directory to hold the translated and menuified tree.
outdir = '/tmp'

# The language.
lang = 'site'

LANGUAGES = (
	('site', 'English'),
	('nl', 'Nederlands'),
	)

localedir = 'out/locale'
try:
	import gettext
	gettext.bindtextdomain ('newweb', localedir)
	gettext.textdomain ('newweb')
	_ = gettext.gettext
except:
	def _ (s):
		return s
underscore = _


'''
NOTES

* Do not use absolute URL locations.  That breaks local installs
  of the website.  Rather, use '../' * depth to get to the root.

* The handling of the Home > url is completely ugh.
'''



# Ugh, data 

header = '''<HTML><!-- Generated by format-page.py; changes will be lost. !-->
<HEAD>
<TITLE>%(title)s</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="%(depth)snewweb.css">
<LINK REL="shortcut icon" HREF="%(depth)simages/shortcut.png">
%(script)s
</HEAD>
<BODY>
'''

top_script = '''<SCRIPT>
  <!--
    function setfocus ()
        {
          document.f_lily_google.brute_query.focus ();
        }
    // !-->
</SCRIPT>
'''

main_template = '''<DIV class="main">
<HR>
%s
<br clear=all>
<HR>
</DIV>
'''

footer = '''
</BODY>'''


menu_template = '''<DIV class="menu">
%s
</DIV>
'''

button_row_template = '''
<TABLE
 cellpadding="0"
 cellspacing="0"
><TR>%(buttonrow)s</TR></table>'''

button_row_spacer = '''<TABLE width="100%%"
 cellpadding="1"
 cellspacing="0">
<tr><td class=menuactive></td></tr>
</TABLE>
<TABLE width="100%%"
 cellpadding="1"
 cellspacing="0">
<tr><td></td></tr>
</TABLE>
'''

location_template = '''<p class="location">
%s
</p>
'''

# don't use mouseover magic as long as we don't have button images

## don't break line after > 
button_template = '''
<TD class="%(class)sleftedge" width=1>
</td>
<TD class="%(class)s">
%(contents)s
</TD><TD class="%(class)srightedge" width=1>
</td>
'''

#
button_active_template = '''<TD class="%(class)s"><A href="%(url)s"
>
%(text)s</A></TD>'''


def read_menu (f):
	# be safe, use output dict = {}
	menu = eval (open (f).read (), __main__.__dict__, {})
	nm = []
	for (file, link) in menu:
		if file[-1] == '/':
			file = file[:-1]
		nm.append ((file, link))

	return nm
    
def one_tab (depth, file):
	'''
	Return the menu to put at the top, and
	the label that you for the > > > bars at the bottom.


	TODO:
	use a dict in menu-entries.py for pages without menu at the top
	(eg. page 1, .. , page 12)
	'''
	
	(dir, here) = os.path.split (file)

	site_dir = string.join (['site'] + string.split (dir, '/')[1:], '/')
	menu_file = os.path.join (site_dir, 'menu-entries.py')
	# use gettext rather than copied and translated menu-py files.
	#if not os.path.exists (menu_file):
	#menu_file = os.path.join (dir, 'menu-entries.py')
	if not os.path.exists (menu_file):
		if re.search ('index.html$', file):
			return ('', '')
		else:
			base = os.path.splitext (here)[0]
			return ('', base)
	
	menu = read_menu (menu_file)
	here_label = filter (lambda x: x[0] == here, menu)

	if not here_label:
		here_label = ''
	else:
		here_label = here_label[0][1]

		
	def entry_to_label (x):
		(file, label) = x
		name = re.sub ("['! ]", '-', label)
		active = 1

		button_dict =  {
			'url' : '../' * depth + file,
			'name' : name,
			'text' : label,
			'root' : '../' * depth
		}
		
		if file == here:
			active = active and (depth > 0)

			button_dict['class'] =  "menuactive"
			button_dict['text'] = '[<b>%s</b>]' % button_dict['text']
		else:
 			button_dict['class'] = "menu"

		contents = '<A href="%(url)s">%(text)s</A>' % button_dict
		button_dict['contents'] = contents

		button = button_template % button_dict
		return button

	labels = []
	toprow = []
	for m in menu:
		# ugh.
		labels.append (entry_to_label (m))
		if m[1] == _ ('Home'):
			labels.append ('<td class="menuunclickable"><b>&gt;</b></td>')

	# FIXME
	
	menu_str = button_row_template % {
		'buttonrow' : string.join (labels, ''),
	}
	if depth> 0 or here_label:
		menu_str = menu_str + button_row_spacer % {} 

	return (menu_str, here_label)

def do_one_file (in_file_name):
	(dir, here) = os.path.split (in_file_name)

	here_dir = dir
	if os.path.isdir (in_file_name):
		here_dir = in_file_name

	try:
		os.makedirs (os.path.join (outdir, dir))
	except:
		OSError
		
	html = open (in_file_name).read ()
	
	file_name = in_file_name
	tabs = []

	depth = 0
	is_index = re.search ('index.html$', file_name)

	locations = []
	while 1:
		(dir, here) = os.path.split (file_name)
		if os.path.exists (os.path.join (dir, 'GNUmakefile')):
			break

		(menu, here_label) = one_tab  (depth, file_name)
		if menu:
			tabs.append (menu)

		if here_label:
			locations.append (here_label)
		file_name = dir

		depth += 1

	tabs.reverse ()
	locations.reverse ()

	# UGH.
	if locations != [_ ('Home')]:
		locations = [_ ('Home')] + locations
	else:
		locations = []

	nav_elts = []
	d = len (locations) - 1
	
	for l in locations:
		if d == 0:
			l = '[<b>%s</b>]' % l

		loc = ''
		if is_index:
			loc = '../' * d
		elif d == 1:
			loc = './'
		elif d > 1:
			loc = '../' * (d-1)

		nav_elts.append ("<a href=%s>%s</a>" % (loc, l))
		d -= 1
	
	nav_str = string.join (nav_elts, ' &gt; ')		
	nav_title = 'LilyPond - ' + string.join (locations[1:], ' - ')
	
	menu = menu_template % string.join (tabs)
	nav_str = location_template % nav_str
	main = main_template % html
	depth_str = ('../' * (depth - 1))

	## AT substitutions.

	titles = [nav_title]
	
	def grab_title (match):
		titles.append (match.group (1))
		return ''

	def grab_ihtml (match):
		s = match.group (1)
		for d in (dir, lang, 'site'):
			n = os.path.join (d, s)
			if os.path.exists (n):
				return open (n).read ()
		return match.group (0)

	def grab_gettext (match):
		return gettext (match.group (1))

	main = re.sub ('<title>(.*?)</title>', grab_title, main)
	main = re.sub ('@DEPTH@', depth_str, main)
	main = re.sub ('@DOC@', os.path.join (depth_str, '../doc/'),
		       main)
	main = re.sub ('@IMAGES@', os.path.join (depth_str, 'images/'),
		       main)
	main = re.sub ('@([-A-Za-z]*.ihtml)@', grab_ihtml, main)
	main = re.sub ('_@([^@]*)@', grab_gettext, main)
	main = re.sub ('\$\Date: (.*) \$', '\\1', main)

	script = ''
	if is_index and depth == 1:
		script = top_script

	rel_name = string.join (string.split (dir, '/')[1:], '/')
	available = filter (lambda x: lang != x[0] \
			    and os.path.exists (os.path.join (x[0], rel_name)),
			    LANGUAGES)
	## python sux
	## av_urls = map (lambda prefix, name: '<a href="%(depth_str)s/%(prefix)s/%(rel_name)s">%(name)s</a>' % vars ())
	## language_menu = string.join (av_urls)

	language_menu = ''
	for prefix, name in available:
		lang_depth = depth * '../'
		language_menu += '<a href="%(lang_depth)s%(prefix)s%(rel_name)s">%(name)s</a>' % vars ()

	# Disable language selection until we have something useful.
	if lang == 'site':
		language_menu = ''

	page = header % {
		'depth': depth_str,
		'title': titles[-1],
		'script': script,
		} + menu + main + nav_str + language_menu + footer
	
	open (os.path.join (outdir, in_file_name), 'w').write (page)

def do_options ():
	global outdir
	(options, files) = getopt.getopt (sys.argv[1:],
					  '',
					  ['outdir=', 'help']) 
	for (o, a) in options:
		if o == '--outdir':
			outdir = a
		elif o == '--help':
			sys.stdout.write (r'''
Usage:
format-page --outdir=DIRECTORY

This script is licensed under the GNU GPL
''')
		else:
			assert unimplemented
	return files

def main ():
	global lang
	files = do_options ()

	for f in files:
		sys.stderr.write ('%s...\n' % f) 
		lang = string.split (f, '/')[0]
		if lang != 'site' and not os.path.exists (f):
			f = string.join (['site'] + string.split (f, '/')[1:],
					 '/')
			sys.stderr.write ('[%s...]\n' % f)
		do_one_file (f)

if __name__ == '__main__':
	main ()


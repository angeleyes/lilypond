mailto(gnu-music-discuss@gnu.org)
COMMENT(-*-text-*-)

redef(var)(1)(whenlatex(latexcommand({\normalfont\scshape )ARG1+latexcommand(}))\
    whenhtml(sc(ARG1)))


def(indexcode)(1)(cindex(ARG1@code(ARG1)))
def(indexandcode)(1)(code(ARG1)indexcode(ARG1))
def(keyindex)(1)(cindex(ARG1@code(\ARG1)))

redef(code)(1)(tt(ARG1))


COMMENT(

  BUGS:

   restStyle=mensural doesn't seem to work (lots of characters not found
     for rests.fly)

TODO:
  
   accordion symbols
)


COMMENT( 
This document contains Mudela fragments.  You need at least
Yodl-1.30.18 to convert this to tex or html.
)

htmlbodyopt(bgcolor)(white)
htmlcommand(<font color=black>)

latexlayoutcmds(
\setlength{\topmargin}{-0.25in}
\setlength{\textheight}{9in}
\setlength{\textwidth}{5.875in} 
\setlength{\oddsidemargin}{0.25in}   
\setlength{\evensidemargin}{0.25in}
\input mudela-book
\usepackage{makeidx}
\makeindex
)

whentexinfo(notableofcontents())

article(LilyPond 1.2.0 Reference Manual)
      (Adrian Mariano, Han-Wen Nienhuys and Jan Nieuwenhuizen)
      (nop()PIPETHROUGH(date "+%B %d, %Y")()()nop())


latexcommand(\def\interexample{})
latexcommand(\def\preexample{\par})
latexcommand(\def\postexample{\par\medskip})
latexcommand(\def\file#1{{code(#1)}})
COMMENT(
latexcommand(\def\texttt#1{\tt #1})
latexcommand(\def\textbf#1{\bf #1})
)

COMMENT(urg, texinfo include breaks)
whenhtml(
includefile(html-disclaimer.yo-urg)
)



sect(Overview)


This nop(document)footnote(This document was revised for LilyPond
1.2.)  describes the the GNU LilyPond input format, which is a
language for defining music.  We call this language Music Definition
Language or Mudela, for short.footnote(If anybody comes up with a
better name, we'd gladly take this. Gourlay already uses Musical
Description Language,  ISO standard
10743 defines a Standard Music Description Language.  We're not being
original here.)

Mudela is a language that allows you  to
itemize(
it() create musical expressions by combining pitches, durations 
it() output those musical expressions to various formats
it() give those musical expressions and output definitions names, so
you can enter them in manageable chunks.
)

Mudela aims to define a piece of music completely, both from
typesetting and from a performance point of view.

sect(Top level)cindex(top level)

This section describes what you may  enter at top level.

subsect(Score definitions)cindex(score definition)

The output is generated combining a music expression with an output
definition.  A score block has the following syntax code(\score {)
var(musicexpr) var(outputdefs) code(}).  var(outputdefs) are zero or
more output definitons.  If no output definiton is supplied, the
default code(\paper) block will be added.

subsect(Information header)cindex(header)keyindex(header)

The syntax is code(\header) code({) var(key1) = var(val1); var(key2) = var(val2); ... code(}))

A header describes the file's contents.  It can also appear in a
code(\score) block.  Tools like indexandcode(ly2dvi) can use this
information for generating titles.  Key values that are used by ly2dvi
are: title, subtitle, composer, opus, poet, instrument, metre,
arranger, piece and tagline.

It is customary to put the code(\header) at the top of the file.

subsect(Setting notenames and chordnames)
label(notenames)

Note name tables can be specified using code(\notenames)keyindex(notenames) code({)
var(assignmentlist) code(}).  var(assignmentlist) is a list of definitions of
the form var(name) = var(pitch).

Chord modifiers can be set analogously, with
code(\chordmodifiers)keyindex(chordmodifiers).



subsect(Output definitions)

A code(\paper) block at top level sets the default paper block.  A
code(\midi) block at top level works similarly.


subsect(GUILE and Scheme)

LilyPond contains a Scheme interpreter (the GUILE library) for
internal use.  The following commands access the interpreter directly.

code(\scm)keyindex(scm) var(scheme)code(;) evaluates the specified Scheme
code.  The result is discarded. keyindex(scm)

code(\scmfile)keyindex(scmfile) var(filename)code(;) reads Scheme code from the
specified file.  The result is discarded. keyindex(scmfile)

subsect(Identifiers)

Identifier assignments may appear at top level.  Semicolons are
forbidden after top level assignments.


sect(Lexical conventions)cindex(Lexical conventions)

subsect(Comments)cindex(Comments)
cindex(%)

A one line comment is introduced by a indexandcode(%)
character.  Block comments are started by code(%{) and ended by
code(%}).  They cannot be nested.


subsect(Keywords)
cindex(keyword)

Keywords start with a backslash, followed by a number of lower case
alphabetic characters.  This are all the keywords.

verb(\accepts \addlyrics \alternative \bar \breathe \cadenza
\chordmodifiers \chords \clef \cm \consists \consistsend \context
\duration \font \grace \header \in \key \keysignature \lyrics \mark
\midi \mm \musicalpitch \name \notenames \notes \paper \partial
\penalty \property \pt \relative \remove \repeat \repetitions \scm
\scmfile \score \script \sequential \shape \simultaneous \skip
\spanrequest \tempo \textscript \time \times \translator \transpose
\type)


subsect(Integers)cindex(Integers)

Formed from an optional minus sign followed by digits.  Arithmetic
operations cannot be done with integers, and integers cannot be mixed
with reals.

subsect(Reals)cindex(Reals) 
Formed from an optional minus sign and a sequence of digits followed
by a em(required) decimal point and an optional exponent such as
code(-1.2e3).  Reals can be built up using the usual operations:
indexandcode(+), indexandcode(-), indexandcode(*), and indexandcode(/), with parentheses for grouping.

A real constant can be followed by one of the dimension keywords:
cindex(dimension) code(\mm)keyindex(mm), code(\pt)keyindex(pt),
code(\in)keyindex(in), or code(\cm)keyindex(cm), for millimeters,
points, inches and centimeters.  This converts the number a real that
is the internal representation of dimensions.

subsect(String)cindex(String) 

Begins and ends with the code(") character.  To include a code(")
character in a string write code(\").  Various other backslash
sequences have special interpretations as in the C language.  A string
that contains no spaces can be written without the quotes.  See
Section ref(modes) for details on unquoted strings; their
interpretation varies depending on the situation.  Strings can be
concatenated with the code(+) operator.




subsect(Tokenizer commands)

The tokenizer accepts the following commands.  They can appear
anywhere.

description(

dit(code(\maininput)) keyindex(maininput) This command is used in init
files to signal that the user file must be read.  It is illegal to use
this command in a user file.

dit(code(\include) var(file))keyindex(include) Include var(file).  The
argument var(file) may be a quoted string, (An unquoted string will
not work here.)  or a string identifier.  The full filename including
the file(.ly) extension must be given,

dit(code(\version) var(string)code(;))
keyindex(version)
Specify the version of LilyPond that a
file was written for.  The argument is a  version string in quotes, for example
code("1.2.0").  This is used to detect invalid input, and to aid
code(convert-mudela), a tool that automatically upgrades input files.
)

subsect(Pitch Names in Other Languages)cindex(other languages)
label(notelang)

Note name definitions have been provided in various languages.  
Simply include the language specific init file.  For example:
code(\include "english.ly").  The available language files and the names
they define are:

verb(                        Note Names               sharp       flat
nederlands.ly  c   d   e   f   g   a   bes b   -is         -es
english.ly     c   d   e   f   g   a   bf  b   -s/-sharp   -f/-flat
deutsch.ly     c   d   e   f   g   a   b   h   -is         -es
norsk.ly       c   d   e   f   g   a   b   h   -iss/-is    -ess/-es
svenska.ly     c   d   e   f   g   a   b   h   -iss        -ess
italiano.ly    do  re  mi  fa  sol la  sid si  -d          -b
catalan.ly     do  re  mi  fa  sol la  sid si  -d/-s       -b)

 Pitch names can be redefined using the
code(\notenames)keyindex(notenames) command, see Subsection
ref(notenames).

subsect(Lexical modes)cindex(Lexical modes)cindex(modes)
label(modes)

To simplify entering notes, lyrics and chrds Mudela has three special
input modes on top of the default mode.  In each mode, words are
identified on the input.  If code("word") is encountered, it is
treated as a string.  If code(\word) is encountered it is treated as a
keyword or as an identifier.  The behavior of the modes differs in two
ways: different modes treat unquoted words differently, and different
modes have different rules for deciding what is a word.

description(
dit(Normal mode)cindex(mode!normal) 
At the start of parsing, Mudela is in normal mode.
In normal mode, a word is an alphabetic character followed by
alphanumeric characters.  If code(word) is encountered on the input it
is treated as a string. 

dit(Note mode) cindex(mode!note) Note mode is introduced by the keyword
code(\notes)keyindex(notes).  In Note mode, words can only contain alphabetic
characters.  If code(word) is encountered, LilyPond first checks for a
notename of code(word).  If no notename is found, then code(word) is
treated as a string.

Since combinations of numbers and dots are used for indicating
durations, it is not possible to enter real numbers in this mode.

dit(Chord mode)cindex(mode!chord) Chord mode is introduced by the keyword
code(\chords)keyindex(chords).  It is similar to note mode, but words are also looked
up in a chord modifier table (containg code(maj), code(dim) etc.)

Since combinations of numbers and dots are used for indicating
durations, you can not enter real numbers in this mode.  Dashes and
carets are used to indicate chord additions and substractions, so
scripts can not be entered in chord mode.

dit(Lyric mode) cindex(mode!lyric) Lyrics mode is introduced by the keyword
code(\lyrics)keyindex(lyrics).  This mode is has rules that make it easy to include
punctuation and diacritical marks in words.  A word in Lyrics mode
begins with: an alphabetic character, code(_), code(?), code(!),
code(:), code('), the control characters code(^A) through code(^F),
code(^Q) through code(^W), code(^Y), code(^^), any 8-bit character
with ASCII code over 127, or a two character combination of a
backslash followed by one of code(`), code('), code(") or
code(^).footnote(The purpose of lyrics mode is that you can enter lyrics in
TeX() format or a standard encoding without needing quotes.  The
precise definition of this mode indeed is ludicrous.  This will remain
so until the authors of LilyPond acquire a deeper understanding of
character encoding, or someone else steps up to fix this.)

Subsequent characters of a word can be any character that is not a
digit and not white space.  One important consequence of this is that
a word can end with code(}), which may be confusing if you thought the
code(}) was going to terminate lyrics mode.footnote(LilyPond will
issue a warning, though).  Any code(_) characters
which appear in an unquoted word are converted to spaces.  This
provides  a
mechanism for introducing spaces into words without using quotes.  
Quoted words can also be used in lyrics mode to specify words that
cannot be specified with the above rules.  Here are some examples.
Not all of these words are printable by TeX().
COMMENT(
DOEXPAND(muckslash)^etre          % a word
)verb(Ah!       % a word
2B_||_!2B       % not a word because it starts with a digit
``Hello''       % not a word because it starts with `
_ _ _ _         % 4 words, each one a space
)


Since combinations of numbers and dots are used for indicating
durations, you can not enter real numbers in this mode.

)

It is possible to create words that break the rules by prefixing them
with the dollar sign indexandcode($).  Regardless of the context, a word
beginning with code($) extends until the next white space character.
Such words can contain numbers (even in Note mode), or other forbidden
characters.  The dollar sign can be used to create and access
identifiers that could not otherwise be used.footnote(Use of $ hampers
readability and portability to future LilyPond versions.  Use of $ is
discouraged.)




sect(Types)cindex(Types and identifiers)

Mudela has a limited set of types:
itemize(
it() integers,
it() reals,
it() strings,
it() music expressions,
it() durations of notes and rests (specified with code(\notenames)keyindex(notenames)),
it() note name tables,
it() context definitions,  Part of output definitions.  See Section ref(contextdefs) for more
information,
it() output definitions (like code(\paper)keyindex(paper) blocks and
code(\midi)keyindex(midi) blocks),
it() score definitions. (code(\score)keyindex(score) blocks)
)


Type is a syntactical property: Mudela has no real type system, so
there is no support for generic expressions, functions or user defined
types.  For the same reason, it is not possible to mix reals and
integers in arithmetic expressions, and ``type errors'' cindex(type error) (eg. using a
string identifier to initialize a code(\paper)keyindex(paper) block)
will yield ``parse error''.

Identifiers allow objects to be assigned to names.  To assign an
identifier you use var(name)=var(value) and to refer to an identifier,
you preceed its name with a backslash: code(\)var(name).  Identifier
assignments must appear at the top level in the Mudela file.
Semicolons are forbidden after assignments appearing at the top level
but they are obligatory after assignments appearing elsewhere.

var(value) is any of the types listed above.

An identifier can be created with any string for its name, but you
will only be able to refer to identifiers whose names begin with a
letter and are entirely alphanumeric.  It is impossible to refer to an
identifier whose name is the same as the name of a keyword.

The right hand side of an identifier assignment is parsed completely
before the assignment is done, so it is legal to redefine an
identifier in terms of its old value: code(foo = \foo * 2.0).


When an identifier is referenced, the information that it points to is
copied.  Therefore it only makes sense to put identifiers for
translators, output definitions and code(\score)keyindex(score) blocks as the first
item in a block.  For this reason, if you reference to a code(\foo)
variable in a code(\foo) block, it must be the first item in the list
following code(\foo).footnote(code(\paper{\one \two}) does not make
sense, because the information of code(\two) would overwrite the
information of code(\one), thereby making the reference to the first
identifier useless.)



sect(Music expressions)cindex(Music expressions)

Music in mudela is entered as a music expression.  Notes, rests, lyric
syllables are music expressions (the atomic expressions),
cindex(atomic music expressions) and you can
combine music expressions to form new ones.  This example
forms a compound expressions out of the quarter code(c)   note and a
code(d) note:COMMENT(

)verb(\sequential { c4 d4 })COMMENT(

)The meaning of this compound expression is to play the code(c) first,
and then the code(d) (as opposed to playing them simultaneously, for
instance).

Atomic music expression are discussed in
bind(Subsection)ref(atomicmusic).  Compound music expressions are
discussed in bind(Subsection)ref(compoundmusic).

sect(Atomic music expressions)
label(atomicmusic)

subsect(Pitch and duration)cindex(pitch)cindex(duration) 

The syntax for pitch specification is
code(\musicalpitch)keyindex(musicalpitch) code({) var(octave)
var(note) var(shift) code(}) The octave is specified by an integer,
zero for the octave containing middle C.  The note is a number from 0
to 7, with 0 corresponding to C and 7 corresponding to B.  The shift
is zero for a natural, negative to add flats, or positive to add
sharps.

In note and chord mode,  pitches may be designated by names. 
See Section ref(notelang) for pitch names in different languages.

The syntax for duration specification is
code(\duration)keyindex(duration) code({) var(length) var(dotcount)
code(}) var(length) is the negative logarithm (base 2) of duration: 1
is a half note, 2 is a quarter note, 3 is an eighth note, etc.  The
number of dots after the note is given by var(dotcount).

In note, chord and lyric mode, durations may be designated by numbers
and dots. See Section ref(notelang) for details.




subsect(Note specification)label(notedesc)

cindex(Note Specification)
cindex(pitches)cindex(entering notes)

A note specification has the form
var(pitch)[var(octavespec)][code(!)][code(?)][var(duration)].  The
pitch of the note is specified by the note's name.

subsubsect(Pitches)

The default names are the Dutch note names.  The notes are specified
by the letters code(c) through code(b), where code(c) is an octave
below middle C and the letters span the octave above that C.  In
Dutch,cindex(notenames!Dutch) a sharp is formed by adding code(-is) to
the end of a pitch name.  A flat is formed by adding code(-es).
Double sharps and double flats are obtained by adding code(-isis) or
code(-eses).  code(aes) and code(ees) are contracted to code(as) and
code(es) in Dutch, but both forms will be accepted.q


Lily has predefined sets of notenames for various
languages.  See Section ref(notelang) for details.

subsubsect(Octaves)

The optional octave specification takes the form of a series of single
quote indexandcode(') characters or a series of comma indexandcode(,)
characters.  Each code(') raises the pitch by one octave; each code(,)
lowers the pitch by an octave.

mudela(fragment,verbatim,center)(
c' d' e' f' g' a' b' c''
)

mudela(fragment,verbatim,center)(
cis' dis' eis' fis' gis' ais' bis'
)

mudela(fragment,verbatim,center)(
ces' des' es' fes' ges' as' bes'
)

mudela(fragment,verbatim,center)(
cisis' eisis' gisis' aisis' beses'
)

mudela(fragment,verbatim,center)(
ceses' eses' geses' ases' beses'
)

Whenever a C-sharp is desired,  you must specify a C-sharp.  LilyPond
will determine what accidentals to  typeset  depending on the  key and
context.   
A reminder accidental cindex(reminder accidental) can be forced by
adding an exclamation mark `code(!)'
after the pitch.
A cautionary accidental, cindex(cautionary accidental) i.e., an accidental within parentheses
can be obtained by adding the question mark `indexandcode(?)' after
the pitch.COMMENT(

)mudela(fragment,verbatim,center)(
cis' d' e' cis'  c'? d' e' c'!  
)

subsubsect(Duration)
cindex(duration)

Durations are entered as their reciprocal values. For notes longer
than a whole note, use identifiers.
verb(
  c'\longa c'\breve  
  c'1 c'2 c'4 c'8 c'16 c'32 c'64 c'64 
)
mudela()(
\score {
       \notes \relative c'' {
         a\longa a\breve  
         a1 a2 a4 a8 a16 a32 a64 a64 
         }
         \paper {
		loose_column_distance = 2.5 * \interline;
        	linewidth = -1.0;
        	\translator { \type "Score_engraver";
        		    \name "Score";
        		    \consists "Note_heads_engraver";
        		    \consists "Stem_engraver";
        		    \consists "Rhythmic_column_engraver";
         }}})
verb(
  r\longa r\breve  
  r1 r2 r4 r8 r16 r32 r64 r64 
)mudela()(\score {
       \notes \relative c'' {
         r\longa r\breve  
         r1 r2 r4 r8 r16 r32 r64 r64 
         }
         \paper {
		loose_column_distance = 2.5 * \interline;
        	linewidth = -1.0;
        	\translator { \type "Score_engraver";
        		    \name "Score";
        		    \consists "Rest_engraver";
        		    \consists "Stem_engraver";
        		    \consists "Rhythmic_column_engraver";
         } }})

If the duration is omitted then it is set equal to the previous
duration.  If there is no previous duration, then a quarter note is
assumed.  The duration can be followed by a dot indexandcode(.) to
obtain dotted note lengths.  COMMENT(

)mudela(fragment,verbatim,center)(
a'4. b'4.
)

You can alter the length of duration by writing code(*)var(fraction)
after a it.  This will not affect the appearance of noteheads or
rests.

subsubsect(Rests)

Rests are entered like notes, with note name indexandcode(r),
indexandcode(s) or indexandcode(R).  There is also a note name which
produces a nonprinting note of the specified duration. code(R) is
specifically  meant for entering parts: the code(R) rest can expand to
fill a score with rests, or it can be printed as a single multimeasure resst.

subsubsect(Lyrics syllables)cindex(Lyric expressions)

Syllables are entered like notes, with pitches replaced
by text.  For example code(Twin-4 kle4 twin-4 kle4) enters four
syllables, each with quarter note duration.  Note that the hyphen has
no special meaning for lyrics, and does not introduce special symbols.
See Section ref(modes) for a description of what is interpreted as a lyric.

Spaces can be introduced into a lyric either by using quotes (code("))
or by using an underscore without quotes: code(He_could4 not4).  All
unquoted underscores are converted to spaces.  Printing lyrics is
discussed in Section ref(lyricprint).

subsect(Properties)cindex(Properties)

code(\property)keyindex(property) var(contextname)code(.)var(propname) code(=) var(value)
Sets the var(propname) property of the context var(contextname) to the
specified var(value).  All three arguments are strings.  Depending on
the context it may be necessary to quote the strings or to leave space
on both sides of the dot. 

subsect(Translator switches)cindex(Translator switches)

code(\translator)keyindex(translator) var(contexttype) = var(name)
A music expression that the context which is a direct child of the 
a  context of type var(contexttype) should be shifted to a context of
type var(contexttype) and  the specified name.  

Usually this is used to switch staffs in Piano music,
eg. code(\translator Staff = top )var(Music)

subsect(Commands)cindex(Commands)

Commands are music expressions that have no duration.   

subsubsect(Key signatures)

code(\key)keyindex(key) var(pitch) var(type) code(;) Change the key
signature.  var(type) should be code(\major)keyindex(major) or code(\minor)keyindex(minor)
to get var(pitch)-major or var(pitch)-minor, respectively. The second
argument is optional, the default is major keys.  The var(\context)
argument can also be given as an integer, which tells the number of
semitones that should be added to the pitch given in the subsequent
code(\key)keyindex(key) commands to get the corresponding major key,
e.g. code(\minor)keyindex(minor) is defined as 3.  The standard mode names
code(\ionian)keyindex(ionian), code(\locrian)keyindex(locrian), code(\aeolian)keyindex(aeolian),
code(\mixolydian)keyindex(mixolydian), code(\lydian)keyindex(lydian), code(\phrygian)keyindex(phrygian), and
code(\dorian)keyindex(dorian) are also defined.


code(\keysignature)keyindex(keysignature) var(pitchseq)code(;)
Specify an arbitrary key signature.  The pitches from var(pitch) will
be printed in the key signature in the order that they appear on the list.


subsubsect(Rehearsal marks)
        
code(\mark)keyindex(mark) var(unsigned)code(;) or code(\mark)
var(string)code(;) A music expression.  Prints a mark over or under
(depending on the indexandcode(markDirection) property) the staff.  You must
add indexandcode(Mark_engraver) to the either Score or Staff context for this
to work.


subsubsect(Bar lines)

code(\bar)keyindex(bar) var(bartype)code(;) This is a request to print
a special bar symbol, or at measure boundaries.  It replaces the
regular bar symbol with a special symbol.  The argument var(bartype)
is a string which specifies the kind of bar to print.  Options are
indexandcode(":|"), indexandcode("|:"), indexandcode(":|:"),
indexandcode("||"), indexandcode("|."), indexandcode(".|"), or
indexandcode(".|.").  These produce respectively a right repeat, a
left repeat, a double repeat, a double bar, a start bar, an end bar,
or a thick double bar.  If var(bartype) is set to code("empty") then
nothing is printed, but a line break is allowed at that spot.

You are encouraged to use code(\repeat) for repetitions. See Section ref(sec:repeats)

subsubsect(Timing commands) 

code(\cadenza)keyindex(cadenza) var(togglevalue)code(;) Music expression that
toggles the automatic generation of bar lines.  If var(togglevalue) is
0 then bar line generation is turned off.  If var(togglevalue) is 1
then a bar is immediately printed and bar generation is turned on.

code(\time)keyindex(time) var(numerator)code(/)var(denominator)code(;) Change the time
signature.  The default time signature is 4/4.  The time signature is
used to generate bar lines.

code(\partial )var(duration)code(;) Music expression that makes
the first measure of the music last for the specified duration.  keyindex(partial)

code(\tempo)keyindex(tempo) var(duration) = var(perminute)code(;) Used
to specify the tempo.  For example, `code(\tempo 4 = 76;)' requests
output with 76 quarter notes per minute.

code(\partial)keyindex(partial)var( duration)code(;) This creates an incomplete
measure at the start of the music, eg.  code(\partial 8*2;) creates a
starting measure lasting two eighth notes.cindex(anacrusis)cindex(upstep)

code(|)cindex(|)cindex(barcheck)

code(|) is a barcheck.  Whenever a barcheck is encountered during
interpretation, a warning message is issued if it doesn't fall at a
measure boundary.  This can help you finding errors in the input. The
beginning of the measure will also be relocated, so this can also be
used to shorten measures.cindex(shorten measures)cindex(upstep)

subsubsect(Other commands)

code(\penalty)keyindex(penalty) var(int)code(;) 
Discourage or encourage line breaks.  See identifiers code(\break)keyindex(break) and
code(\nobreak)keyindex(nobreak) in Section ref(ident). 

code(\clef)keyindex(clef) var(clefname)code(;) Music expression that
sets the current clef.  The argument is
a string which specifies the name of the clef.  Several clef names are
supported.  If code(_8) or code(^8) is added to the end of a clef
name then the clef lowered or raised an octave will be generated.  
Here are the supported clef names with middle C shown in each clef:
mudela(center)(
\score{
  \notes{ \cadenza 1;
   %\property Voice.textStyle = typewriter
   \clef subbass; c'4-"\kern-10mm subbass" 
           \clef bass;    c'4^"\kern -8mm bass"
           \clef baritone; c'4_"\kern -10mm baritone"
           \clef varbaritone; c'4^"\kern -10mm varbaritone"
           \clef tenor;     c'4_"\kern -10mm tenor"
           \clef "G_8";   c'4^"\kern -6mm G\_8" 
   }  
   \paper{ linewidth= 4.5 \in; }
}
)
mudela(center)(
\score{
  \notes{\cadenza 1; \clef alto;    c'4_"\kern -10mm alto"
           \clef mezzosoprano; c'4^"\kern -10mm mezzosoprano"
           \clef soprano;  c'4_"\kern -10mm soprano"
           \clef treble;  c'4^"\kern -6mm treble"
           \clef french;  c'4_"\kern -10mm french" }  
  \paper{ linewidth= 4.5 \in; }
}
)
The treble  clef  can also  be obtained using  the  names code(G) or
code(violin).  The bass clef is also available by code(\clef  F). 

code(\skip)keyindex(skip) var(duration)code(;) Skips the amount of time
specified by var(duration).  If no other music is played, a gap will
be left for the skipped time with no notes printed.  It works in Note
Mode or Lyrics Mode.  In note mode, this has the same effect as the
space rest code(s).


subsubsect(Beams)cindex(beams)
label(manualbeam)

A beam is specified by surrounding the beamed notes with brackets
indexandcode([) and indexandcode(]).  
mudela(fragment,verbatim,center)(
[a'8 a'] [a'16 a' a' a'] 
)
Some more elaborate constructions:
mudela(fragment,verbatim,center)(
[a'16 <a' c''> c'' <a' c''>]
\times 2/3 { [e'8 f' g'] }
)

Beaming can be generated automatically see Section ref(autobeam).

cindex(Tremolo beams)

To place tremolo marks in between two notes, begin with
code([:)var(length) and end with code(]).  The tremolo marks will
appear instead of beams.  Putting more than two notes in such a
construction will produce odd effects.
  
mudela(fragment,verbatim,center)(
  [:16 e'1 g'] [:8 e'4 f']
)
  
mudela(fragment,verbatim,center)(
  c'4:32 [:16 c'8 d'8]
)

COMMENT(ref to normal tremolos?)

subsubsect(Lyric helpers)
cindex(--)cindex(__)cindex(extender)cindex(hyphen)

The syntax for an extender mark is code(__).  This syntax can only be
used within lyrics mode.  The syntax for a spanning hyphen (a hyphen
that will be printed between two lyric syllables) is code(-)code(-)



subsubsect(Tie)cindex(tie)

A tie connects two adjacent note heads of the same pitch.  When used
with chords, it connects all of the note heads whose pitches match.
Ties are indicated using the tilde symbol indexandcode(~).
If you try to tie together chords which have no common pitches, a
warning message will appear. No ties will be created.  COMMENT(

)mudela(fragment,verbatim,center)(
e' ~ e' <c' e' g'> ~ <c' e' g'>
)

subsect(Atomic music expressions: add-ons)

[TODO: explain Requests]


subsubsect(Articulations)cindex(articulations)cindex(scripts)cindex(ornaments)

A variety of symbols can appear above and below notes to indicate
different characteristics of the performance.  These symbols can be
added to a note with `var(note)code(-\)var(name)'.  Numerous symbols
are defined in file(script.ly) and file(script.scm).  Symbols can be
forced to appear above or below the note by writing
`var(note)code(^\)var(name)' and `var(note)code(_\)var(name)'
respectively. Here is a chart showing symbols above notes, with the
name of the corresponding symbol appearing underneath.

mudela()(
\score{
 < \notes{ c''-\accent c''-\marcato c''-\staccatissimo f'-\fermata 
          c''-\stopped c''-\staccato c''-\tenuto c''-\upbow c''-\downbow
          c''-\lheel c''-\rheel  c''-\ltoe  c''-\rtoe  c''-\turn
          c''-\open  c''-\flageolet  c''-\reverseturn 
          c''-\trill
          c''-\prall c''-\mordent c''-\prallprall  c''-\prallmordent
          c''-\upprall c''-\downprall c''-\thumb c''-\segno c''-\coda}
  \context Lyrics \lyrics{  
        accent__ marcato__ staccatissimo__ fermata stopped__
        staccato__ tenuto__ upbow downbow__ lheel__ rheel__ ltoe
        rtoe__ turn__ open__ flageolet reverseturn__ trill__ prall__
        mordent prallprall__ prallmordent__ uprall__ downprall thumb 
	segno coda }
  >
  \paper{ linewidth = 5.875\in;          
          indent = 0.0;        }
 }
)

In addition, it is possible to place arbitrary strings of text or
TeX() above or below notes by using a string instead of an identifier:
`code(c^"text")'.  Fingerings cindex(fingering) can be placed by
simply using digits.  All of these note ornaments appear in the
printed output but have no effect on the MIDI rendering of the music.

To save typing, fingering instructions (digits 0 to 9 are supported)
and a few common symbols can be abbreviated with single characters:
COMMENT(

)mudela()(
\score{ \notes {
        \property Voice.textStyle = typewriter
        c''4-._"c-." s4
        c''4--_"c-{}-"  s4
        c''4-+_"c-+" s4
        c''4-|_"c-|" s4
        c''4->_"c->"  s4
        c''4-^_"c-\\^{ }"  s4
	c''4-1_"c-1" s4
	c''4-2_"c-2" s4
	c''4-3_"c-3" s4
	c''4-4_"c-4" s4
	}
%        \paper { linewidth = 12.\cm; }
})

Dynamic marks are specified by using an identifier after a note:
code(c4-\ff).  The available dynamic marks are: keyindex(pppp),
code(\ppp)keyindex(ppp), code(\pp)keyindex(pp), code(\p)keyindex(p),
code(\mp)keyindex(mp), code(\mf)keyindex(mf), code(\f)keyindex(f),
code(\ff)keyindex(ff), code(\fff)keyindex(fff),
code(\ffff)keyindex(ffff), code(\fp)keyindex(fp),
code(\sf)keyindex(sf), code(\sff)keyindex(sff), code(\sp)keyindex(sp),
code(\spp)keyindex(spp), code(\sfz)keyindex(sfz) and
code(\rfz)keyindex(rfz).

subsubsect(General text scripts)

code(\textscript)keyindex(textscript) var(text) var(style).  Defines a text to be
printed over or under a note.  var(style) is a string that may be one
of code(finger), code(roman), code(italic), code(dynamic), code(Large)
or code(large).  

You can attach a general textscript request using this syntax
verb(c4-\textscript "6" "finger"
c4-\textscript "foo" "normal"
)
This is equivalent with code(c4-6 c4-"foo").  

subsubsect(General scripts)cindex(scripts)

Syntax: code(\script)keyindex(script) var(alias).

 Prints a symbol above or below a note.  The argument is a string
which points into the script-alias table defined in file(script.scm).
The scheme definitions specify whether the symbol follows notes into
the staff, dependence of symbol placement on staff direction, and a
priority for placing several symbols over one note.  Usually the
code(\script)keyindex(script) keyword is not used directly.  Various
helpful identifier definitions appear in file(script.ly).


subsubsect(Slur)cindex(Slur)

Slurs connects chords and try to avoid crossing stems.  A slur is
started with code(CHAR(40)) and stopped with code(CHAR(41)).  The
starting code(CHAR(40)) appears to the right of the first note in the
slur.  The terminal code(CHAR(41)) apppears to the left of the first
note in the slur.  This makes it possible to put a note in slurs from
both sides: COMMENT(

)mudela(fragment,verbatim,center)(
f'()g'()a' [a'8 b'(] a'4 g'2 )f'
)


subsubsect(Crescendo)cindex(Crescendo)

A crescendo mark is started with code(\cr)keyindex(cr) and terminated with
code(\rc)keyindex(rc).  A decrescendo mark is started with code(\decr)keyindex(decr) and
terminated with code(\rced)keyindex(rced).  There are also shorthands for these
marks.  A crescendo can be started with code(\<)keyindex(<) and a decrescendo can
be started with code(\>)keyindex(>).  Either one can be terminated with code(\!)keyindex(!).
Note that code(\!) must go before the last note of the dynamic mark whereas
code(\rc) and code(\rced) go after the last note.  Because these marks are
bound to notes, if you want to get several marks during one note, you must use
spacer notes. COMMENT(

)mudela(fragment,verbatim,center)(
c'' \< \! c''   d'' \decr e'' \rced 
< f''1 {s4 \< \! s2 \> \! s2 } >)



subsubsect(General spanners)

code(\spanrequest)keyindex(spanrequest) var(startstop) var(type).
Define a spanning request var(startstop) is either -1
(code(\start)keyindex(start)) or 1 (code(\stop)keyindex(stop)). The
var(type) parameter is a string that describes what should be started.
Supported types are code(crescendo), code(decrescendo), code(beam),
code(slur).  This is an internal command.  Users should use the
abbreviations which are defined in the initialization file
file(spanners.ly).

You can attach a (general) span request to a note using
mudela(fragment,center)(
c4-\spanrequest \start "slur"
c4-\spanrequest \stop "slur"
)
The slur syntax with parentheses is an abbreviation of this.

COMMENT(came till here with indexifying)

subsubsect(Tremolo marks)cindex(Tremolo marks)

Tremolo marks can be printed by a single note by adding code(:)[var(length)]
after the note.  The length must be at least 8.  A var(length) value
of 8 gives one line across the note stem.  
If the length is omitted,
then the last value is used, or the value of the code(abbrev)
property if there was no last value.
mudela(verbatim,fragment,center)(c'2:8 c':32
)

sect(Compound music expressions)cindex(Compound music expressions)
label(compoundmusic)


Music expression are a compound data structure.  You can nest music
expressions any way you like.  This simple example shows how three
chords can be expressed in two different ways: COMMENT(

)mudela(fragment,verbatim,center)(
\notes\context Staff{
  <a c'> <b  d' > <c' e' >
  <{a b  c'}{c' d' e'}>
})


subsect(Context selection)cindex(Context selection)

code(\context)keyindex(context) var(contexttype) [code(=) var(contextname)]
var(musicexpr)

Interpret var(musicexpr) within a context of type var(contexttype).
If the context does not exist, it will be created.  The new context
can optionally be given a name.  See Section ref(contextselection) and
ref(contextdefs) for more
information on interpretation contexts.

subsect(Music entry modes)
cindex(input modes)
cindex(mode switch)

Mode switching keywords form compound music
expressions:keyindex(notes)keyindex(chords)keyindex(lyrics)
code(\notes )var(musicexpr), code(\chords )var( musicexpr), and
code(\lyrics )var(musicexpr).  These expressions do not add anything
to the meaning of their arguments.  They are just a way to indicat
that the arguments should be parsed in indicated mode. See Section
ref(modes) for more information on modes.


More information on context selection can be found in Section ref(contextselection)


subsect(Sequential music)cindex(Sequential music)
keyindex(sequential)

The syntax is code(\sequential)code( {)var(musicexprlist)code( }).  This means that list should be played or
written in sequence, i.e., the second after the first, the third after
the second.  The duration of sequential music is the the sum of the
durations of the elements.  There is an abbreviated form, which leaves
out the keyword: code({ )var(musicexprlist )code( }).


subsect(Simultaneous music)cindex(Simultaneous music)

The syntax is code(\simultaneous)keyindex(simultaneous)code({)var(
musicexprlist )code(}).  It constructs a music expression where all of
its arguments start at the same moment.  The duration is the maximum
of the durations of the elements.  The abbreviated form, code(<)
var(musicexprlist) code(>) is common idiom.

If you try to use a chord as the first thing in your score, you
might get multiple staffs in stead of a chord.COMMENT(

)mudela(verbatim)(\score { \notes <c''4 e''>
	\paper { linewidth = -1.; }
})COMMENT(

) This happens because the chord is interpreted by a score context.
Each time a note is encountered a default Voice context (along with a
Staff context) is created. The solution is to explicitly instantiate a
Voice context:
mudela(verbatim,center)(\score { \notes\context Voice <c''4 e''>
  \paper { linewidth = -1.; }
})


subsect(Relative Pitch Specification)cindex(Relative Pitch Specification)
label(relative)

It is easy to get confused by octave changing marks and accidentally
put a pitch in the wrong octave.  A much better way of entering a
note's octave is `the relative octave' mode.

The syntax for relative mode is code(\relative)keyindex(relative)
var(startpitch) var(musicexpr).

The octave of notes that appear in var(musicexpr) are calculated as
follows: when no octave changing marks are used, the basic interval
between this and the last note is always taken to be a fourth or
less.footnote(The interval is determined without regard accidentals.
A code(fisis) following a code(ceses) will be put above the
code(ceses)) The octave changing marks code(') and code(,) can then be
added to raise or lower the pitch by an extra octave.  Upon entering
relative mode, an absolute starting pitch must be specified that will
act as the predecessor of the first note of var(musicexpr).

Entering scales is straightforward in relative mode.

mudela(fragment,verbatim,center)(
\relative c' { c d e f g a b c c, }
)

and octave changing marks are used for intervals greater than a fourth.

mudela(fragment,verbatim,center)(
\relative c'' { c g c f, c' a,, e''' }
)

When the preceding item is a chord, the first note of the chord is used to
determine the first note of the next chord.  But other notes within the second
chord are determined by looking at the immediately preceding note.  

mudela(fragment,verbatim,center)(
\relative c' { c <c e g> 
    <c' e g> <c, e' g> }
) 

The pitch after the code(\relative) contains a notename. To parse the
pitch as a notename, you have to be in note mode, so there must be a
surrounding code(\notes)keyindex(notes) keyword (which is not shown here).

The relative conversion will not affect code(\transpose) or
code(\relative) sections in its argument.  If you want to use relative
within transposed music, you must place an additional code(\relative)
inside the code(\transpose).

You are strongly recommended to use relative pitch mode: it is less
work, less error-prone and more readable.



subsect(Chord names)

Chord names are a way to generate simultaneous music expressions that
correspond with traditional chord names. It can only be used in chord
mode (See Section ref(modes)).  The syntax is
var(tonic)[var(duration)][code(-)var(modifiers)][code(^)var(substractions)][code(/)var(inversion)].
var(tonic) should be the tonic note of the chord, and the var(duration) is
the chord duration in the usual notation.  There are two kinds of modifiers.
One type is chord additions, which are obtained by listing intervals separated
by dots.  An interval is written by its number with an optional code(+) or
code(-) to indicate raising or lowering by half a step.  A chord additions has
two effects:  it adds the specified interval and all lower odd numbered
intervals to the chord, and it may lower or raise the specified interval.
Intervals must be separated by a dot (code(.)).
COMMENT(

)mudela(fragment,verbatim)(
\transpose c''{ 
\chords{
  c1 c-3- c-7 c-8 c-9  
  c-9-.5+.7+ c-3-.5- c-4.6.8
}})COMMENT(

)The second type of modifier that may appear after the code(-) is 
a named modifier. 
Named modifiers are listed in the file file(chord-modifiers.ly).  The
available modifiers are code(m) and code(min) which lower
the 3rd half a step, indexandcode(aug) which raises the 5th, indexandcode(dim) which lowers
the 5th, indexandcode(maj) which adds a raised 7th, and indexandcode(sus) which replaces the
5th with a 4th.  
mudela(fragment,verbatim,center)(
\transpose c''{ 
\chords{
  c1-m c-min7 c-maj c-aug c-dim c-sus
}}) 

Chord substractions are used to eliminate notes from a chord.  The notes to be
substracted are listed after a code(^) character, separated by dots.  
mudela(fragment,verbatim,center)(
\transpose c''{ 
\chords{
  c1^3 c-7^5.3 c-8^7
}}) 

Chord inversions can be specified by appending indexandcode(/) and the name of a
single note to a chord.  This has the effect of lowering the specified note by
an octave so it becomes the lowest note in the chord.  If the
specified note is not in the chord then a warning will be printed.  
mudela(fragment,verbatim,center)(
\transpose c'''{ 
  \chords { c1 c/e c/g c-7/e }
}) 
Throughout these examples, chords have been shifted around the staff
using code(\transpose).  b

You should  not combine code(\relative)  with named chords. 




subsect(Tuplets)cindex(Tuplets)

Tuplets are made out of a music expression by multiplying their
duration with a fraction.  The syntax is code(\times)keyindex(times) var(fraction)
var(musicexpr).

The duration of var(musicexpr) will be multiplied by the fraction.
In print, the fraction's denominator will be printed over the notes,
optionally with a bracket.  The most
common tuplet is the triplet in which 3 notes have the length of 2, so
the notes are 2/3 their written length:
COMMENT(

)mudela(fragment,verbatim,center)( b'4 \times 2/3 {c'4 c' c'} d'4 d'4 )

subsect(Grace notes)cindex(Grace notes)

Grace notes are specified as code(\grace )keyindex(grace )var(musicexpr).  A grace
note expression has duration 0; the next real note is assumed to the
main note.

You cannot have the grace note after the main note, terms of duration
and main notes, but you can typeset the grace notes to the right of
the main note using the property indexandcode(graceAlignPosition).

When grace music is interpreted, a score-within-a-score is set up:
var(musicexpr) has its own time bookkeeping, and you could (for
example) have a separate time signature within grace notes.  Within
this score-within-a-score you can create notes, beams, slurs,
etc. Unbeamed eighth notes and shorter by default have a slash through
the stem.  This behavior can be controlled with the
indexandcode(stemStyle) property.

mudela(fragment)(
  \relative c'' { \grace c8 c4 \grace { [c16 c16] } c4
    \grace { \property Grace.stemStyle = "" c16 } c4 }
)

At present nesting code(\grace)keyindex(grace) notes, eg. code(\grace { \grace
c32 c16} c4) may result in run-time errors of LilyPond.  Since the
meaning of such a construct is unclear, we don't consider this a loss.
Similarly, juxtaposing two code(\grace) sections syntactically valid,
but makes no sense and may cause runtime errors.

Ending a staff or score with grace notes may generate a run-time
error, since there will be no main note to attach the grace notes to.

subsect(Repeats)cindex(Repeats)
label(sec:repeats)

In order to specify repeats, use the code(\repeat)keyindex(repeat) keyword.  Since
repeats look and sound differently when played and when printed, there are a few
different variants of repeats.

description(
dit(unfolded) repeated music is fully written (played) out.  Useful
for  MIDI output.
dit(volta)  This is the normal notation: repeats are not
written out, but alternative endings (voltas), are printed, left to right.
dit(folded) alternative endings are written stacked, which is useful
for lyrics.
)  

The syntax for repeats is code(\repeat) var(variant) var(repeatcount)
var(repeatbody).  If you have alternative endings, you may add
code(\alternative)keyindex(alternative)code( { )var(alternative1)
var(alternative2) var(alternative3) .. code( }), where each
var(alternative) is a  Music expression.

Normal notation repeats are used like this:
mudela(fragment,verbatim,center)(
c'1
\repeat volta 2 { c'4 d' e' f' }
\repeat volta 2 { f' e' d' c' })

With alternative endings:
mudela(fragment,verbatim,center)(
c'1
\repeat volta 2 {c'4 d' e' f'} 
\alternative { {d'2 d'} {f' f} })

Folded repeats look like this:footnote(Folded repeats offer little
more over simultaneous music.  However, it is to be expected that more
functionality --especially for the MIDI backend-- will be implemented) 


mudela(fragment,verbatim,center)(
c'1
\repeat fold 2 {c'4 d' e' f'} 
\alternative { {d'2 d'} {f' f} })

mudela(fragment,verbatim)(
\context Staff { \relative c'{
  \partial 4; \repeat volta 2 {  e | c2 d2 | e2 f2 | }
  \alternative { { g4 g g } {  a a a a  b1 } }
}})

If you don't give enough alternatives for all of the repeats, then the
first alternative is assumed to be repeated often enough to equal the
specified number of repeats.  
mudela(fragment,verbatim)(
\context Staff { \relative c'{
  \repeat volta 3 { \partial 4; e | c2 d2 | e2 f2 | }
  \alternative { { g4 g g } {\partial 1; e4 e e } 
                 {\partial 1; a a a a | b1 } }
}})



It is possible to nest code(\repeat).  This is not entirely supported:
the notes will come be in the right places, but the repeat bars will
not.




subsect(Tranposition of Pitches)cindex(Tranposition of Pitches)
label(transpose)

A music expression can be transposed with code(\transpose)keyindex(transpose).
The syntax is code(\transpose) var(pitch) var(musicexpr)
This means that middle C in var(musicexpr) is tranposed to var(pitch). 

code(\transpose) distinguishes between enharmonic pitches: both
code(\transpose cis') or code(\transpose des') will transpose up half
a tone.  The first version will print sharps and the second version
will print flats.    COMMENT(

)mudela(fragment,verbatim)(
\context Staff {
  \clef "F"; { \key e; c d e f } \clef "G";
  \transpose des'' { \key e; c d e f }
  \transpose cis'' { \key e; c d e f } }
)


If you want to use both code(\transpose) and code(\relative), then you
must use code(\transpose) first.  code(\relative) will have no effect
music that appears inside a code(\transpose).

 
subsect(Automatic lyric durations)cindex(Automatic lyric durations)

If you have lyrics that are set to a melody, you can import the rhythm
of that melody into the lyrics using code(\addlyrics).
keyindex(addlyrics) The syntax for this is code(\addlyrics)
var(musicexpr1 musicexpr2).  This means that both var(musicexpr1) and
var(musicexpr2) are interpreted, but that every non-command atomic
music expression (``every syllable'') in var(musicexpr2) is
interpreted using timing of var(musicexpr1).

If the property code(automaticMelismata) is set in the context of
var(musicexpr1), then no lyrics will be put on slurred and tied notes.

Example
COMMENT(

)mudela(verbatim,fragment)(
	\addlyrics
		\transpose c'' {
			\property Voice.automaticMelismata = "1"
			c8 () cis d8. e16 f2 }
		\context Lyrics \lyrics { do4 re mi fa }
)COMMENT(

)You should use a single rhythm melody, and single rhythm lyrics (a
constant duration is the obvious choice).  If you do not, you will get
undesired effects when using multiple stanzas: COMMENT(

)mudela(verbatim,fragment)(
	\addlyrics
		\transpose c'' { c8 () cis d8. e16 f2 }
		\context Lyrics \lyrics < { do4 re mi fa }
					  { do8 re mi fa } >
)

It is valid (but probably not very useful) to use notes in stead of  lyrics
for var(musicexpr2). COMMENT(

mudela(verbatim,fragment)(
	\context Voice \addlyrics
		{ s4 s8 s16 s32 }
		{ [c16 c c c] }))

	


sect(Ambiguities)cindex(ambiguities)

The grammar contains a number of ambiguities.footnote(The authors hope
to resolve them at a later time.)

itemize(
it()
The assignment
verb(
foo = bar)
COMMENT(

)Can be interpreted as making a string identifier code(\foo)
containing code("bar"), or a music identifier code(\foo) containing
the syllable `bar'.

it()The assignment
verb( foo = -6
)Can be interpreted as making a integer identifier containing -6, or a
Request identifier containing the fingering `6' (with neutral direction).

it()
If you do a nested repeat,
verb(
\repeat ...
  \repeat ..
  \alternative
  ) then it is ambiguous to which code(\repeat) the code(\alternative)
  belongs. This is the classic if-then-else dilemma.  It may be solved
  by using braces.

it()
(an as yet unidentified ambiguity)
)

sect(Notation conversion specifics)

subsect(Automatic Beam Generation)cindex(Automatic Beam Generation)
label(autobeam)

By default, Lilypond will generate beams automatically.  This feature
can be disabled by setting the indexandcode(Voice.noAutoBeaming)
property to 1.  It can be overridden for specific cases by specifying
explicit beams as described in Section ref(manualbeam).

A large number of Voice properties are used to decide how to generate
beams.  Their default values appear in file(auto-beam-settings.ly).
In general, beams can begin anywhere, but their ending location is
significant.  Beams can end on a beat, or at durations specified by
the indexandcode(Voice.beamAutoEnd) property.  To end beams every
quarter note, for example, you could use set
indexandcode(Voice.beamAutoEnd) equal to code("1/4").  To end beams at
every three eighth notes you would set it to code("3/8").  The same
syntax can be used to specify beam starting points using
indexandcode(Voice.beamAutoBegin).

To allow different settings for different time signatures, these
property names can start with code(time)var(N)code(_)var(M) to
restrict the definition to var(N)code(/)code(M) time.  For example,
to specify beams ending only for 6/8 time you would use the property
code(Voice.time6_8beamAutoEnd).  To allow different endings for notes
of different durations, the duration can be tacked onto the end of the
property.  To specify beam endings for beams that contain 32nd notes,
you would use code(Voice.beamAutoEnd_32).

subsect(Printing chord names)cindex(chord names)cindex(chords)cindex(printing!chord names)

For displaying printed chord names, use the indexandcode(ChordNames) context.  
The chords may be entered either using the notation described above,
or directly using simultaneous music. 
mudela(fragment,verbatim)(
<
  \context ChordNames { \chords{ a b c} \notes{ < d f g >  < e g b > } }
  \context Staff \notes{ a b c' d' e' }
>
)
Lilypond examines chords specified as lists of notes to determine a
name to give the chord.  By default, LilyPond will not try to identify
chord inversions:
mudela(fragment,verbatim,center)(
<
  \context ChordNameVoice { 
     \notes{ < e'1 g' c'' > } }
  \context Thread \notes{ < e'1 g' c'' > }
>)
If you want inversions to be recognized, you must set the property
indexandcode(ChordNames.chordInversion): 
mudela(fragment,verbatim,center)(
<
  \property Score.chordInversion = 1
  \context ChordNameVoice { 
       \notes{ < e'1 g' c'' > } }
  \context Thread \notes{ < e'1 g' c'' > }
>)



subsect(Printing lyrics)cindex(Lyrics)cindex(printing!lyrics)
label(lyricprint)

Lyric syllables must be interpreted within a code(Lyrics) context
cindex(context!Lyrics) for printing them.

Here is a full example: 
mudela(verbatim)(\score{
  <  \notes \transpose c'' {c d e c | c d e c | e f g2 | 
                              e4 f g2 \bar "|."; }
     \context Lyrics \lyrics { 
              Va-4 der Ja- cob Va- der Ja- cob
              Slaapt gij nog?2 Slaapt4 gij nog?2  }
  >
})


 You may 
want a  continuous line after the syllables to show melismata.   To achieve
this effect, add a code(__) lyric as a separate word 
after the lyric to be extended.  
This will create
an extender, a line  that extends over the entire duration of 
the lyric.  This line will run all the way to the start of the next
lyric, so you may want to shorten it by using a blank lyric.  
COMMENT(

)mudela(verbatim)(\score{
< \notes \relative c''{ 
     a4()b()c()d c()d()b()a c()d()b()a }
   \context Lyrics \lyrics {
     foo1 __  bar2. __ _4 baz1 __ }
> })COMMENT(

)
     
If you want to have hyphens centered between syllables (rather than attached
to the end of the first syllable) you can use the special code(-)code(-) lyric as
separate word between syllables. This will result in a hyphen whose length
varies depending on the space between syllables, and centered between the
syllables. For example: 
mudela(verbatim)(\score{
  <  \notes \transpose c'' {c d e c | c d e c | e f g2 | 
                              e4 f g2 \bar "|."; }
     \context Lyrics \lyrics { 
              Va4  -- der Ja -- cob Va -- der Ja -- cob
              Slaapt gij nog?2 Slaapt4 gij nog?2  }
  >
})




sect(Notation Contexts)cindex(Notation Contexts)

Notation contexts are objects that only exist during a run of
LilyPond.  During the interpretation phase of LilyPond, the Music
expression contained in a code(\score) block is interpreted in time
order.  This is the order in which humans read, play and write music.

A  context is an object that holds the reading state of the expression:
it contains information like
itemize(
it() What notes are playing at this point?
it() What symbols will be printed at this point?
it() In what style will they printed?
it() What is the current key signature, time signature, point within
the measure, etc.
)

Contexts are grouped hierarchically: a code(Voice) context is
contained in a code(Staff) context (because a staff can contain
multiple voices at any point), a code(Staff) context is contained in a
code(Score), code(StaffGroup) or code(ChoirStaff) context (because these
can all contain multiple staffs.)

Contexts associated with sheet music output are called notation
contexts, those for sound output are called playing contexts.

Contexts are created either  manually or automatically.
Initially, the top level music expression is interpreted by the top level
context (the code(Score) context). 
When a atomic music expression (a note, a rest, a code(\bar),
code(\time) command), a nested set of contexts is created that can process these
atomic expressions, so in this example,COMMENT(

)verb(\score { \notes < c4 > })COMMENT(

)the sequential music, code({ c4 }) is interpreted by code(Score) context.
When the note code(c4) itself is interpreted, a set of contexts is needed
that will accept notes. The default for this is a code(Voice) context,
contained in a code(Staff) context.  Creation of  these contexts
results in the staff being printed.

subsect(Context selection)
label(contextselection)

You can also create contexts manually, and you probably have to do so
if you want to typeset complicated multiple part
material.  If a code(\context )var(name musicexpr) expression is
encountered during the interpretation phase, the var(musicexpr)
argument will be interpreted with a context of type var(name).  If you
specify a name, the specific context with that name is searched.

If a context of the specified type and name can not be found, a new
one is created.  For example,
COMMENT(

)mudela(verbatim)(\score {
  \notes \relative c'' {
    c4 <d4 \context Staff = "another" e4> f } })COMMENT(

) in this example, the code(c) and code(d) are
printed on the default staff.  For the code(e), a context Staff called
code(another) is specified; since that does not exist, a new context is
created.  Within code(another) a (default) Voice context is created
for the code(e4).   When all music referring to a context is finished, the
context is ended as well.  So after the third quarter, the
code(another) is removed.

Almost all music expressions inherit their interpretation context from
their parent. In other words, suppose that the syntax for a music
expression is code(\keyword) var(musicexpr1) var(musicexpr2) ellipsis().
When the interpretation of this music expression starts, the context
for var(musicexpr1), var(musicexpr2), etc. that of the total
expression.

Lastly, you may wonder, why doesn't this:
verb(\score { \notes \relative c'' { c4 d4 e4 }})
result in this?
mudela()(\score { \notes \relative c'' { <c4> <d4> <e4> }})

For the code(c4) a default code(Staff) (with contained code(Voice)) context is
created.  After the code(c4), ends no music refers to this default
staff, so it would be ended, with the result shown.  To prevent this
inconvenient behavior, the context to which the sequential music
refers is adjusted during the interpretation.  So after the code(c4)
ends, the context of the sequential music is also the default code(Voice)
context.  The code(d4) gets interpreted in the same context as code(c4)


subsect(Predefined contexts)

These are the contexts are supplied with the package.  They are
defined in init file(ly/engraver.ly).

description(

dit(code(Grace))indexcode(Grace) The context for handling grace notes, it is
  instantiated automatically when you use code(\grace).  It is a
  `embedded' miniature of the Score context.  Since this context needs
  special interaction with the rest of LilyPond, you should not
  explicitly instantiate it.

dit(code(LyricVoice))indexcode(LyricVoice) Corresponds to a voice with lyrics.  Handles the printing
of a single line of lyrics.  

dit(code(Thread))indexcode(Thread) Handles note heads, and is contained in the Voice
  context.  You have to instantiate these explicitly if you want to
  adjust the style of individual noteheads.

dit(code(Voice))indexcode(Voice) Corresponds to a voice on a staff.  This context
  handles the conversion of dynamic signs, stems, beams, super- and
  subscripts, slurs, ties and rests.

  You have to instantiate these explicitly if you want to have
  multiple voices on the same staff.

dit(code(ChordNamesVoice))indexcode(ChordNamesVoice) A voice with chord names.  Handles printing
of a line of chord names.  

dit(code(ChordNames))indexcode(ChordNames)  Typesets chord names.  Can contain
code(ChordNamesVoice) contexts.  

dit(code(Lyrics))indexcode(Lyrics) Typesets lyrics.  It can contain code(LyricVoice) contexts.

dit(code(Staff))indexcode(Staff) Handles clefs, bar lines, keys,
  accidentals.  It can contain code(Voice) contexts.

dit(code(RhythmicStaff))indexcode(RhythmicStaff) A context like code(Staff) but for printing
rhythms.  Pitches are ignored; the notes are printed on one line.  
It can contain code(Voice) contexts. 

dit(code(GrandStaff))indexcode(GrandStaff) Contains code(Staff) or code(RhythmicStaff)
contexts.  It adds a brace on the left side grouping the staffs
together. The bar lines of the contained staffs are connected vertically.
It can contain code(Staff) contexts.

dit(code(PianoStaff))indexcode(PianoStaff) Just like code(GrandStaff) but with
code(minVerticalAlign) set equal to code(maxVerticalAlign) so that
interstaff beaming and slurring can be used.  

dit(code(StaffGroup))indexcode(StaffGroup) Contains code(Staff) or code(RhythmicStaff)
contexsts.  Adds a bracket on the left side, grouping the staffs
together.  The bar lines of the contained staffs are connected vertically.
It can contain code(Staff), code(RhythmicStaff), code(GrandStaff) or code(Lyrics) contexts.  

dit(code(ChoirStaff))indexcode(ChoirStaff) Identical to code(StaffGroup) except that the
contained staffs are not connected vertically.  

dit(code(Score))indexcode(Score) This is the top level notation context.    No
other context can contain a code(Score) context.  This context handles
the administration of time signatures.  It also makes sure that items
such as clefs, time signatures, and key-signatures are aligned across
staffs.  It can contain code(Lyrics), code(Staff),
code(RhythmicStaff), code(GrandStaff), code(StaffGroup), and
code(ChoirStaff) contexts.

You can not explicitly instantiate a Score context (since it is not
contained in any other context.).  It is instantiated automatically
when an output definition (a code(\score) or code(\paper) block) is
processed.
)

subsect(Context properties)

Properties that are set in one context are inherited by all of the
contained contexts.  This means that a property valid for the Voice
context can be set in the Score context (for example) and thus take
effect in all Voice contexts.

Properties can be preset within the code(\translator) block
corresponding to the appropriate context.  In this case, the syntax is
`var(propname) code(=) var(value)'.  This assignment happens before
interpretation starts, so a code(\property) expression will override
any pre defined settings.

The code(\property) expression will create any property you specify.
There is no guarantee that a property will be used.  So if you spell a
property name wrong, there will be no error message.

The property settings are used during the interpretation phase. They
are read by the LilyPond modules where interpretation contexts are
built of.  These modules are called em(translators). Translators for
notation are called em(engravers) and translators for sound are called
em(performers).

The precise result of a property is determined by the implementation
of the translator that reads them.  Therefore, the result of a
property can vary, since it is implementation and configuration
dependent.

In order to fully find out what properties are used, you must search
the source code for calls to code(get_property).  The rest of the
section is devoted to an (incomplete) overview of available properties.

subsubsubsect(Lyrics properties)cindex(properties!Lyrics)

description(

dit(code(textStyle))indexcode(textStyle) Set the font for lyrics.  The available font
choices are code(roman), code(italic), code(bold), code(large),
code(Large), code(typewriter), and code(finger).  The code(finger)
font can only display numbers.  Note also that you must be careful
when using code(\property) in Lyrics mode,  because of the way strings
are parsed.   Either put quotes around the arguments to code(\property)
or be sure to leave a space on both sides of the dot.


)

subsubsubsect(Thread properties)cindex(properties!Thread)

description(
dit(code(noteheadStyle))indexcode(noteheadStyle) Selects type of note head.  Choices are
code(cross), code(diamond), code(harmonic), code(transparent), and
code("").  They are shown in that order below.  
mudela(center)(
\score{
  \notes{ 
     \property Staff.barNonAuto = 1
     \property Voice.noteHeadStyle = cross 
     a'
     \property Voice.noteHeadStyle = diamond
     a'
     \property Voice.noteHeadStyle = harmonic
     a'
     \property Voice.noteHeadStyle = transparent
     a' 
     \property Voice.noteHeadStyle = ""
     a'
  }
 \paper{ linewidth = -1.;}
}
)
)


subsubsubsect(Voice properties)cindex(properties!Voice)

description(  

dit(code(stemLength))indexcode(stemLength) Set length of stems.  Unit is 
code(interline)/2, so code(stemLength) defaults to 7.

dit(code(stemLeftBeamCount))indexcode(stemLeftBeamCount) Specify the number of beams to draw on
the left side of the next note.   Overrides automatic beaming.  The
value is only used once, and then it is erased.

dit(code(stemRightBeamCount))indexcode(stemRightBeamCount) Specify the number of beams to draw on
the right side of the next note.   Overrides automatic beaming.  The
value is only used once, and then it is erased.

dit(code(noAutoBeaming))indexcode(beamAuto) If set to 1 then beams are
not generated automatically.

dit(code(beamAutoEnd))indexcode(beamAutoEnd) Specifies when automatically generated beams
can end.  See Section ref(autobeam).

dit(code(beamAutoBegin))indexcode(beamAutoBegin) Specifies when automatically generated beams
can start.  See Section ref(autobeam). 

dit(code(textEmptyDimension))indexcode(textEmptyDimension) If set to 1 then text placed above or
below the staff is assumed to have zero width.  

dit(code(beamquantisation))indexcode(beamquantisation) Set to
code(\none) for no quantization.  Set to code(\normal) to quantize
position and slope.  Set to code(\traditional) to avoid wedges.  These
three settings are available via code(\beamposfree),
code(\beamposnormal), and code(\beampostraditional).

dit(code(beamslopedamping))indexcode(beamslopedamping) Set to code(\none) for undamped beams.
Set to code(\normal) for damped beams.  Set to code(\infinity) for
beams with zero slope.  The identifiers code(\beamslopeproportional),
code(\beamslopedamped), and code(\beamslopezero) each set the
corresponding value.

dit(code(restStyle))indexcode(restStyle) Change the layout of rests shorter than quarter notes. 
Currently, the standard layout code(restStyle="") and mensural notation
code(restStyle="mensural") are available.

dit(code(midiInstrument))indexcode(midiInstrument) Sets the instrument for MIDI output.    If
this property is not set then LilyPond will use the code(instrument)
property.  This must be set to one of the strings on the list of MIDI
instruments that appears in Section ref(midilist).  If you use a
string which is not listed, LilyPond will silently substitute piano. 

dit(code(transposing))indexcode(transposing) Tranpose the MIDI output.  Set this property to
the number of half-steps to transpose by.

dit(code(oldTieBehavior))indexcode(oldTieBehavior) Set to 1 in order to get old tie behavior
where ties would connect unequal pitches.  This property is
deprecated, and use is not recommended.

dit(code(verticalDirection))indexcode(verticalDirection) Determines the direction of stems, subscripts,
beams, slurs, and ties.  Set to code(\down) to force them down,
code(\up) to force them up, or code(\free) to let LilyPond decide.
This can be used to distinguish between voices on the same staff.  The
code(\stemdown), code(\stemup), and code(\stemboth) identifiers set
this property.

dit(code(slurVerticalDirection))indexcode(slurVerticalDirection) Set to code(\free) for free choice of slur
direction, set to code(\up) to force slurs up, set to code(\down) to
force slurs down.  The shorthands code(\slurup), code(\slurdown), and
code(\slurboth) are available.

dit(code(tieVerticalDirection))indexcode(tieVerticalDirection) Set to code(\free) for free choice of tie
direction, set to code(\up) to force ties up, set to code(\down) to
force ties down.  

dit(code(slurDash))indexcode(slurDash) Set to 0 for normal slurs, 1 for dotted slurs, and
a larger value for dashed slurs.  Identifiers code(\slurnormal) and
code(\slurdotted) are predefined to set the first two settings.

dit(code(horizontalNoteShift))indexcode(horizontalNoteShift) Enable LilyPond to shift notes
horizontally if they collide with other notes.  This is useful when
typesetting many voices on one staff.  The identifier code(\shift) is
defined to enable this.  Traditionally, the outer chords (the upmost
and downmost voices), should have no code(horizontalNoteShift). 


dit(code(forceHorizontalShift))indexcode(forceHorizontalShift) Force
horizontal shift for collision resolution.  It overrides automatic
collision resolution.  The value is the shift amount expressed in
code(note_width), as set in the paper section.

dit(code(dynamicDir))indexcode(dynamicDir) Determines location of dynamic marks.  Set to
code(\up) to print marks above the staff; set to code(\down) to print
marks below the staff.

dit(code(dynamicStyle))indexcode(dynamicStyle) Set the text style for dynamics.  

dit(code(textStyle))indexcode(textStyle) Set the text style for superscripts and
subscripts.  See above for list of text styles.

dit(code(textScriptPadding))indexcode(textScriptPadding) Determines the extra space added between
super-/subscripted text and the closest staff line or note.

dit(code(fontSize))indexcode(fontSize) Can be used to select smaller font sizes for
music.  The normal font size is 0, and the two smaller sizes are -1
and -2.

dit(code(abbrev))indexcode(abbrev) Set length for tremolo to be used if no length is
explicitly specified.

dit(code(tupletDirection))indexcode(tupletDirection) Determines the direction of triplets and 
other tuplets.  Set to code(\down) to force them below the staff,
code(\up) to force them above, or code(\free) to let LilyPond decide.

dit(code(tupletVisibility))indexcode(tupletVisibility) Determines whether tuplets of notes are
labelled.  Setting to 0 shows nothing; setting to 1 shows a number;
setting to 2 shows a number and a bracket if there is no beam; setting
to 3 shows a number, and if there is no beam it adds a bracket;
setting to 4 shows both a number and a bracket unconditionally.


dit(code(markScriptPadding))indexcode(markScriptPadding) Determines the extra space added between
the mark and the closest staff line or note.

dit(code(markDirection))indexcode(markDirection) Determines if marks should be printed above
or below the staff. Set to code(\up) to print marks above the staff;
set to code(\down) to print marks below the staff.

dit(code(articulationScriptPadding))indexcode(articulationScriptPadding) Determines the extra space added 
between articulation marks, such as staccato, tenuto, trill, up/down 
bow or fermata, and the closest staff line or note.


dit(code(articulationScriptVerticalDirection))indexcode(articulationScriptVerticalDirection) Determines the location
of articulation marks. Set to code(\up) to print marks above the
staff; set to code(\down) to print marks below the staff. This
property does not override explicit directions marked with code(^) or
code(_) in the mudela file.
)

subsubsubsect(Staff properties)cindex(properties!Staff)

description(

dit(code(createInitdefaultClef))indexcode(createInitdefaultClef) Specify whether clefs are created on
default?  (Doesn't seem to do anything.)

dit(code(barNumberDirection))indexcode(barNumberDirection) Set to code(\up) or code(\down) to put
bar numbers above or below the staff.  

dit(code(barNumberHangOnClef))indexcode(barNumberHangOnClef) Set to 1
to cause bar numbers to appear above or below the clef instead of on
the bar line. This property is deprecated.  Do not use.

dit(code(barNumberScriptPadding))indexcode(barNumberScriptPadding) Sets extra space between the bar
number and the bar it labels.

dit(code(barSize))indexcode(barSize) Specify the height of the bar lines if it should be
different than the staff height.

dit(code(markHangOnClef))indexcode(markHangOnClef) Set to 1 to cause marks to appear by clefs
instead of by bar lines.  Deprecated, use is not recommended.

dit(code(marginDirection))indexcode(marginDirection) Set to code(\left) or code(\right) to
specify location of marginal scripts.  

dit(code(marginScriptPadding))indexcode(marginScriptPadding) Specify extra space for marginal scripts.

dit(code(forgetAccidentals))indexcode(forgetAccidentals) Causes accidentals to be printed at every
note instead of remembered for the duration of a measure.  

dit(code(noResetKey))indexcode(noResetKey) Do not reset the key at the start of a measure.
Accidentals will be printed only once and are in effect until
overridden, possibly many measures later. 

dit(code(staffLineLeading))indexcode(staffLineLeading) Specifies the distance (in points) between lines
of the staff.  

dit(code(numberOfStaffLines))indexcode(numberOfStaffLines) Specifies the number of staff lines. The
default is 5. 

dit(code(postBreakPadding))indexcode(postBreakPadding) Extra space in points to be added after
the clef, time signature and key signature on the staff. Deprecated,
do not use.

dit(code(barAtLineStart))indexcode(barAtLineStart) Set to 1 to produce a bar line after the
clef at the start of each line (but not at the beginning of the
music).  

dit(code(noVoltaBraces))indexcode(noVoltaBraces) Set to true to suppress the printing
of brackets over alternate endings specified by code(\alternative).

dit(code(voltaSpannerDuration))indexcode(voltaSpannerDuration) Set to an integer to control the size
of the brackets printed by code(\alternative).  The integer specifies
the number of whole notes duration to use for the brackets.  It seems
to be rounded to the nearest measure.  This can be used to shrink the
length of brackets in the situation where one alternative is very
large.  It may have odd effects if the specified duration is longer
than the music given in an code(\alternative).   [FIXME: This was
broken in 1.1.53]

dit(code(barNonAuto))indexcode(barNonAuto) If set to 1 then bar lines will not be printed
automatically; they must be explicitly created with code(\bar) keywords.
Unlike with the code(\cadenza) keyword, measures are still counted.  Bar
generation will resume according to that count if this property is set to
zero.  

dit(code(defaultClef))indexcode(defaultClef) Determines the default clef.  See code(\clef)
keyword.

dit(code(numberOfStaffLines))indexcode(numberOfStaffLines) Sets the number of lines that the staff has.
 
dit(code(barAlways))indexcode(barAlways) If set to 1 a bar line is drawn after each note.

dit(code(defaultBarType))indexcode(defaultBarType) Sets the default type of bar line.  See
code(\bar) keyword.

dit(code(keyOctaviation))indexcode(keyOctaviation) If set to 1, then keys are the same in all
octaves.  If set to 0 then the key signature for different octaves can
be different and is specified independently: code(\keysignature bes
fis').  The default value is 1.  Can be set to zero with
code(\specialkey) or reset to 1 with code(\normalkey).

dit(code(instrument)) and code(instr) If code(Staff_margin_engraver)
cindex(instrument)cindex(instr)cindex(Staff_margin_engraver)
is added to the Staff translator, then the code(instrument) property
is used to label the first line of the staff and the code(instr)
property is used to label subsequent lines.  If the
code(midiInstrument) property is not set then code(instrument) is
used to determine the instrument for MIDI output.

dit(code(createKeyOnClefChange))indexcode(createKeyOnClefChange) Set
to a nonempty string if you want key signatures to be printed when the
clef changes.  Set to the empty string if you do not want key
signatures printed.

dit(code(timeSignatureStyle))indexcode(timeSignatureStyle) Changes the default two-digit layout
   for time signatures. The following values are recognized:
   description(
      dit(code(C))indexcode(C) 4/4 and 2/2 are typeset as C and struck C,
      respectively. All other time signatures are written with two digits.
      dit(code(old))indexcode(old) 2/2, 3/2, 2/4, 3/4, 4/4, 6/4, 9/4, 4/8, 6/8 and
      9/8 are typeset with old-style mensuration marks. All other time
      signatures are written with two digits.
      dit(code(1))indexcode(1) All time signatures are typeset with a single
      digit, e.g. 3/2 is written as 3.
      dit(indexandcode(C2/2), code(C4/4), code(old2/2), code(old3/2),
      code(old2/4), code(old3/4), code(old4/4), code(old6/4), 
      code(old9/4), code(old4/8), code(old6/8), code(old6/8alt)
      or code(old9/8))Tells Lilypond to use a specific symbol as 
      time signature.
   )
The different time signature characters are shown below with
their names:
mudela(center)(
\score{
  \notes\relative c'' {
\property Voice.textStyle = typewriter
\property Staff.timeSignatureStyle = "C2/2"
\time 2/2; a2^"C2/2" a2 
\property Staff.timeSignatureStyle = "C4/4"
\time 2/2; a2^"C4/4" a2 
\property Staff.timeSignatureStyle = "old2/2"
\time 2/2; a2^"old2/2" a2 
\property Staff.timeSignatureStyle = "old3/2"
\time 2/2; a2^"old3/2" a2 
\property Staff.timeSignatureStyle = "old2/4"
\time 2/2; a2^"old2/4" a2 
\property Staff.timeSignatureStyle = "old4/4"
\time 2/2; a2^"old4/4" a2 
\property Staff.timeSignatureStyle = "old6/4"
\time 2/2; a2^"old6/4" a2 
\property Staff.timeSignatureStyle = "old9/4"
\time 2/2; a2^"old9/4" a2 
\property Staff.timeSignatureStyle = "old4/8"
\time 2/2; a2^"old4/8" a2 
\property Staff.timeSignatureStyle = "old6/8"
\time 2/2; a2^"old6/8" a2 
\property Staff.timeSignatureStyle = "old6/8alt"
\time 2/2; a2^"old6/8alt" a2 
\property Staff.timeSignatureStyle = "old9/8"
\time 2/2; a2^"old9/8" a2 
}
   \paper{ linewidth= 4.5 \in; }
}
)

dit(code(clefStyle))indexcode(clefStyle) Determines how clefs are typeset. When set to
code(transparent), the clefs are not printed at all, when set to
code(fullSizeChanges), clef changes in the middle of a line are
typeset with a full size clef. By default, clef changes are typeset in
smaller size.

)
   
subsubsubsect(GrandStaff properties)cindex(properties!GrandStaff)

description( 

dit(code(alignmentReference))indexcode(alignmentReference) Set to code(\center) for vertical
alignment reference point to be in the center of the vertical group.
Set to code(\up) to put the reference point at the top of the group. 

dit(code(maxVerticalAlign))indexcode(maxVerticalAlign) Set the maximum vertical distance between
staffs.

dit(code(minVerticalAlign))indexcode(minVerticalAlign) Set the minimum vertical distance between
staffs.  

)

subsubsubsect(Score properties)cindex(properties!Score)

description(

dit(code(skipBars))indexcode(skipBars) Set to 1 to skip the empty bars that are produced
by multimeasure notes and rests.  These bars will not appear on the
printed output.  Set to zero (the default) to expand multimeasure
notes and rests into their full length, printing the appropriate
number of empty bars so that synchronization with other voices is
preserved.
mudela(fragment,verbatim,center)(
r1 r1*3 R1*3\property Score.skipBars=1 r1*3 R1*3
)

)

subsubsubsect(ChordNamesVoice properties)cindex(properties!ChordNamesVoice)

description(
dit(code(chordInversion))indexcode(chordInversion) Determines whether LilyPond should look for
chord inversions when translating from notes to chord names.  Set to 1
to find inversions.  The default is 0 which does not look for inversions.
)


sect(Notation output definitions)cindex(Output)cindex(Notation output)
cindex(output definition)
label(output)
label(paper)

The most important output definition is the code(\paper) block, for
music notation.  The syntax is
code(\paper {) [var(paperidentifier)] var(items) code(}),
where each of the items is one of

itemize(

it() An assignment.  The assignment must be terminated by a semicolon.
See Section ref(papervars) for information on paper variables.

it() A context definition, see Section ref(contextdefs) for more
information on context definitions.

it() A margin shape declaration. The syntax is code(\shape)
var(indent1)code(,) var(width1)code(,) var(indent2)code(,) var(width2)
ellipsis() code(;)
indexcode(\shape)
Each pair of var(indent) and var(width) values is a
dimension specifying how far to indent and how wide to make the line.
The indentation and width of successive lines are specified by the
successive pairs of dimensions.  The last pair of dimensions will
define the characeristics of all lines beyond those explicitly
specified.

it() A font declaration.  Its syntax is var(fontsize) code(=)
code(\font)keyindex(font) var(fontname).  var(fontsize) is an integer
describing the font to be used.  0 is the default font. var(fontname)
is the basename of a font (usually a member of the Feta family).

)




subsect(Changing Font Size and Paper Size)cindex(Changing Font Size and Paper Size)

The Feta font provides musical symbols at six different sizes.  These
fonts are 11 point, 13 point, 16 point, 20 point, 23 point, and 26
point.  The point size of a font is the height of the five line staff
when displayed in the font.

Definitions for these sizes are the files file(paperSZ.ly), where
code(SZ) is one of 11, 13, 16, 20, 23 and 26.  If you include any of
these files, the identifiers code(paper_eleven), code(paper_thirteen),
code(paper_sixteen), code(paper_twenty), code(paper_twentythree), and
code(paper_twentysix) are defined respectively.  The default
code(\paper) block is also set.

To change the paper size, you must first set the code(papersize)
variable at the top level.  Set it to the strings code(a4),
code(letter), or code(legal).  After this specification, you must set
the font as described above.  If you want the default font, then use
the 20 point font.  The new paper size will not take effect if the
font is not loaded and selected afterwards.  Paper size selection
works by loading a file named after the paper size you select.



subsect(Paper variables)cindex(Paper variables)
label(papervars)

There are a large number of paper variables that are used to control
details of the layout. These variables control the defaults for the
entire score.  Usually, they do not have to be changed; they are 
by default set to values that depend on the font size in use.  The values
are used by the graphic objects while formatting the score; they are
therefore implementation dependent.  Most variables are accompanied by
documentation in the initalization file file(params.ly) or
file(paperSZ.ly), where code(SZ) is the staff height in points.

Nevertheless, here are some variables  you may want to use or change:

description(
dit(code(indent))indexcode(indent) The indentation of the first line of music.

dit(code(interline))indexcode(interline) The distance between two
staff lines, calculated from the center of the lines.  You should use
either this or code(rulethickness) as a unit for distances you modify.
  
dit(code(linewidth))indexcode(linewidth) Sets the width of the
lines.  If  set to -1.0, then a single unjustified line is
produced.

dit(code(output))indexcode(output) Specifies an alternate name for
the TeX() output.  A file(.tex) extension will be added to the string
you specify.

dit(code(rulethickness))indexcode(rulethickness) Determines thickness of staff lines and bars. 

code(castingalgorithm)indexcode(castingalgorithm) The algorithm to use
for breaking lines.  Choices are code(\Gourlay)keyindex(Gourlay) for a
TeX() like dynamic programming algorithm, and
code(\Wordwrap)keyindex(Wordwrap) for a simple algorithm.  Gourlay
breaking looks much better, but takes a lot more resources.  Wordwrap
leaves loosely spaced lines at the end

)



subsect(Context definitions)
label(contextdefs)cindex(context definition)

A notation contexts is defined by the following information

enumerate(
it() a name
it() The LilyPond modules that do the actual conversion of music to
notation.   Each module is a so-called code(Engraver)cindex(Engraver).
it() How these modules should cooperate, i.e. which ``cooperation
module'' should be used.   This cooperation module is a special type
of engraver. 
it() what other contexts the context can contain,
it() what properties are defined
)


A context definition has this syntax: code(\translator
{ )var(translatorinit) var(translatormodifierlist) code(}).

var(translatorinit) can be  an identifier, or code(\type
)var(typename)code(;).   var(typename) is one of
itemize(
it() indexandcode(Engraver_group_engraver) the standard cooperation engraver.
it() indexandcode(Score_engraver) this is cooperation module that should be
  in the top level context.
it() indexandcode(Grace_engraver_group) 
  This is  a special cooperation module (resembling Score_engraver),
  that is used to created an embedded `miniscore'
) 

var(translatormodifierlist) is a list of items, where each item is one
of

itemize(
it() code(\consists) var(engravername)code(;)
  Add var(engravername)  to the list of modules in  this
  context. Section ref(engravers) contains an overview of the
  engravers available.  The order of engravers added   with
  code(\consists) is significant.
  
it() code(\consistsend) var(engravername)code(;)
  Analogous to code(\consists), but makes sure that var(engravername)
  is always added to the end of the list of engravers. 

    Some engraver types need to be at the end of the list; this
    insures they are put there, and stay there, if a user adds or
    removes engravers.  This command is usually not needed for
    end-users.


    
it() code(\accepts) var(contextname)code(;)
  Add var(contextname) to the list of  context this context can
  contain.  The first listed context the context to create  by
  default.
  
it() code(\remove) var(engravername)code(;) 
  Remove a previously added (with code(\consists)) engraver
  
it() code(\name) var(contextname)code(;) This sets name of the
  context, eg. code(Staff), code(Voice).  If the name is not
  specified, the translator won't do anything.

it()
  var(propname)code(=)var(value)code(;) A property assignment.  It is
  legal to use reals for var(value)

)

 

In the code(\paper) block, it is also possible to define translator
identifiers.  Like other block identifiers, the identifier can only
be used as the very first item of a translator.  In order to define
such an identifier outside of code(\score), you must do
verb(
\paper{ foo=\translator{ ... } }
\score{
  \notes{ ... }
  \paper{ \translator{ \foo ... } }
})

subsubsect(Paper Types and Engravers and Pre-defined Translators)cindex(Paper Types and Engravers and Pre-defined Translators)

Some pre-defined identifiers can simplify modification of translators.
The pre-defined identifiers are:  
description(
dit(code(StaffContext))indexcode(StaffContext)
Default Staff  context. 
dit(code(RhythmicStaffContext))indexcode(RhythmicStaffContext)
Default RhythmicStaff  context. 
dit(code(VoiceContext))indexcode(VoiceContext)
  Default Voice  context.  
dit(code(ScoreContext))indexcode(ScoreContext)
  Default  Score context. 
dit(code(ScoreWithNumbers))indexcode(ScoreWithNumbers)
  Score context with numbering at the Score level.   

dit(code(BarNumberingStaffContext))indexcode(BarNumberingStaffContext)
  Staff context with numbering at the Staff level.

dit(code(HaraKiriStaffContext))indexcode(HaraKiriStaffContext)
  Staff context that does not print if it only contains rests.  Useful for
  orchestral scores.footnote(Hara kiri is the ritual suicide of the Samourai)
dit(code(OrchestralPartStaffContext))indexcode(OrchestralPartStaffContext)
dit(code(OrchestralScoreContext))indexcode(OrchestralScoreContext)
)

Using these pre-defined values, you can remove  or add items to the
translator verb(\paper{ \translator{ \StaffContext
                     \remove Some_engraver;
                     \consists Different_engraver;  }})
      

subsubsect(Engravers)
label(engravers)


The engravers for paper output are:

[incomplete, FIXME]

description(
dit(code(Bar_engraver))indexcode(Bar_engraver) Engraves bar lines.  Normally in code(Staff) and
code(RhythmicStaff).  
dit(code(Bar_number_engraver))indexcode(Bar_number_engraver) Engrave bar numbers.  These numbers
appear at the start of each line.  Not normally in any translator.  Can
be added to code(Score) for Score-wide numbering or to code(Staff) for
numbering on each staff.  

dit(code(Beam_engraver))indexcode(Beam_engraver) Handles beam requests by engraving beams.  Normally
appears in the code(Voice) translator.  If omitted, then notes will be printed
with flags instead of beams.

dit(code(Beam_req_swallow_translator))indexcode(Beam_req_swallow_translator) Swallows beam requests.  In
code(LyricVoice).  
dit(code(Chord_name_engraver))indexcode(Chord_name_engraver) Engraves chord names.  Normally in
code(ChordNameVoice) 
dit(code(Chord_tremolo_engraver))indexcode(Chord_tremolo_engraver)
dit(code(Clef_engraver))indexcode(Clef_engraver) Engraves the clef symbol.  Normally in code(Staff).
dit(code(Collision_engraver))indexcode(Collision_engraver)
dit(code(Dot_column_engraver))indexcode(Dot_column_engraver) Engraves dots on dotted notes shifted to the
right of the note.  Normally in code(Voice).  If omitted, then dots appear on
top of the notes.  
dit(code(Dynamic_engraver))indexcode(Dynamic_engraver) Engraves dynamics symbols.  Normally in code(Voice).
dit(code(Font_size_engraver))indexcode(Font_size_engraver)
dit(code(Key_engraver))indexcode(Key_engraver) Engraves the key signature.  Normally in code(Staff).
dit(code(Local_key_engraver))indexcode(Local_key_engraver)
dit(code(Lyric_engraver))indexcode(Lyric_engraver) Engraves lyrics.  Normally in code(LyricVoice).
dit(code(Multi_measure_rest_engraver))indexcode(Multi_measure_rest_engraver) Engraves multi-measure rests that are
produced with code(R).  Normally in code(Voice).
dit(code(Piano_bar_engraver))indexcode(Piano_bar_engraver)
dit(code(Pitch_squash_engraver))indexcode(Pitch_squash_engraver) Treat all pitches as middle C.  Used in
code(RhythmicStaff).  Note that the notes move, but the locations of
accidentals stay the same. 
dit(code(Priority_horizontal_align_engraver))indexcode(Priority_horizontal_align_engraver)
dit(code(Repeat_engraver))indexcode(Repeat_engraver) Handles repeats? In code(Staff) and 
   code(RhythmicStaff).
dit(code(Rest_collision_engraver))indexcode(Rest_collision_engraver) Handles collisions of rests. In code(Staff).
dit(code(Rest_engraver))indexcode(Rest_engraver) Engraves rests.  Normally in code(Voice).
dit(code(Rhythmic_column_engraver))indexcode(Rhythmic_column_engraver)
dit(code(Score_priority_engraver))indexcode(Score_priority_engraver)
dit(code(Script_engraver))indexcode(Script_engraver) Handles note ornaments generated by code(\script).
Normally in code(Voice).  
dit(code(Separating_line_group_engraver))indexcode(Separating_line_group_engraver)
dit(code(Skip_req_swallow_translator))indexcode(Skip_req_swallow_translator)
dit(code(Slur_engraver))indexcode(Slur_engraver) Engraves slurs.  Normally in code(Voice).
dit(code(Span_bar_engraver))indexcode(Span_bar_engraver) Engraves lines across multiple staffs.  Normally
in code(Staffgroup) and code(GrandStaff).  Removing this from code(StaffGroup)
gives the definition of code(ChoirStaff).  
dit(code(Span_score_bar_engraver))indexcode(Span_score_bar_engraver)
dit(code(Staff_group_bar_engraver))indexcode(Staff_group_bar_engraver)
dit(code(Staff_margin_engraver))indexcode(Staff_margin_engraver) Prints the name of the instrument
(specified by code(Staff.instrument) and code(Staff.instr)) at the
left of the staff.  
dit(code(Staff_sym_engraver))indexcode(Staff_sym_engraver)
dit(code(Stem_engraver))indexcode(Stem_engraver) Engraves stems.  Normally in code(Voice).
dit(code(Ties_engraver))indexcode(Ties_engraver) Engraves ties.  Normally in code(Voice).
dit(code(Time_signature_engraver))indexcode(Time_signature_engraver) Engraves the time signature.  Normally in
code(Staff) and code(RhythmicStaff).
dit(code(Timing_engraver))indexcode(Timing_engraver) Responsible for synchronizing timing information
from staffs.  Normally in code(Score).  In order to create polyrhythmic music,
this engraver should be removed from code(Score) and placed in code(Staff).
dit(code(Tuplet_engraver))indexcode(Tuplet_engraver) Engraves tuplet brackets?  In code(Staff).
dit(code(Vertical_align_engraver))indexcode(Vertical_align_engraver) 
)




sect(Sound output)

subsect(output definition)

The MIDI block is analogous to the paper block, but it is simpler.
The code(\midi) block can contain:cindex(MIDI block)

itemize(
it() a  code(\tempo) definition.
it() context definitions
)

Assignments are illegal in the code(\midi) block.


subsect(Context definitions) cindex(context definitions)

Context definitions follow the precisely the same syntax as within the
\paper block.  Translation modules for sound are called performers.
The contexts for MIDI output are defined in file(ly/performer.ly).


subsect(MIDI Instrument Names)cindex(MIDI Instrument Names)
label(midilist)

The MIDI instrument name is set by the indexandcode(Staff.midiInstrument)
property or, if that property is not set, the indexandcode(Staff.instrument)
property.  The instrument name should be chosen from this list.  If
string does not exactly match one from this list then LilyPond uses
the default piano.

COMMENT( acordina = accordion, tango accordian = concertina
         distortion guitar = distorted guitar
         orchestral strings = harp 
         pan flute = wood flute? )

verb("acoustic grand"               "contrabass"             "lead 7 (fifths)"
"bright acoustic"              "tremolo strings"        "lead 8 (bass+lead)"
"electric grand"               "pizzicato strings"      "pad 1 (new age)"
"honky-tonk"                   "orchestral strings"     "pad 2 (warm)"
"electric piano 1"             "timpani"                "pad 3 (polysynth)"
"electric piano 2"             "string ensemble 1"      "pad 4 (choir)"
"harpsichord"                  "string ensemble 2"      "pad 5 (bowed)"
"clav"                         "synthstrings 1"         "pad 6 (metallic)"
"celesta"                      "synthstrings 2"         "pad 7 (halo)"
"glockenspiel"                 "choir aahs"             "pad 8 (sweep)"
"music box"                    "voice oohs"             "fx 1 (rain)"
"vibraphone"                   "synth voice"            "fx 2 (soundtrack)"
"marimba"                      "orchestra hit"          "fx 3 (crystal)"
"xylophone"                    "trumpet"                "fx 4 (atmosphere)"
"tubular bells"                "trombone"               "fx 5 (brightness)"
"dulcimer"                     "tuba"                   "fx 6 (goblins)"
"drawbar organ"                "muted trumpet"          "fx 7 (echoes)"
"percussive organ"             "french horn"            "fx 8 (sci-fi)"
"rock organ"                   "brass section"          "sitar"
"church organ"                 "synthbrass 1"           "banjo"
"reed organ"                   "synthbrass 2"           "shamisen"
"accordion"                    "soprano sax"            "koto"
"harmonica"                    "alto sax"               "kalimba"
"concertina"                   "tenor sax"              "bagpipe"
"acoustic guitar (nylon)"      "baritone sax"           "fiddle"
"acoustic guitar (steel)"      "oboe"                   "shanai"
"electric guitar (jazz)"       "english horn"           "tinkle bell"
"electric guitar (clean)"      "bassoon"                "agogo"
"electric guitar (muted)"      "clarinet"               "steel drums"
"overdriven guitar"            "piccolo"                "woodblock"
"distorted guitar"             "flute"                  "taiko drum"
"guitar harmonics"             "recorder"               "melodic tom"
"acoustic bass"                "pan flute"              "synth drum"
"electric bass (finger)"       "blown bottle"           "reverse cymbal"
"electric bass (pick)"         "skakuhachi"             "guitar fret noise"
"fretless bass"                "whistle"                "breath noise"
"slap bass 1"                  "ocarina"                "seashore"
"slap bass 2"                  "lead 1 (square)"        "bird tweet"
"synth bass 1"                 "lead 2 (sawtooth)"      "telephone ring"
"synth bass 2"                 "lead 3 (calliope)"      "helicopter"
"violin"                       "lead 4 (chiff)"         "applause"
"viola"                        "lead 5 (charang)"       "gunshot"
"cello"                        "lead 6 (voice)")


subsubsect(MIDI Types and Performers)cindex(MIDI Types and Performers)

The types available for  MIDI translators are:
description(
dit(code(Performer_group_performer))indexcode(Performer_group_performer)
dit(code(Score_performer))indexcode(Score_performer)
dit(code(Staff_performer))indexcode(Staff_performer)
)

The performers for MIDI translators are:
description(
dit(code(Key_performer))indexcode(Key_performer)
dit(code(Time_signature_performer))indexcode(Time_signature_performer)
dit(code(Note_performer))indexcode(Note_performer)
dit(code(Lyric_performer))indexcode(Lyric_performer)
dit(code(Swallow_performer))indexcode(Swallow_performer)
)


sect(Pre-defined Identifiers)cindex(Pre-defined Identifiers)
label(ident)

Various identifiers are defined in the initialization files to
provide shorthands for some settings.  Most of them are in file(ly/declarations.ly).

description(
dit(code(\break))keyindex(break) Force a line break in music by using a large
argument for the keyword code(\penalty). 
dit(code(\center))keyindex(center) Used for setting direction  properties.  Equals 0.
dit(code(\down))keyindex(down) Used for setting direction setting properties.  Is
equal to -1.  
dit(code(\free))keyindex(free) Used for setting direction setting properties.  Is
equal to 0.  
dit(code(\left))keyindex(left) Used for setting textalignment property.  Is equal to -1.
dit(code(\nobreak))keyindex(nobreak) Prevent a line break in music by using a large
negative argument for the keyword code(\penalty). 
dit(code(\none))keyindex(none) Used for setting code(Score.beamslopedamping) and
code(Score.beamquantisation) properties.  Is equal to 0.
dit(code(\normal))keyindex(normal) Used for setting code(Score.beamslopedamping) and
code(Score.beamquantisation) properties.  Is equal to 1.
dit(code(\normalkey))keyindex(normalkey) Select normal key signatures where each octave
has the same key signature.  This sets the code(Staff.keyoctaviation) property.
dit(code(\right))keyindex(right) Used for setting textalignment property.  Is set to 1.
dit(code(\shiftoff))keyindex(shiftoff) Disable horizontal shifting of note heads that collide.  
Sets the code(Voice.horizontalNoteShift) property.
dit(code(\shifton))keyindex(shifton) Enable note heads that collide with other note heads
to be shifted horiztonally.  Sets the code(Voice.horizontalNoteShift) property.
dit(code(\slurboth))keyindex(slurboth) Allow slurs to be above or below notes.  This
sets the code(Voice.slurVerticalDirection) property. 
dit(code(\slurdown))keyindex(slurdown) Force slurs to be below notes. This sets the
code(Voice.slurVerticalDirection) property. 
dit(code(\slurup))keyindex(slurup) Force slurs to be above notes.  This sets the
code(Voice.slurVerticalDirection) property.  
dit(code(\specialkey))keyindex(specialkey) Allow keys signatures do differ in different
octaves.  This sets the code(Staff.keyoctaviation) property.  
dit(code(\stemboth))keyindex(stemboth) Allow stems, beams, and slurs to point either
direction.  This sets the code(Voice.verticalDirection) property. 
dit(code(\stemdown))keyindex(stemdown) Force stems, beams, and slurs to point down.
This sets the code(Voice.verticalDirection) property. 
dit(code(\stemup))keyindex(stemup) Force stems, beams and slurs to point up.  This
sets the code(Voice.verticalDirection) property. 
dit(code(\traditional))keyindex(traditional) Used for setting the 
code(Score.beamquantisation) property.  Is equal to 2.  
dit(code(\up))keyindex(up) Used for setting various direction properties.  Is
equal to 1. 
)




sect(Running LilyPond)cindex(Running LilyPond)


When invoked with a filename that has no extension, LilyPond will try
adding a file(.ly) extension first, then a file(.sly) and then a
file(.ly) extension second.  If the filename ends with file(.fly),
LilyPond processes the file as music using file(init.fly).  In this
case, LilyPond does something like: COMMENT(

)verb(\score {
  \notes\relative c {
    \input "yourfile.fly"
  }
  \paper{}
  \midi{}
})
If you invoke LilyPond with a file file(foo.)var(ext) that doesn't
have the file(.ly) extension then LilyPond will look for a file called
file(init.)var(ext) and process this file.  The file
file(init.)var(ext) must contain the code(\maininput) keyword or LilyPond
will not read the user specified file.

When LilyPond processes file(filename.ly) it will produce
file(filename.tex) as output.  If file(filename.ly) contains a second
code(\paper) keyword, then LilyPond will produce file(filename-1.tex)
as well.  Subsequent code(\paper) keywords will produces sequentially
numbered file names.  Several files can be specified; they will each
be processed independently.footnote(Not entirely true: the status of
GUILE is kept).


whenlatex(
latexcommand(\printindex)
)

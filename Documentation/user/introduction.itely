@c -*-texinfo-*-


@node Introduction
@chapter Introduction

There are a lot of programs that let you print sheet music with a
computer. Unfortunately, most of them do not do good job.  Most
computer printouts have a bland, mechanical look, and are unpleasant
to play from.  If you agree with us on that, than you will like
LilyPond: we have tried to capture the original look of hand-engraved
music in a program: we have tuned our algorithms, font-designs, and
program settings to make the output match that of the old editions
that we love to see and love to play from.


@menu
* Music notation and  engraving::  
* Computerized typography::     
* Music representation::        
* Example applications::        
* About this manual::           
@end menu

@node Music notation and  engraving
@section Music notation and engraving



@cindex engraving
@cindex typography

Making sheet music may seem trivial, ``you print 5 lines, and then put
in the notes at different heights'', but as one learns more of it, the
opposite turns out to be true. There are two problems when making
sheet music. First, one has to master music notation: the science of
knowing which symbols to use when what. Second, one has to master
music engraving: the art of placing symbols such that they look
elegant.

Music notation was first started in the medieval centuries. In this
time, monks started to write down hints that indicated how their
sacred music was sung. These hints (neumes), gradually evolved, and at
some point became the note heads.  Lines were added to the neumes, to
indicate a reference pitch, which later became the staff.  Over many
centuries, improvements and extensions were added. For example, the
first notation did not have an explicit notion of rhythm, and
polyphonic music only came into existence in the XXX. The graphic
language of notation is still under development; the innovations of
contemporary music require still newer and more complex notations. A
system of notation encompasses such a wide scope of music inherently
is complex: there are many rules, and for every rule there are
exceptional situations where they do not apply.

The term music engraving derives from the traditional process of
music printing.  Only a few decades ago, sheet music was made by
cutting and stamping the music into zinc or pewter plates,
mirrored. The plate would be inked, and the depressions caused by the
cutting and stamping would hold ink.  An image was formed by pressing
paper to the plate. The stamping and cutting was completely done by
hand. Making corrections was cumbersome, so engraving had to be done
correctly in one go. As you can imagine this was a highly specialized
skill, much more so than the traditional process of printing books.
@cindex craftsmanship
@cindex master
In the traditional German craftsmanship six years of full-time
training, more than any other craft, were required before a student
could call himself a master of the art. After that many more years of
practical experience were needed to become an established music
engraver.  Even today, with the use of high-speed computers and
advanced software, music requires lots of manual fine tuning before it
is acceptable for publication.

Sheet music is performance material, hence everything is done to aid
the musician in letting him perform better.  Music often is far away
from its reader---it might be on a music stand. To make it clearly
readable, traditionally printed sheet music always uses bold symbols,
on heavy staff lines, and is printed on large sheets of paper.  This
``strong'' look is also present in the horizontal spacing.  To
minimize the number of page breaks, (hand-engraved) sheet music is
spaced very tightly. Yet, by a careful distribution of white space,
the feeling of balance is retained, and clutters of black are avoided.

We have used these observations in designing LilyPond.  The images
below shows the flat symbol. On the left, a scan from a Henle edition,
which was made by a computer, and in the center is the flat from a
B@"{a}renreiter edition of the same music. The symbols have noticeable
differences: the left image is much lighter, the staff lines are
thinner, and the glyph has straight layout with sharp corners. By
contrast, the B@"{a}renreiter has a bold and almost voluptuous rounded
look.  Our flat symbol is designed after, among others, this one.  It
is tuned it to harmonize with the thickness of our staff lines, which
are also much thicker than Henle's lines.

@multitable @columnfractions  .4 .3 .3
@item 
@iftex
@image{henle-flat-bw,4cm}
@end iftex
@html
<p>
<a href=henle-flat-bw.png>
<img width=300 src=henle-flat-bw.png>
</a>

@end html

@tab
@iftex
@image{baer-flat-bw,4cm}
@end iftex
@html
<a href=baer-flat-bw.png>
<img width=300 src=baer-flat-bw.png></a>
@end html

@tab
@iftex
@image{lily-flat-bw,4cm}
@end iftex
@html
<a src=lily-flat-bw.png>
<img width=300 src=lily-flat-bw.png>
</a>
@end html

@item
Henly (2000)
@tab
B@"{a}renreiter (1950)
@tab
LilyPond Feta font (2003)

@end multitable


@cindex musical symbols
@cindex font
@cindex blackness
@cindex balance

In spacing, the distribution of space should reflect the durations
between notes.  However, adhering with mathematical precision to the
duration will lead to a poor result. Shown here is an example of a
motive, printed twice. It is printed using exact mathematical spacing,
and with some corrections. Can you spot which fragment is which?

@cindex optical spacing
@lilypond[noindent]
    \score { \notes {
      \property Staff.NoteSpacing \set #'stem-spacing-correction
        = #0.6
      c'4 e''4 e'4 b'4 |
       \stemDown b'4 e''4 a'4 e''4| \stemBoth
       \bar "||"
      \property Staff.NoteSpacing \override #'stem-spacing-correction
      = #0.0
      \property Staff.StaffSpacing \override #'stem-spacing-correction
      = #0.0
      c'4 e''4 e'4 b'4 |
      \stemDown b'4 e''4 a'4 e''4|
    }
    \paper { raggedright = ##t } }
@end lilypond

@cindex regular rhythms
@cindex regular spacing

The fragment that was printed uses only quarter notes: notes that are
played in a constant rhythm. The spacing should reflect
that. Unfortunately, the eye deceives us a little: the eye not only
notices the distance between note heads, but also between consecutive
stems. As a result, the notes of an up-stem/down-stem combination
should be put farther apart, and the notes of a down-up combination
should be put closer together, all depending on the combined vertical
positions of the notes. The first two measures are printed with this
correction, the last two measures without. The notes in the last two
measures form down-stem/up-stems clumps of notes.

@node Computerized typography
@section Computerized typography

Producing good engraving requires skill and knowledge.  It was our
challenge to see if we could put such typographical knowledge into a
computer program. Capturing that knowledge has two aspects: first, it
has to be acquired. Then, it has to be encoded in data-structures and
algorithms.  As the previous examples show, there is a lot of subtlety
involved in music engraving, and unfortunately, only a small fraction
of these details are documented.

One reason for the time that it takes to become a master engraver, is
that all these details must be learned either from experience or from
other engravers: as an engraver gets older and wiser, he will be able
to produce better and more complex pieces.  A similar situation is
present when putting typography into computer programs.  It is not
possible to come up with a final solution for a problem at the first
try. Instead, we start out with simple solution that might cover 75%
of the cases, and gradually refine that solution over the course of
months or years, so that 90 or 95 % of the cases are handled.

This has an important implication for the design of the
program. During development, almost every piece of formatting code
must be considered as temporary. When the need arises, is to be
replaced a solution that will cover even more cases.  A clean way to
accomplish this, is a ``plug-in'' architecture: an architecture where
new pieces of code can be inserted in the program dynamically.  In
such a program, a new solution can be developed along-side the
existing code. It can be perfected separately until it is better than
the existing solution, at which point, the new solution is switched on
by default, and the old one is removed.

Until that time, users must have a way to deal with imperfections:
these 25%, 10% or 5% of the cases that are not handled
automatically. In these cases, a user must be able to override
formatting decisions. A way to accomplish this, is to store decisions
in generic variables, and let the user manipulate these variables.
For example, consider the following fragment of notation.

@lilypond
\score { \notes {
    g'4-\f g4
  	}
\paper { raggedright = ##t }
     }
@end lilypond

@noindent
The position of the forte symbol is slightly awkward, because it is
next to the low note, whereas dynamics should be below notes in
general. This may be remedied by inserting extra space between the
high note and the `f', as shown in this example

@lilypond
\score { \notes {
    \once\property Voice. DynamicLineSpanner  \override #'padding = #4.0 
    g'4-\f g4
  	}
\paper { raggedright = ##t }
     }
@end lilypond

This was achieved with the input statement
@example
    \property Voice. DynamicLineSpanner  \override #'padding = #4.0 
@end example
which increases the amount of space (@code{padding}) between the note
and the dynamic symbol to 4.0 (which is measured in staff space, so
4.0 equals the height of a staff).

Both design aspects, a plug-in architecture, and formatting variables,
are built on top of GUILE, an interpreter for the programming language
Scheme, which is a member of the LISP family. Variables are stored as
Scheme objects, and attached to graphical objects such as note heads
and stems. The variables are a means to adjust formatting details in
individual cases, but they are used in a more general manner.

Consider the case of a publisher that is not satisfied with the in the
default layout, and wants heavier stems. Normally, they are @code{1.3}
times the thickness of staff lines, but suppose that their editions
require them to be twice the thickness of the staff lines. The same
mechanism can be used to adjust a setting globally. By issuing
@example
    \property Score.Stem \override #'thickness = #2.0 
@end example
the entire piece is formatted with thick stems:
@lilypond
\score { \notes {
    \property Score.Stem \override #'thickness = #2.0 
    \once\property Voice. DynamicLineSpanner  \override #'padding = #4.0 
    g'4-\f g4
  	}
\paper { raggedright = ##t }
     }
@end lilypond

@noindent
In effect, by setting these variables, users can define their own
layout styles.

``Plug-ins'' are also implemented using Scheme.  A formatting
``plug-in'' takes the form of a function written in Scheme (or a C++
function made available as a Scheme function), and it is also stored
in a variable.  For example, the placement of the forte symbol in the
example above is calculated by the function
@code{Side_position_interface::aligned_side}.  If we want to replace
this function by a more advanced one, we could issue
@example
    \property Voice.DynamicLineSpanner \override #'Y-offset-callbacks
       = #`(,gee-whiz-gadget)
@end example

@noindent
Now, the formatting process will trigger a call to our new
@code{gee-whiz-gadget} function when the position of the f symbol has
to be determined.

The full scope of this functionality certainly is intimidating, but
there is no need to fear: normally, it is not necessary to define
style-sheets or rewrite formatting functions. In fact, LilyPond gets a
lot of formatting right automatically, so adjusting individual layout
situations is not needed very often at all.


@node Music representation
@section Music representation


One of the big questions when writing batch programs, is what kind of
input the program should expect. Many music notation programs offer a
graphical interface that shows notation, and allow you to enter the
music by placing notes on a staff. From our point of view, this design
is a form of cheating. After all, the core message of a piece of music
notation simply is the music itself. If you start by offering notation
to the user, you have already skipped one conversion, even if it is
implicit. If we want to generate music notation from something else,
then the obvious candidate for the source is the music itself.

On paper this theory sounds very good. In practice, it opens a can of
worms. What really @emph{is} music? Many philosophical treatises must
have been written on the subject.  Instead of losing ourselves in
philosophical arguments over the essence of music, we have reversed
the question to yield a more practical approach. Our assumption is
that the printed score contains all of the music of piece. We build a
program that uses some input format to produce such a score. Over the
course of time, the program evolves. While this happens, we can remove
more and more elements of the input format: as the program improves,
it can fill in irrelevant details of the input by itself. At some
(hypothetical) point, the program is finished: there is no possibility
to remove any more elements from the syntax.  What we have left is by
definition exactly the musical meaning of the score.

There are also more practical concerns.  Our users have to key in the
music into the file directly, so the input format should have a
friendly syntax: a quarter note C is entered as @code{c4}, the code
@code{r8.}  signifies a dotted eighth rest.

As programmers and scientists, we want a clean formal
definition. After all, producing music notation is a difficult
problem, and problems can only be solved if they are
well-specified. Moreover, formally defined formats are easier to write
programs for.  We have chosen for a format that is based on music
expressions: complex musical constructs are built from simple entities
like notes and rests in much the same way that complex formulas are
built from simple expressions such as numbers and mathematical
operators.  The language is described by a context-free
grammar. Reading such languages robustly is a well studied problem,
and we use a standard solution to do it.

LilyPond is a batch program, so the syntax of the program is its
user-interface.  It is the part that they see most, so it is easy to
think that music representation is a very important or interesting
problem. In reality, less than 10% of the source code of the program
handles reading and representing the input, and they form the easy
bits of the program. Converting the music to notation, and calculating
a pretty layout is much more difficult.

@node Example applications
@section Example applications

We have written LilyPond as an experiment of how to condense the art
of music engraving into a computer program. Thanks to all that hard
work, the program can now be used to perform useful tasks.  The
simplest application is printing notes.

@lilypond[relative=1]
  \time 2/4 c4 c g'4 g a4 a g2  
@end lilypond

By adding chord names and lyrics we obtain a lead sheet:
@lilypond[raggedright]
\score { <
  \context ChordNames \chords  { c2 c f2 c }
  \notes \relative c' { \time 2/4 c4 c g'4 g a4 a g2 }
  \context Lyrics \lyrics  { twin4 kle twin kle lit tle star2 } > }
@end lilypond

Polyphonic notation and piano music can also be printed. The following
example combines some more exotic constructs.

@lilypondfile{screech-boink.ly}

The fragments shown above have all been written by hand, but that is not
a requirement. Since the formatting engine is mostly automatic, it can
serve as an output means for other programs that manipulate music. It
can also be used to convert databases of musical fragments to images for
use on websites on multimedia presentations.

This manual also shows an application: the input format is plain text,
and can therefore be easily embedded in other text-based formats, such
as La@TeX{}, HTML or in the case of this manual, Texinfo.  By means of a
special program, the input fragments can be replaced by music images in
the resulting PostScript or HTML output files. This makes it easy to
mix music and text in documents.



@node About this manual
@section About this manual

The manual is divided into the following chapters
@itemize @bullet
@item
@ifhtml The 
@end ifhtml
@emph{@ref{Tutorial}}
gives a  gentle introduction into typesetting music.
First time users should start here. 
@item
@ifhtml
The
@end ifhtml
@emph{@ref{Notation manual}}
discusses topics grouped by notation construct.
@item
@ifhtml
 The
 @end ifhtml
@emph{@ref{Technical manual}}
@c
discusses the general design of the program, and how to extend its
functionality.
@item
@ifhtml
The chapter
@end ifhtml
@emph{@ref{Invoking LilyPond}}  explains how to run LilyPond and its helper
programs.
@end itemize

Once you are an experienced user, you can use the manual as reference:
there is an extensive index@footnote{If you are looking for something,
and you cannot find it by using the index, that is considered a bug.
In that case, please file a bug report.}, but the document is also
available in
@ifnothtml
a big HTML page,
@end ifnothtml 
@ifhtml
@uref{../lilypond.html, a big HTML page}
@end ifhtml
which can be searched easily using the search facility of a web
browser.
@cindex search in manual
@cindex using the manual

@c  TODO: advise to buy a book on notation? 

If you are not familiar with music notation, or music terminology
(especially if you are a foreigner), then it is advisable to consult
the glossary as well. The glossary explains musical terms, and
includes translations to various languages. It is a
@ifhtml
@uref{../glossary.html,separate document}
@end ifhtml
@ifnothtml
separate document, available in HTML and PDF and can be printed as
well.
@end ifnothtml
@cindex idiom
@cindex jargon
@cindex terminology
@cindex foreign languages
@cindex language


This manual is not complete without a number of other documents. They
are not available in print, but should be included with the
documentation package for your platform

@itemize @bullet
@item
Generated internal documentation.
@ifhtml
available @uref{../lilypond-internals/lilypond-internals.html,here}
@end ifhtml

The generated internal documentation is a heavily crosslinked HTML
document, produced directly from the formatting definitions used.  It
documents the nit-gritty details of each and every LilyPond class,
object and function.

Almost all formatting functionality that is used internally, is
available directly to the user. For example, all variables that
control thicknesses, distances, etc, can be changed in input
files. There are a huge number of formatting options, and all of them
are described in the generated documentation.  Each section of the
reference manual has a @b{See also} subsection, which refers to the
the generated documentation.  In the HTML document, these subsections
have clickable links.

@item
  Templates
@ifhtml
(available @uref{../../../input/templates/out-www/collated-files.html,here})
@end ifhtml

After you have gone through the tutorial, in theory you should be able
to write input files. In practice, writing files from scratch turns
out to be intimidating.  To give a headstart, we have collected a
number of often-used formats in example files.  These files can be
used as a start, by copying the template, and adding notes in the
appropriate places.

@item
  Various input examples
@ifhtml
available @uref{../../../input/test/out-www/collated-files.html,here}
@end ifhtml
@cindex snippets

These small files show various tips and tricks, and are available as a
big HTML document, with pictures and explanatory texts included.


@item
  The regression test
@ifhtml
available @uref{../../../input/regression/out-www/collated-files.html,here}
@end ifhtml

We strive to test each feature in one test file. This collection is
primarilyt there to help us debug problems, but it can be instructive
to see how we excercise the program. The format is like the tips and
tricks document.

@end itemize


The location of the documentation files that are mentioned here can
vary from system to system.  On occasion, this manual refers to
initialization and example files.  Throughout this manual, we refer to
input files relative to the top-directory of the source archive. For
example, @file{input/test/bla.ly} may refer to the file
@file{lilypond-1.7.19/input/test/bla.ly}.  On binary packages for the
Unix platform, the documentation and examples can typically be found
somewhere below @file{/usr/share/doc/lilypond/}. Initialization files,
for example @file{scm/lily.scm}, or @file{ly/engraver-init.ly}, are
usually found in the directory @file{/usr/share/lilypond/}.

@cindex adjusting output
@cindex variables
@cindex properties
@cindex lilypond-internals
@cindex internal documentation
@cindex Scheme
@cindex extending lilypond
@cindex bugreport
@cindex index

Finally, this and all other manuals, are available online both as PDF
files and HTML from the web site, which can be found at
@uref{http://www.lilypond.org/}.

@cindex website 
@cindex URL

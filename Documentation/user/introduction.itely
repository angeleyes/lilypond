@c -*-texinfo-*-

@node Introduction
@chapter Introduction

LilyPond is a program to print sheet music.  If you have used notation
programs before, then the way to use this program might be surprising
at first sight.  To print music with lilypond, you have to enter
musical codes in a file.  Then you run LilyPond on the file, and the
music is produced without any further intervention.  For example,
something like this:

@lilypond[fragment,verbatim, relative 1, intertext="produces this

"]
\key c \minor r8 c16 b c8 g as c16 b c8 d | g,4
@end lilypond

@cindex encoding music

Encoding music using letters and digits may appear strange,
intimidating or even clumsy at first. Nevertheless, when you take the
effort to learn the codes and the program you will find that it is
easier than it seems.  Entering music can be done quickly, and you
never have to remember how you made the program do something
complicated: it is all in the input code, and you only have to read
the file to see how it works. Moreover, when you use LilyPond, you are
rewarded with very nicely looking output.

In this chapter, we will explain the reasoning behind this unusual
design, and how this approach affects you as a user.

@menu
* Batch processing::            
* Music engraving::             
* Music representation::        
* Example applications::        
* About this manual::           
@end menu

@node Batch processing
@section Batch processing

@cindex GUI
@cindex Batch
@cindex UNIX

When we started developing LilyPond, we were still studying at the
university.  We were interested in music notation, not as publishers
or musicians, but as students and scientists. We wanted to figure to
what extent formatting sheet music could be automated.  Back then GUIs
were not as ubiquitous as they are today, and we were immersed in the
UNIX operating system, where it is very common to use compilers to
achieve computing tasks, so our computerized music engraving
experiment took on the form of a compiler.


@ignore
@cindex free software
@cindex sharing software

You can freely use, modify and redistribute LilyPond. This choice was
also motivated by our academic background. In the scientific community
it has always been a tradition to share knowledge, also if that
knowledge was packaged as software. One of the most visible groups
that stimulated this philosophy, was the Free Software Foundation,
whose popular GNU project aimed to replace closed and proprietary
computing solutions with free (as in ``Libre'') variants. We jumped on
that bandwagon, and released LilyPond as free software.  That is the
reason that you can get LilyPond at no cost and without any strings
attached.
@end ignore


@node Music engraving
@section Music engraving



@cindex engraving
@cindex typography

Making sheet music may seem trivial at first (``you print 5 lines, and
then put in the notes at different heights''), @emph{music engraving},
i.e. professional music typography, is in another ballpark.  The term
`music engraving' derives from the traditional process of music
printing.  Only a few decades ago, sheet music was made by cutting and
stamping the music into zinc or pewter plates, mirrored. The plate
would be inked, and the depressions caused by the cutting and stamping
would hold ink.  A positive image was formed by pressing paper to the
plate. Stamping and cutting was completely done by hand. Making
corrections was cumbersome, so engraving had to be done correctly in
one go. As you can imagine this was a highly specialized skill, much
more so than the traditional process of printing books.
@cindex craftsmanship
@cindex master
In the traditional German craftsmanship six years of full-time
training, more than any other craft, were required before a student
could call himself a master of the art. After that many more years of
practical experience were needed to become an established music
engraver.  Even today, with the use of high-speed computers and
advanced software, music requires lots of manual fine tuning before it
acceptable to be published.

When we wanted to write a computer program to do create music
typography, we encountered the first problem: there were no sets of
musical symbols available: either they were not available freely, or
they did not look well to our taste. Not let down, we decided to try
font design ourselves. We created a font of musical symbols, relying
on nice printouts of hand-engraved music.  The experience helped
develop a typographical taste, and it made us appreciate subtle design
details. Without that experience, we would not have realized how ugly
the fonts were that we admired at first.


@lilypond[noindent]
#(define magfact 3.0)
\score {  \notes { as'2 r4 }
          \paper {
                 raggedright = ##t
              \translator {
                  \ScoreContext
                  AccidentalPlacement \override #'right-padding = #3.0
                  StaffSymbol \override #'transparent =   ##t
                  Clef \override #'transparent = ##t
                  TimeSignature \override #'transparent = ##t
                  Accidental \override #'font-magnification = #magfact
                  Rest \override #'font-magnification = #magfact
                  NoteHead \override #'font-magnification = #magfact
                  Stem \override #'transparent = ##t
                  } } }
@end lilypond

@cindex musical symbols
@cindex font
@cindex blackness
@cindex balance

The figure above shows a few notable glyphs. For example, the
half-notehead is not elliptic but slightly diamond shaped.  The
vertical stem of a flat symbol should be slightly brushed,
i.e. becoming wider at the top. Fine endings, such as the one on the
bottom of the quarter rest, should not end in sharp points, but rather
in rounded shapes.  Taken together, the blackness of the font must be
carefully tuned together with the thickness of lines, beams and slurs
to give a strong yet balanced overall impression.

Producing a strong and balanced look is the real challenge of music
engraving. It is a recurring theme with many variations.  In spacing,
the balance is in a distribution that reflects the character of the
music. The spacing should not lead to unnatural clusters of black and
big gaps with white space.  The distances between notes should reflect
the durations between notes, but adhering with mathematical precision
to the duration will lead to a poor result. Shown here is an example
of a motive, printed twice. It is printed using both exact,
mathematical spacing, and with some corrections. Can you spot which is
which?


@cindex optical spacing
@lilypond[noindent]
    \score { \notes {
      \property Staff.NoteSpacing \set #'stem-spacing-correction
        = #0.6
      c'4 e''4 e'4 b'4 |
       \stemDown b'4 e''4 a'4 e''4| \stemBoth
      \property Staff.NoteSpacing \override #'stem-spacing-correction
      = #0.0
      \property Staff.StaffSpacing \override #'stem-spacing-correction
      = #0.0
      c'4 e''4 e'4 b'4 |
      \stemDown b'4 e''4 a'4 e''4|
    }
    \paper { raggedright = ##t } }
@end lilypond

@cindex regular rhythms
@cindex regular spacing

The fragment that was printed uses only quarter notes: notes that are
played in a constant rhythm. The spacing should reflect
that. Unfortunately, the eye deceives us a little: the eye not only
notices the distance between note heads, but also between consecutive
stems. The notes of a up-stem/down-stem combination should be put
farther apart, and the notes of a down-up combination should be put
closer together, all depending on the combined vertical positions of
the notes. The first two measures are printed with this correction,
the last two measures without. The notes in the last two measures form
downstem/upstems clumps of notes.

We hope that these examples show that music typography is a subtle
business, and that it requires skill and knowledge to produce good
engraving.  It was our challenge to see if we could put such knowledge
into a computer program.


@node Music representation
@section Music representation


One of the big questions when making programs, is what kind of input
the program should expect. Many music notation programs offer a
graphical interface that shows notation, and allow you to enter the
music by placing notes on a staff. From our point of view, this design
is a form of cheating. After all, the core message of a piece of music
notation simply is the music itself. If you start by offering notation
to the user, you have already skipped one conversion, even if it is
implicit. If we want to generate music notation from something else,
then the obvious candidate for the source is the music itself.

On paper this theory sounds very good. In practice, it opens a can of
worms. What really @emph{is} music? Many philosophical treatises must
have been written on the subject.  Instead of losing ourselves in
philosophical arguments over the essence of music, we have reversed
the question to yield a more practical approach. Our assumption is
that the printed score contains all of the music of piece. We build a
program that uses some input format to produce such a score. Over the
course of time, the program evolves. While this happens, we can remove
more and more elements of the input format: as the program improves,
it can fill in irrelevant details of the input by itself. At some
(hypothetical) point, the program is finished: there is no possibility
to remove any more elements from the syntax.  What we have left is by
definition exactly the musical meaning of the score.

There are also more practical concerns.  Our users have to key in the
music into the file directly, so the input format should have a
friendly syntax. As programmers and scientists, we want a
clean formal definition. After all, producing music notation is a
difficult problem, and in the scientific world, problems can only be
solved if they are well-specified. Moreover, formally defined formats
are easier to write programs for.

These ideas shaped our music representation: it is a compact format
that can easily be typed by hand. It complex musical constructs from
simple entities like notes and rests, in much the same way that one
builds complex formulas from simple expressions such as numbers and
mathematical operators.

@node Example applications
@section Example applications

As programmers and hedonists we enjoy beauty in code, and code that
produces beautiful typeset music, but nevertheless this program can
applied to do useful things. In this section, we show a few small
examples of what is possible.

[TODO: show examples]

The following example combines some more  exotic uses of notation

@lilypondfile{screech-boink.ly}  



@node About this manual
@section About this manual

The manual is divided into the following chapters
@table @strong
@item Tutorial
  Gives a gentle introduction into typesetting music.
  Start here if you have never used lilypond before.
@item   Reference manual
  Here, each aspect of typesetting music is discussed.
@item Internals
  This chapter discusses how it works from the inside, and how you can
  extend the program.
@item Invoking
  This chapter explains how to runn LilyPond and its helper programs. 
@end table

Once you are experienced with, you can simply use the manual as
reference: there is an extensive index@footnote{If you are looking for
something, and you cannot find it by using the index, that is
considered a bug.  In that case, please file a bug report}, but the
document is also available in
@ifhtml
One Big Page,
@end ifhtml
@ifnothtml
@uref{One Big Page,../lilypond.html}
@end ifnothtml 
which is is available for text search using your browser's search
facility.
@cindex search in manual
@cindex using the manual


If you are familiar with music notation, and music terminology
(especially if you are a foreigner), then it is advisable to consult
the glossary as well. This documents explains many terms, and includes
translations to various languages. It is a 
@ifhtml
@uref{separate document,../glossary.html}
@end ifhtml
@ifnothtml
separate document, and can be printed as well.
@end ifnothtml
@cindex idiom
@cindex jargon
@cindex terminology
@cindex foreign languages
@cindex language


This manual is not complete without a number of other documents. They
are not available in print, but should be included with the
documentation package for your platform

@itemize @bullet
@item
Generated internal documentation.
@ifhtml
available @uref{here,../lilypond-internals/lilypond-internals.html}
@end ifhtml

Almost all formatting functionality that is used internally, is
available directly to the user. For example, all variables that
control thicknesses, distances, etc, can be changed from input
files. There are a huge number of formatting options, and it would be
impossible to describe them all in a hand-written manual. The
generated internal documentation is a heavily crosslinked HTML
document, produced directly from the formatting definitions used.  It
the nit-gritty details of each and every LilyPond class, object and
function.

Each section of the reference manual has a @b{See also}
subsection, with links (in the HTML document, at least) to the
generated documentation.

@item
  Templates
@ifhtml
available @uref{here,../../../input/templates/out-www/collated-files.html}
@end ifhtml

  When you have gone through the tutorial, you theoretically should be
able to start writing input files. However, this turns out to be a
little intimidating.  To give you a headstart, we have collected a
number of often-used formats in example files. You can take one of
these example files, and add notes in the appropriate places to
generate output.

@item
  Various input examples
@ifhtml
available @uref{here,../../../input/test/out-www/collated-files.html}
@end ifhtml
@cindex snippets

These small files show various applications of lilypond, and are
available as a big HTML document, with pictures and explanatory texts
included.


@item
  The regression test
@ifhtml
available @uref{here,../../../input/regression/out-www/collated-files.html}
@end ifhtml

We strive to test each feature in a collection of input snippets. This
is primarily to help us debug the program, but it can be instructive
to see how we excercise the program. The format is like the input
examples.

@end itemize

@cindex adjusting output
@cindex variables
@cindex properties
@cindex lilypond-internals
@cindex internal documentation
@cindex Scheme
@cindex extending lilypond
@cindex bugreport
@cindex index

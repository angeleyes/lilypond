@c -*- coding: utf-8; mode: texinfo; documentlanguage: de -*-
@c This file is part of lilypond-learning.tely
@ignore
    Translation of GIT committish: a8c28adaf60e575fa101c93b4fda7557741bfb86

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  See TRANSLATION for details.
@end ignore

@c \version "2.11.51"


@node Fundamental concepts
@chapter Fundamental concepts

Nachdem im Tutorial gezeigt wurde, wie aus einfachen Text-Dateien
wunderschön formatierte Musiknoten erzeugt werden können, stellt
dieses Kapitel die Konzepte und Techniken vor, wie auch komplexere
Partituren erstellt werden können.

@menu 
* How LilyPond files work::
* Voices contain music::
* Contexts and engravers::
* Extending the templates::
@end menu

@node How LilyPond files work
@section How LilyPond files work

Das LilyPond Eingabeformat hat eine ziemlich freie Form, so dass 
für erfahrene Benutzer viel Freiheit besteht, die Struktur ihrer 
Quelldateien anzulegen. Für Neulinge kann diese Flexibilität aber 
erst einmal verwirrend sein. In diesem Kapitel soll darum ein Teil 
dieser Strukturen dargestellt werden, vieles aber zur Vereinfachung 
auch weggelassen werden. Für eine komplette Beschreibung des Eingabeformats 
siehe @ruser{File structure}.

Die meisten Beispiele in diesem Handbuch sind kleine Schnipsel, wie 
etwa dieser:

@example
c4 a b c
@end example

Wie hoffentlich bekannt ist, lässt sich solch ein Schnipsel nicht 
in dieser Form übersetzen. Diese Beispiele sind also nur Kurzformen 
von wirklichen Beispielen. Sie müssen wenigstens zusätzlich in 
geschweifte Klammern gesetzt werden.

@example
@{
  c4 a b c
@}
@end example

Die meisten Beispiele benutzen auch den @code{\relative c'}-Befehl. 
Der ist nicht nötig, um die Dateien zu übersetzen, aber in den meisten 
Fällen sieht der Notensatz seltsam aus, wenn man den Befehl 
weglässt.

@lilypond[quote,fragment,ragged-right,verbatim]
\relative c'' {
  c4 a b c
}
@end lilypond

Eine komplette Definition des Eingabeformats findet sich
im Kapitel @ruser{File structure}.

@menu
* Introduction to the LilyPond file structure::
* Score is a (single) compound musical expression::
* Nesting music expressions::
* On the un-nestedness of brackets and ties::
@end menu

@node Introduction to the LilyPond file structure
@subsection Introduction to the LilyPond file structure

@cindex Eingabeformat
@cindex Dateistruktur

Ein grundlegendes Beispiel einer Eingabedatei für LilyPond lautet:

@example
\version @w{"@version{}"}
\header @{ @}
\score @{
  @var{...zusammengesetzter Musik-Austruck...}  % Die gesamte Musik kommt hier!
  \layout @{ @}
  \midi @{ @}
@}
@end example

@noindent
Aufgrund der Flexibilität von LilyPond gibt es viele Variationen dieses 
Schemas, aber dieses Beispiel dient als einfacher Ausgangspunkt.

@funindex \book
@funindex \score
@cindex book
@cindex score

Bisher hat noch keines der Beispiele den @code{\score@{@}}-Befehl
benutzt, da Lilypond derartige zusätzliche Befehle automatisch
bei Bedarf einfügt, wenn die Eingabedatei eine einfache Struktur 
hat.

Sehen wir uns als ein solches einfaches Beispiel an:

@example
\relative c'' @{
  c4 a d c
@}
@end example

@noindent
Im Hintergrund kommen hier noch einige Ebenen dazu: LilyPond-Code 
in der obigen Form ist in Wirklichkeit eine Abkürzung. Auch wenn man so 
Dateien schreiben kann und sie auch korrekt gesetzt werden, heißt 
der vollständige Code, der hier gemeint ist, eigentlich:

@example
\book @{
  \score @{
    \new Staff @{
      \new Voice @{
        \relative c'' @{
          c4 a b c
        @}
      @}
    @}
    \layout @{ @}
  @}
@}
@end example

@noindent
Mit anderen Worten: Wenn die Eingabedatei einen einfachen Musik-Ausdruck
enthält, wird LilyPond die Datei so interpretieren, als ob dieser
Ausdruck in den oben gezeigten Befehlen eingegeben wurde. Diese nötige 
Stuktur wird automatisch im Speicher beim Aufruf von LilyPond erzeugt, 
ohne dass der Benutzer davon etwas bemerkt.

@cindex implicit contexts

@strong{Ein Wort der Warnung ist jedoch angebracht!} Viele der Beispiele
in der Dokumentation von LilyPond lassen die @code{\new Staff} und @code{\new Voice}
Befehle zur Erzeugung einer Notenzeile und einer Stimme (beides ist in 
LilyPond ein sogenannter Kontext) bewusst aus, 
damit sie implizit von LilyPond im Speicher erzeugt werden.
Für einfache Dokumente funktioniert das im Allgemeinen sehr gut, für 
komplexere Partituren können dadurch aber unerwartete Ergebnisse 
entstehen, teilweise sogar unerwartete leere Notenzeilen. Um 
die entsprechenden Kontexte in diesem Fall explizit zu erzeugen, 
siehe @ref{Contexts and engravers}.

@warning{Wenn mehr als ein paar Zeilen an Musik eingegeben werden,
empfielt es sich, die Notenzeilen und die Stimmen immer explizit
mit @code{\new Staff} und @code{\new Voice} zu erzeugen.}

Im Moment wollen wir aber zu unserem ersten Beispiel zurückkehren und
nur den @code{\score}-Befehl näher betrachten.

Eine Partitur (@code{\score}) muss immer mit einem musikalischen Ausdruck 
beginnen. Das ist letztendlich alle Musik, angefangen bei einer 
einzelnen
Note bis hin zu einer riesigen Partitur mit vielen Notensystemen 
(bezeichnet durch @code{GrandStaff}):

@example
@{
  \new GrandStaff <<
    @var{...hier die gesamte Partitur...}
  >>
@}
@end example

@noindent
Da sich alles innerhalb der geschweiften Klammern @code{@{ ... @}} 
befindet, wird es wie ein einziger musikalischer Ausdruck behandelt.


Ein @code{\score} auch andere Dinge enthalten, wie etwa

@example
\score @{
  @{ c'4 a b c' @}
  \layout @{ @}
  \midi @{ @}
  \header @{ @}
@}
@end example

@funindex \header
@funindex \layout
@funindex \midi
@cindex header
@cindex layout
@cindex midi

@noindent

@noindent
Wie man sieht sind die drei Befehle @code{\header}, @code{\layout} und
@code{\midi} von spezieller Natur: Im Gegensatz zu vielen Anderen Befehlen, 
die auch mit einem @code{\} beginnen, liefern sie @emph{keinen} Musikausdruck
und sind auch nicht Teil eines musikalischen Ausdrucks. Daher können sie
sowohl innerhalb eines @code{\score}-Blocks als auch außerhalb plaziert
werden. Tatsächlich werden einige dieser Befehle meist außerhalb des 
@code{\score}-Blocksgesetzt, zum Beispiel findet sich der @code{\header} 
sehr oft oberhalb der @code{\score}-Umgebung. Das 
funktioniert genauso gut.


Zwei bisher noch nicht aufgetauchte Befehle sind 
@code{\layout @{ @}} und @code{\midi @{@}}. Wenn sie in einer 
Datei vorkommen, führt dies dazu, dass Lilypond eine druckfähige PDF-Datei
bzw. eine MIDI-Datei erzeugt. Genauer beschrieben werden sie im 
Benutzerhandbuch -- @ruser{Score layout}, and
@ruser{Creating MIDI files}.

@cindex Partituren, mehrfache

Ihr LilyPond Code kann auch mehrere @code{\score}-Blöcke enthalten. 
Jeder davon wird als eigenständige Partitur interpretiert, die 
allerdings alle in dieselbe Ausgabedatei plaziert weden.
Ein @code{\book}-Befehl ist nicht explizit notwendig -- er wird 
implizit erzeugt. Wenn jedoch für jeden @code{\score}-Block in einer 
einzigen @code{.ly}-Datei eine eigene Ausgabe-Datei erzeugt werden soll,
dann muss jeder dieser Blöcke in einen eigenen @code{\book}-Block
gesetzt werden: Jeder @code{\book}-Block erzeugt dann eine
eigene Ausgabedatei.

Zusammenfassung:

Jeder @code{\book}-Block erzeugt eine eigene Ausgabedatei (z.B. eine
PDF-Datei). Wenn Sie keinen derartigen Block explizit angegeben haben,
setzt LilyPond den gesamten Dateiinhalt innerhalb eines einzigen 
impliziten @code{\book}-Blocks.

Jeder @code{\score}-Block beschreibt ein eigenständiges Musikstück 
innerhalb des @code{\book}-Blocks.

Jeder @code{\layout}-Block wirkt sich auf den @code{\score}- oder
@code{\book}-Block aus, in dem er auftritt. So wirkt z.B. ein 
@code{\layout}-Block innerhalb eines @code{\score}-Blocks nur auf 
diesen einen Block und seinen gesamten Inhalt, ein @code{\layout}-Block 
außerhalb eines @code{\score}-Blocks (und daher innerhalb des implizit 
erzeugten oder explizit angegebenen @code{\book}-Blocks) jedoch auf 
alle @code{\score}-Blocks innerhalb dieses @code{\book}-Blocks.

Nähere Details finden sich im Abschnitt @ruser{Multiple scores in a book}.


@cindex Variablen
@cindex Bezeichner

Eine gute Möglichkeit zur Vereinfachung sind selbst definierte Variablen. 
Alle Vorlagen verwenden diese Möglichkeit.

@example
melodie = \relative c' @{
  c4 a b c
@}

\score @{
  @{ \melodie @}
@}
@end example

Wenn LilyPond diese Datei analysiert, nimmt es den Inhalt
von @code{melodie} (alles nach dem Gleichheitszeichen) und 
fügt ihn immer dann ein, wenn ein @code{\melodie} 
vorkommt. Die Namen sind frei wählbar, die Variable kann genauso
gut  @code{melodie}, @code{GLOBAL},
@code{rechteHandklavier}, oder @code{foofoobarbaz} heißen. Für mehr
Information siehe
@ref{Saving typing with variables and functions}.
Als Variablenname kann fast jeder beliebige Name benutzt werden,
allerdings dürfen nur Buchstaben vorkommen (also keine Zahlen, Unterstriche,
Sonderzeichen, etc.) und er darf nicht wie ein LilyPond-Befehl
lauten. Die genauen Einschränkungen sind beschrieben in 
@ruser{File structure}.

@seealso

Eine vollständige Definition des Eingabeformats findet sich in 
@ruser{File structure}.



@node Score is a (single) compound musical expression
@subsection Score is a (single) compound musical expression

@funindex \score
@cindex score
@cindex Partitur
@cindex Musikstück
@cindex zusammengesetzter Musikausdruck
@cindex Musikausdruck, zusammengesetzter


Im vorigen Kapitel, @ref{Introduction to the LilyPond file structure}, 
wurde die allgemeine Struktur einer LilyPond-Quelldatei 
beschrieben. Aber anscheinend haben wir die wichtigste 
Frage ausgelassen, nämlich wie man herausfindet, was nach 
dem @code{\score} geschrieben werden soll.

In Wirklichkeit ist das aber gar kein Geheimnis. Diese 
Zeile ist die Antwort:


@quotation
@emph{Eine Partitur fängt immer mit @code{\score} an, gefolgt 
von einem einzelnen musikalischen Ausdruck.}
@end quotation

@noindent
Vielleicht wollen Sie noch einmal 
@ref{Music expressions explained} überfliegen. In diesem
Kapitel wurde gezeigt, wie sich große musikalische Ausdrücke 
aus kleinen Teilen zusammensetzen. Noten können zu Akkorden 
verbunden werden usw. Jetzt gehen wir aber in die andere Richtung 
und betrachten, wie sich ein großer musikalischer Ausdruck 
zerlegen lässt.

@example
\score @{
  @{   % diese Klammer startet den großen mus. Ausdruck
    \new GrandStaff <<
      @var{...hier eine ganze Wagner-Oper einfügen...}
    >>
  @}   % diese Klammer beendet den Ausdruck
  \layout @{ @}
@}
@end example

Eine Wagner-Oper ist mindestens doppelt so lang wie dieses Handbuch,
beschränken wir uns also auf einen Sänger und Klavier. Wir brauchen 
keine Orchesterpartitur (@code{GrandStaff}) dafür, darum lassen wir 
den Befehl weg. Wir brauchen aber einen Sänger und ein Klavier.

@example
\score @{
  @{
    <<
      \new Staff = "Sänger" <<
      >>
      \new PianoStaff = Klavier <<
      >>
    >>
  @}
  \layout @{ @}
@}
@end example

Zur Erinnerung: mit @code{<<} und @code{>>} werden Noten gleichzeitig
gesetzt; wir wollen ja auch Klavier- und Sängerstimme gleichzeitig 
und nicht hintereinander haben. Bei genauerem Hinsehen fällt auf, dass
die @code{<< ... >>}-Konstruktion für die Notenzeile des Sängers eigentlich 
nicht unbedingt nötig wäre, da sie ja nur einen (sequenzielle) musikalischen
Ausdruck enthält, nämlich alle Noten des Sängers hintereinander. Daher
könnte an sich auch einfach ein @code{@{...@}} benutzt werden. Die 
Spitzklammern sind allerdings notwendig, sobald die Notenzeile mehrere
parallelle Ausdrücke -- wie etwa zwei parallele Stimmen oder eine Stimme
mit zugehörigem Text -- enthält. 
Wir werden die Musik später in das Beispiel einfügen, im Moment begnügen 
wir uns mit einigen Platzhalter-Noten und -Texten.

@lilypond[verbatim,quote,ragged-right]
\score {
  <<
    \new Staff = "Sänger" <<
      \new Voice = "Singstimme" { c'1 }
      \addlyrics { And }
    >>
    \new PianoStaff = "Klavier" <<
      \new Staff = "oben" { }
      \new Staff = "unten" { }
    >>
  >>
  \layout { }
}
@end lilypond

Jetzt haben wir viel mehr Details. Wir haben ein System (engl. staff) 
für einen Sänger, in dem sich wieder eine Stimme (engl. voice) 
befindet. @code{Voice} bedeutet für LilyPond eine Stimme (sowohl 
gesungen als auch gespielt) und evtl. zusätzlich einen Text. Zusätzlich 
werden zwei Notensysteme für das Klavier mit dem Befehl @code{\new 
PianoStaff} gesetzt. @code{PianoStaff} bezeichnet die Piano-Umgebung (etwa 
durchgehende Taktstriche und die geschweifte Klammer am Anfang), in der 
dann wiederum zwei eigene Systeme ("upper" für die rechte Hand und 
"lower" 
für die linke) erstellt werden.

Jetzt könnte man in diese Umgebung Noten einfügen. Innerhalb der 
geschweiften 
Klammern neben @code{\new Voice = vocal} könnte man


@example
\relative c'' @{
  r4 d8\noBeam g, c4 r
@}
@end example

@noindent schreiben. Aber wenn man seine Datei so direkt schreibt, wird 
der @code{\score}-Abschnitt sehr lang und es wird ziemlich schwer zu 
verstehen, wie alles zusammenhängt. Darum bietet es sich an, Bezeichner 
(oder Variablen) zu verwenden.


@lilypond[verbatim,quote,ragged-right]
melodie = \relative c'' { r4 d8\noBeam g, c4 r }
text    = \lyricmode { And God said, }
oben    = \relative c'' { <g d g,>2~ <g d g,> }
unten   = \relative c { b2 e2 }

\score {
  <<
    \new Staff = "Sänger" <<
      \new Voice = "Singstimme" { \melodie }
      \addlyrics { \text }
    >>
    \new PianoStaff = "Klavier" <<
      \new Staff = "oben" { \oben }
      \new Staff = "unten" {
        \clef "bass"
        \unten
      }
    >>
  >>
  \layout { }
}
@end lilypond

Achten Sie auf den Unterschied zwischen Noten, die mit @code{\relative}
oder direkt in einem musikalischen Ausruck eingegeben werden, und 
dem Text des Lieds, der innerhalb @code{\lyricmode} angegeben 
werden muss. Diese Unterscheidung ist für LilyPond essentiell,
um zu entscheiden, ob der folgende Inhalt als Musik oder Text 
interpretiert werden soll. Wie könnte LilyPond sonst entscheiden, 
ob @code{@{a b c@}} die drei Noten a, b und c darstellen soll oder
den Text eines Lieds über das Alphabet!

Beim Schreiben (oder Lesen) einer @code{\score}-Umgebung 
sollte man langsam und sorgfältig vorgehen. Am besten fängt 
man mit dem größten Gebilde an und definiert dann die darin 
enthaltenen kleineren der Reihe nach. Es hilft auch, sehr 
genau mit den Einzügen zu sein, so dass jede Zeile, die 
der gleichen Ebene angehört, wirklich horizontal an der 
gleichen Stelle beginnt.

@seealso

Benutzerhandbuch: @ruser{Structure of a score}.


@node Nesting music expressions
@subsection Nesting music expressions

@cindex Notenzeilen, temporäre
@cindex Ossia

Notenzeilen (die @q{Staff}-Kontexte) müssen nicht unbedingt gleib
zu Beginn erzeugt werden -- sie können auch zu einem späteren
Zeitpunkt eingeführt weden. Das ist vor allem nützlichm um 
@rglosnamed{ossia,Ossias} zu erzeugen. Hier folgt ein kures Beispiel,
wie eine zusätzliche temporäre Notenzeile für nur drei Noten erzeugt 
werden kann:

@lilypond[verbatim,quote,ragged-right]
\new Staff {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff {
        f8 f c
      }
    >>
    r4 |
  }
}
@end lilypond

@noindent
Wie man sieht ist die Größe des Notenschlüssels dieselbe wie sie 
auch bei einer Schlüsseländerung auftritt -- etwas kleiner als
der Schlüssel am Beginn einer Notenzeile. Dies ist normal für
Notenschlüssel, die innerhalb einer Notenzeile gesetzt werden.

@cindex Notenzeile, Positionierung

Der Ossia-Abschnitt kann auch oberhalb der Hauptnotenzeile
gesetzt werden:

@lilypond[verbatim,quote,ragged-right]
\new Staff = "Hauptzeile" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = "Hauptzeile" }
      { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

Dieses Beispiel benutzt den @code{\with}-Befehl, der später noch
genauer erklärt wird. Damit kann das Standardverhalten einer
einzelnen Notenzeile geändert werden: Hier wird einfach angegeben,
dass die neue Notenzeile oberhalb der bereits existierenden Zeile
mit Namen @qq{Hauptzeile} plaziert werden soll, anstatt 
standardmäßig unterhalb.

@seealso

Ossia werden oft ohne Notenschlüssel und Taktangabe gedruck, meist 
auch etwas kleiner als die anderen Notenzeilen. Dies ist natürlich 
auch in LilyPond möglich, benötigt aber Befehle, die bisher noch 
nicht vorgestellt wurden. Siehe @ref{Size of objects}
und @ruser{Ossia staves}.


@node On the un-nestedness of brackets and ties
@subsection On the un-nestedness of brackets and ties

@cindex Klammern, geschachtelt
@cindex Schachtelung von Klammern

Sie haben bisher zahlreiche verschiedene Arten von Klammern
beim Schreiben von Musik mit LilyPond kennengelernt. Diese
folgen verschiedenen Regeln, die zu Beginn vielleicht 
verwirrend wirken. Bevor die genauen Regeln vorgestellt werden,
wollen wir die diversen Klammerarten kurz rekapitulieren:

@c attempt to force this onto a new page
@need 50
@multitable @columnfractions .3 .7
@headitem Klammerart
  @tab Funktion
@item @code{@{ .. @}}
  @tab Umschließt ein sequenzielles Musiksegment
@item @code{< .. >}
  @tab Umschließt die Noten eines Akkords
@item @code{<< .. >>}
  @tab Umschließt parallele Musikausdrücke
@item @code{( .. )}
  @tab Markiert den Beginn und das Ende eines Haltebogens
@item @code{\( .. \)}
  @tab Markiert den Beginn und das Ende eines Phasierungsbogens
@item @code{[ .. ]}
  @tab Markiert den Beginn und das Ende eines manuell erzeugten Balkens
@end multitable


Zusätzlich sollten vielleicht noch einige weiter Konstruktionen
erwähnt werden, die Noten auf irgendeine Art und Weise verbinden:
Haltebögen (durch eine Tilde @code{~} markiert),
Triolen (als @code{\times x/y @{..@}} geschrieben) und
Vorschlagnoten (als @code{\grace@{..@}} notiert).

Außerhalb von LilyPond fordert die übliche Benutzung von 
Klammern, dass die entsprechenden Arten korrekt verschachtelt
werden, wie z.B. in @code{<< [ @{ ( .. ) @} ] >>}. Die 
schließenden Klammern kommen dabei in der umgekehrten Reihenfolge
wie die öffnenden Klammern vor. Dies ist auch in LilyPond 
ein @strong{Muss} für die drei Klammerarten, die in obiger 
Tabelle mit dem Wort @q{Umschließt} beschrieben werden -- sie 
müssen korrekt geschachtelt werden.
Die restlichen Klammerarten (durch @q{Markiert} beschrieben),
die Haltebögen und die Triolen brauchen jedoch mit den 
anderen Klammerarten @strong{nicht} unbedingt korrekt 
geschachtelt werden. Tatsächlich sind sie auch keine Klammern
in dem Sinn, dass sie etwas umschließen, sondern viel mehr
Indikatoren, an welcher Stelle ein bestimmtes musikalisches 
Objekt beginnt oder endet.

So kann also z.B. einen Phrasierungsbogen vor einem manuellen 
Balken beginn, jedoch schon vor dem Ende des Balkens enden.
Dies mag zwar musikalisch wenig Sinn ergeben, ist aber in LilyPond
auch möglich:

@lilypond[quote,verbatim,fragment,ragged-right,relative=2]
 { g8\( a b[ c b\) a] }
@end lilypond

Im Allgemeinen können die verschiedenen Klammerarten, Haltebögen,
Triolen und Vorschlagnoten beliebig kombiniert werden.
Das folgende Beispiel zeigt einen Balken, der in eine Triole reicht 
(Zeile 1), eine Bindebogen, der ebenfalls in eine Triole 
reicht (Zeile 2), einen Balken und einen Bindeboden in eine Triole,
ein Haltebogen, der über zwei Triolen läuft, sowie einen 
Phrasierungsbogen, der in einer Triole beginnt (Zeilen 3 und 4).

@lilypond[quote,verbatim,fragment,ragged-right]
{
  r16[ g16 \times 2/3 {r16 e'8] }
  g16( a \times 2/3 {b d) e' }
  g8[( a \times 2/3 {b d') e'~]}
  \times 4/5 {e'32\( a b d' e'} a'4.\)
}
@end lilypond


@node Voices contain music
@section Voices contain music

@untranslated

@menu 
* I'm hearing Voices::
* Explicitly instantiating voices::
* Voices and vocals::
@end menu 
@node I'm hearing Voices
@subsection I'm hearing Voices

@untranslated

@node Explicitly instantiating voices
@subsection Explicitly instantiating voices

@untranslated

@node Voices and vocals
@subsection Voices and vocals

@untranslated

@node Contexts and engravers
@section Contexts and engravers

@untranslated

@menu 
* Contexts explained::
* Creating contexts::
* Engravers explained::
* Modifying context properties::
* Adding and removing engravers::
@end menu

@node Contexts explained
@subsection Contexts explained

@untranslated

@node Creating contexts
@subsection Creating contexts

@untranslated

@node Engravers explained
@subsection Engravers explained

@untranslated

@node Modifying context properties
@subsection Modifying context properties

@untranslated

@node Adding and removing engravers
@subsection Adding and removing engravers

@untranslated

@node Extending the templates
@section Extending the templates

@untranslated

@menu 
* Soprano and cello::
* Four-part SATB vocal score::
* Building a score from scratch::
@end menu

@node Soprano and cello
@subsection Soprano and cello

@untranslated

@node Four-part SATB vocal score
@subsection Four-part SATB vocal score

@untranslated

@node Building a score from scratch
@subsection Building a score from scratch

@untranslated


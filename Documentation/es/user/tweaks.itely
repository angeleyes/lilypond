@c -*- coding: utf-8; mode: texinfo; -*-
@c This file is part of lilypond.tely
@ignore
    Translation of GIT committish: 13290c3922962e4538d3acaf1f7abe14fce6bbff

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  See TRANSLATION for details.
@end ignore

@node Tweaking output
@chapter Tweaking output

Este capítulo trata de cómo modificar la salida.  LilyPond es extremadamente
configurable; prácticamente todos los fragmentos de la salida se pueden cambiar.


@menu
* Tweaking basics::             
* The Internals Reference manual::  
* Moving objects::              
* Fixing overlapping notation::  
* Common tweaks::               
* Default files::               
* Fitting music onto fewer pages::  
* Advanced tweaks with Scheme::  
* Avoiding tweaks with slower processing::  
@end menu

@node Tweaking basics
@section Tweaking basics

@menu
* Introduction to tweaks::      
* Objects and interfaces::      
* Naming conventions of objects and properties::  
* Tweaking methods::            
@end menu

@node Introduction to tweaks
@subsection Introduction to tweaks

El @q{Trucaje} es un término de LilyPond que denota los diversos
métodos que el usuario tiene a su disposición para modificar el
proceso de interpretación del archivo de entrada y cambiar la
apariencia de la salida impresa.  Algunos trucos son muy fáciles de
usar; otros son más complejos.  Pero en su conjunto, los métodos de
trucaje disponibles posibilitan conseguir casi cualquier apariencia
que deseemos en la música impresa.

En esta sección vamos a estudiar los conceptos básicos que se
necesitan para comprender el trucaje.  Más tarde daremos un amplio
abanico de instrucciones listas para usar, que podrá simplemente
copiar para obtener el mismo efecto en sus partituras, y al mismo
tiempo mostraremos la forma de construir dichas instrucciones para que
pueda aprender cómo desarrollar sus propios trucos.

Antes de comenzar con este capítulo, quizá quiera echar un vistazo a
la sección @ref{Contexts and engravers}, pues los Contextos, los
Grabadores y las Propiedades que se contienen en ellos son
fundamentales para comprender y construir los trucos.

@node Objects and interfaces
@subsection Objects and interfaces

@cindex objetos
@cindex grobs
@cindex selectores
@cindex interfaces

El trucaje consiste en modificar el funcionamiento y estructura
interna del programa LilyPond, por lo que en primer lugar
introduciremos algunos términos que se usan para describir dichas
operaciones y estructuras internas.

El término @q{Objeto} es un término genérico que se usa para referirse
a la multitud de estructuras internas que LilyPond construye durante
el procesado de un archivo de entrada.  Así, cuando se encuentra una
instrucción como @code{\new Staff}, se construye un objeto nuevo del
tipo @code{Staff}.  Entonces, este objeto @code{Staff} contiene todas
las propiedades asociadas con ese pentagrama en particular, por
ejemplo, su nombre y su armadura, además de otros detalles de los
grabadores que se han asignado para que operen dentro del contexto del
pentagrama.  De forma similar, hay objetos que guardan las propieades
de todos los demás contextos, como objetos de @code{Voice}, objetos de
@code{Score}, objetos de @code{Lyrics}, así como objetos que
representan todos los elementos notacionales como líneas divisorias,
cabezas de las notas, ligaduras, indicaciones dinámicas, etc.  Cada
objeto tiene su propio conjunto de valores de propiedad.

Ciertos tipos de objetos reciben nombres especiales.  Los objetos que
representan elementos de notación sobre la salida impresa como cabezas
de notas, plicas, ligaduras de expresión y de unión, digitaciones,
claves, etc. reciben el nombre de @q{Objetos de presentación}, a
menudo conocidos como @q{Objetos gráficos}, o abreviadamente
@q{Grobs}.  Aún son objetos en el sentido genérico que hemos
mencionado, y también todos ellos tienen propiedades asociadas, como
su posición, tamaño, color,etc.

Ciertos objetos de presentación son aún más especializados.  Las
ligaduras de fraseo, los reguladores, las indicaciones de octava alta
y baja, y muchos otros objetos gráficos no están situados en un solo
lugar: tienen un punto de inicio, un punto de final, y quizá otras
propiedades relacionadas con su forma.  Los objetos con una forma
extendida como estos, reciben el nombre de «Objetos de extensión» o
@q{Spanners}.

Aún falta por explicar qué son los @q{Interfaces}.  Muchos objetos,
incluso aunque son bastante diferentes, comparten funcionalidades que
se deben procesar de la misma manera.  Por ejemplo, todos los objetos
gráficos tienen un color, un tamaño, una posición, etc., y todas estas
propiedades se procesan de la misma forma durante la interpretación
del archivo de entrada por parte de LilyPond.  Para simplificar estas
operaciones internas, estas acciones t propiedades comunes se agrupan
en un objeto llamado @code{grob-interface}, interface de grob.  Hay
muchas otras agrupaciones de propiedades comunes como ésta, y cada
unoa recibe un nombre que acaba en @code{interface}.  En total hay más
de 100 interfaces de éstos.  Veremos más adelante porqué esto es del
interés y de utilidad para el usuario.

Estos son, en fin, los términos principales relativos a los objetos
que vamos a utilizar en este capítulo.

@node Naming conventions of objects and properties
@subsection Naming conventions of objects and properties

Ya hemos visto ciertas convenciones de nomenclatura de objetos, en la
sección @ref{Contexts and engravers}.  En este lugar, para más fácil
referencia, presentamos una lista de los tipos de objetos y
propiedades más comunes, junto con las convenciones según las cuales
reciben su nombre, y un par de ejemplos de nombres reales.  Hemos
utilizado una «A» mayúscula para denotar cualquier carácter alfabético
en mayúsculas, y «aaa» para cualquier número de caracteres alfabéticos
en minúscula.  Otros caracteres se utilizan literalmente como están.

@multitable @columnfractions .33 .33 .33
@headitem Objeto o tipo de propiedad
  @tab Convención de nomenclatura
  @tab Ejemplo
@item Contextos
  @tab Aaaa o AaaaAaaaAaaa
  @tab Staff, GrandStaff
@item Objetos de presentación
  @tab Aaaa o AaaaAaaaAaaa
  @tab Slur, NoteHead
@item Grabadores
  @tab Aaaa_aaa_engraver
  @tab Clef_engraver, Note_heads_engraver
@item Interfaces
  @tab aaa-aaa-interface
  @tab grob-interface, break-aligned-interface 
@item Propiedades de contextos
  @tab aaa o aaaAaaaAaaa
  @tab alignAboveContext, skipBars
@item Propiedades de objetos de presentación
  @tab aaa o aaa-aaa-aaa
  @tab direction, beam-thickness
@end multitable

Como podremos ver en breve, las propiedades de distintos tipos de
objeto se modifican por parte de diferentes instrucciones; así pues,
es útil poder reconocer el tipo de objeto a partir de sus nombres de
propiedad.

@node Tweaking methods
@subsection Tweaking methods

@strong{La instrucción \override}

@cindex override, instrucción
@funindex \override

Ya hemos visto las instrucciones @code{\set} y @code{\with}, que se
usan para cambiar las propiedades de los @strong{contextos} y para
quitar y poner @strong{grabadores}, en @ref{Modifying context
properties} y @ref{Adding and removing engravers}.  Ahora debemos
examinar algunas instrucciones importantes más.

La instrucción que cambia las propiedades de los @strong{objetos de
presentación} es @code{\override}.  Puesto que esta instrucción debe
modificar propiedades internas que se encuentran en un lugar profundo
dentro de LilyPond, su sintaxis no es tan simple como la del resto de
las instrucciones que hemos visto hasta ahora.  Tiene que saber
exactamente qué propiedad de qué objeto y en qué contexto se debe
modificar, y cuál debe ser su nuevo valor.  Veamos cómo se hace.

La sintaxis genérica de esta instrucción es:

@example
\override @emph{contexto}.@emph{objeto_de_presentación} 
  #'@emph{propiedad_de_presentación} = #@emph{valor}
@end example

@noindent
Esto establecerá la propiedad de nombre
@emph{propiedad_de_presentación} del objeto de presentación con el
nombre @emph{objeto_de_presentación}, que es miembro del contexto
@emph{contexto}, al valor @emph{valor}.

El @emph{contexto} se puede omitir (y normalmente así es) cuando el
contexto requerido se encuentra implicado sin ambigüedad y es uno de
los contextos del nivel más bajo, es decir: @code{Voice},
@code{ChordNames} o @code{Lyrics}, y lo omitiremos en muchos de los
ejemplos siguientes.  Veremos más tarde cuándo se debe especificar.

Las últimas secciones tratan de forma exhaustiva las propiedades y sus
valores, pero para ilustrar el formato y utilización de estas
iinstrucciones usaremos sólo unas cuantas propiedades y valores
sencillos que sean fáciles de entender.

Por ahora no se preocupe por el @code{#'}, que debe anteponerse a la
propiedad de presentación, y el @code{#}, que debe preceder al valor.
Deben estar presentes siempre y de esa forma exacta.  Es la
instrucción de uso más común dentro del trucaje, y durante la mayor
parte del resto de este capítulo presentaremos ejemplos de cómo se
usa.  A continuación hay un ejemplo sencillo para cambiar el color de
una cabeza:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a b c
@end lilypond

@strong{La instrucción \revert}

@cindex revert, instrucción
@funindex \revert

Una vez sobreescrita, la proopiedad retiene su nuevo valor hasta que
se sobreescribe de nuevo o se encuentra una instrucción
@code{\revert}.  La instrucción @code{\revert} tiene la siguiente
sintaxis y ocasiona que el valor de la propiedad se devuelva a su
valor predeterminado original; observe que no es a su valor previo si
se han utilizado varias instrucciones @code{\override}.

@example
\revert @emph{contexto}.@emph{objeto_de_presentación} #'@emph{propiedad_de_presentación}
@end example

Una vez más, igual que @emph{contexto} dentro de la instrucción
@code{\override}, con frecuencia no es necesario especificar el
@emph{contexto}.  Se omitirá en muchos de los ejemplos siguientes.
Aquí devolvemos el color de la cabeza al valor predeterminado para las
dos últimas notas:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a
\revert NoteHead #'color
b c
@end lilypond

@strong{El prefijo \once}

Tanto la instrucción @code{\override} como @code{\set} se pueden
preceder por @code{\once}.  Esto ocasiona que la siguiente instrucción
@code{\override} o @code{\set} sea efectiva solamente durante el
tiempo musical en curso y antes de que la propiedad vuelva a tener
otra vez su valor predeterminado.  Utilizando el mismo ejemplo,
podemos cambiar el color de una sola nota de la siguiente manera:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\once \override NoteHead #'color = #red
e f g
\once \override NoteHead #'color = #green
a b c
@end lilypond

@strong{La instrucción \overrideProperty}

@cindex overrideProperty, instrucción
@funindex \overrideProperty

Hay otra forma para la instrucción de sobreescritura,
@code{\overrideProperty}, que ocasionalmente es necesaria.  La
mencionamos aquí con un propósito de exhaustividad, pero para ver más
detalles consulte @ruser{Difficult tweaks}.
@c Maybe explain in a later iteration  -td

@strong{La instrucción \tweak}

@cindex tweak, instrucción
@funindex \tweak

La última instrucción de trucaje que está disponible es @code{\tweak}.
Se debe utilizar para cambiar las propiedades de objetos que suceden
en el mismo momento musical, como las notas de un acorde.  El uso de
@code{\override} para la sobreescritura afectaría a todas las notas
del acorde, mientras que @code{\tweak} afecta solamente al siguiente
elemento del flujo de entrada.

He aquí un ejemplo.  Suponga que queremos cambiar el tamaño de la nota
intermedia (el Mi) en un acorde de Do mayor.  En primer lugar, veamos
lo que haría @code{\once \override}:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  \once \override NoteHead #'font-size = #-3
  <c e g>
  <c e g>
@end lilypond

Vemos que la sobreescritura con override afecta a @emph{todas} las
notas del acorde.  Esto es así porque todas las notas de un acorde
ocurren en el mismo @emph{momento musical}, y la acción de
@code{\once} es aplicar la sobreescritura a todos los oobjetos de
presentación del tipo especificado que ocurren en el mismo momento
musical que la propia instrucción de sobreescritura @code{\override}.

LA instrucción @code{\tweak} opera de una forma distinta.  Actúa sobre
el elemento inmediatamente siguiente dentro del flujjo de entrada.
Sin embargo, es efectivo solamente sobre objetos que se crean
directamente a partir del flujo de entrada, en esencia las cabezas y
las articulaciones (los objetos como las plicas y las alteraciones se
crean con posterioridad y no se pueden trucar de esta forma).  Es más,
cuando se aplica a las cabezas de las notas, éstas @emph{deben} estar
dentro de un acorde, es decir, dentro de ángulos simples, así que para
trucar una sola nota la instrucción @code{\tweak} se debe colocar
dentro de ángulos simples junto con la nota.

Así pues, volviendo a nuestro ejemplo, el tamaño de la nota intermedia
se cambiaría de la siguiente forma:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  <c \tweak #'font-size #-3 e g>4
@end lilypond

Observe que la sintaxis de @code{\tweak} es diferente de la de la
instrucción @code{\override}.  Ni el contexto ni el objeto de
presentación se deben especificar; de hecho, generaría un error
hacerlo.  Los dos están implícitos por el siguiente elemento del flujo
de entrada.  Así que la sintaxis genérica de la instrucción
@code{\tweak} es, simmplemente:

@example
\tweak #'@emph{propiedad_de_presentación} = #@emph{valor}
@end example

Una instrucción @code{\tweak} también se puede usar para modificar
sólo una de una serie de articulaciones, como se muestra aquí:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
a ^Black
  -\tweak #'color #red ^Red
  -\tweak #'color #green _Green
@end lilypond

Observe que la instrucción @code{\tweak} debe venir precedida de una
marca de articulación como si ella misma fuera una articulación.

@cindex grupos especiales anidados
@cindex tresillos anidados
@cindex corchete del grupo especial
@cindex grupo especial, corchete de
@cindex tresillo, corchete de
@funindex TupletBracket

La instrucción @code{\tweak} también se debe usar para cambiar la
apariencia de uno solo de un conjunto de grupos especiales anidados
que comiencen en el mismo instante musical.  En el siguiente ejemplo,
el corchete del tresillo largo y el primero de los tres corchetes
cortos empiezan en el mismo momento musical, y por ello cualquier
instrucción @code{\override} se aplicaría a los dos.  En el ejemplo se
usa @code{\tweak} para distinguir entre ellos.  La primera instrucción
@code{\tweak} especifica que el corchete del tresillo largo se debe
colocar por encima de las notas y el segundo especifica que el número
del tresillo se debe imprimir en rojo sobre el corchete del primer
tresillo corto.

@lilypond[quote,ragged-right,verbatim,fragment,relative=2]
\tweak #'direction #up
\times 4/3 {
  \tweak #'color #red
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
}
@end lilypond

Encontrará más detalles de la instrucción @code{\tweak} en
@ruser{Objects connected to the input}.

Si los grupos anidados no comienzan en el mismo momento, su apariencia
se puede modificar de la forma usual mediante instrucciones
@code{\override}:

@c NOTE Tuplet brackets collide if notes are high on staff
@c See issue 509
@lilypond[quote,ragged-right,verbatim,fragment,relative=1]
\times 2/3 { c8[ c c]}
\once \override TupletNumber 
  #'text = #tuplet-number::calc-fraction-text
\times 2/3 {
  c[ c]
  c[ c]
  \once \override TupletNumber #'transparent = ##t
  \times 2/3 { c8[ c c] }
\times 2/3 { c8[ c c]}
}
@end lilypond

@node The Internals Reference manual
@section The Internals Reference manual

@cindex Internals Reference

@menu
* Properties of layout objects::  
* Properties found in interfaces::  
* Types of properties::         
@end menu

@node Properties of layout objects
@subsection Properties of layout objects

@cindex propiedades de los objetos de presentación
@cindex propiedades de los grobs
@cindex grobs, propiedades de
@cindex presentación, propiedades de los objetos de

Suponga que tiene una partitura con una ligadura de expresión que para
su gusto es demasiado fina y quiere trazarla un poco más gruesa. ¿Cómo
debe proceder?  Ya sabe, por las afirmaciones anteriores acerca de la
flexibilidad de LilyPond, que tal posibilidad existe, y seguramente
piensa que una cierta instrucción de sobreescritura @code{\override}
será necesaria.  Pero ¿existe una propiedad de grosor para las
ligaduras? y, si la hay, ¿cómo se puede modificar?  Aquí es donde
interviene el Manual de Funcionamiento Interno.  Contiene toda la
información que puede necesitar para construir ésta y todas las demás
instrucciones @code{\override}, de sobreescritura.

Una advertencia antes de dirigir nuestra mirada a la referencia de
funcionamiento interno.  Éste es un documento de @strong{referencia},
lo que significa que hay pocas o ninguna explicación en él: su
propósito es presentar la información de forma precisa y concisa.  Por
tanto, podrá parecerle desalentador a primera vista.  ¡No se preocupe!
La guía y las explicaciones que presentamos aquí le permitirán extraer
la información de la referencia de funcionamiento interno por sí mismo
con tan sólo algo de práctica.

@cindex sobreescritura, ejemplo de
@cindex Referencia de Funcionamiento Interno, ejemplo de utilización

Utilicemos un ejemplo concreto con un sencillo fragmento de música
real:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g | 
    g[( e]) e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

Suponga ahora que decidimos que nos gustan las ligaduras algo más
gruesas.  ¿Es posible?  La ligadura es, ciertamente, un objeto de
presentación, así que la cuestión es @q{¿Hay una propiedad
perteneciente a las ligaduras de expresión que controle su grosor?}
Para responder a esta pregunta debemos mirar el manual de Referencia
de Funcionamiento Interno, abreviadamente RFI@footnote{@strong{IR}
(Internals Reference) en inglés}.

El RFI de la versión de LilyPond que está usando se puede encontrar en
la página web de LilyPond en @uref{http://lilypond.org}.  Vaya a la
página de la documentación y siga el enlace Manual de Referencia de
Funcionamiento Interno (RFI).  Para nuestros propósitos pedagógicos
sería mejor que utilizase la versión html, no la @q{en una sola
página} ni el PDF.  Para que los siguientes párrafos tengan algún
sentido deberá consultarlo realmente al tiempo que lee.

@c Link names in English as these pages are not yet translated
Bajo el encabezamiento @strong{Top} podrá ver cinco enlaces.
Seleccione el enlace @emph{Backend}, que es donde se encuentra la
información sobre los objetos de presentación.  Una vez allí, bajo el
encabezamiento @strong{Backend}, siga el enlace @emph{All layout
objects}.  La página que aparece relaciona todos los objetos de
presentación que se usan en su versión de LilyPond, en orden
alfabético.  Siga el enlace Slur (ligadura de expresión), y aparecerán
relacionadas las propiedades de las ligaduras de expresión o Slurs.

(Una forma alternativa de encontrar esta página es a partir de la
Referencia de la Notación.  En una de las páginas que tratan de las
ligaduras de expresión podrá encontrar un enlace al manual de
referencia del funcioonamiento interno.  Este enlace le llevará
directamente a esta página, aunque con frecuencia es más fácil ir
directamente al RFI y buscar allí.)

Esta página sobre las ligaduras de expresión dentro del manual RFI nos
dice en primer lugar que los objetos Slur se crean por el grabador
Slur_engraver.  A continuación relaciona los ajustes estándar.
Observe que @strong{no} están en orden alfabético.  Navegue hacia
abajo buscando una propiedad que pudiera controlar el grosor de las
ligaduras, y encontrará

@example
@code{thickness} (number)
     @code{1.2}
     Line thickness, generally measured in @code{line-thickness}
@end example

Esto promete ser una buena opción para cambiar el grosor.  Nos dice
que el valor de @code{thickness} es un simple @emph{número}, que el
valor predeterminado es 1.2, y que las unidades están dentro de otra
propiedad llamada @code{line-thickness}.

Como dijimos con anterioridad, existen entre pocas y ninguna
explicación en el RFI, pero ya tenemos información suficiente para
probar a cambiar el grosor de la ligadura.  Vemos que el nombre del
objeto de presentación es @code{Slur}, que el nombre de la propiedad
que debemos cambiar es @code{thickness} y que el nuevo valor debe ser
un número algo más grande que 1.2 si queremos hacer las ligaduras más
gruesas.

Ahora podemos construir la instrucción de sobreescritura
@code{\override} simplemente mediante la sustitución de los valores
que hemos encontrado para los nombres, omitiendo el contexto.
Usaremos un valor muy grande para el grosor al principio, para estar
seguros de que la instrucción está funcionando.  Obtenemos lo
siguiente:

@example
\override Slur #'thickness = #5.0
@end example 

¡No olvide el @code{#'} antes del nombre de la propiedad y @code{#}
antes del valor nuevo!

La pregunta final es @q{¿Dónde se debe colocar esta instrucción?}
Aunque nos falta seguridad y estamos todavía aprendiendo, la mejor
respuesta es: @q{Dentro de la música, antes de la primera ligadura y
cerca de ella.}  Hagámoslo así:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
y podemos ver que la ligadura, es sin duda, más pesada.

Así pues, ésta es la forma básica de construir instrucciones
@code{\override} o de sobreescritura.  Existen unas cuantas
complicaciones más con las que nos encontraremos en secciones
posteriores, pero ahora conoce todos los principios esenciales que
necesita para hacerlo por sí mismo (aunque aún necesita algo de
práctica).  La cual vendrá proporcionada por los ejemplos que vienen a
continuación.

@subheading Finding the context
@cindex contexto, encontrar

Pero en primer lugar ¿qué habría pasado si hubiésemos tenido que
especificar el contexto? ¿Cuál sería?  Podemos suponer que las
ligaduras están en el contexto de Voz, por estar claramente asociados
de manera estrecha con las líneas individuales de música, pero
¿podemos estar seguros?  Para averiguarlo, vayamos de nuevo al inicio
de la página del RFI que describe las ligaduras (Slur), donde dice
@q{Slur objects are created by: Slur engraver} («Los objetos de
ligadura de expresión se crean por: el grabador Slur»).  Así pues, las
ligaduras de expresión se crean en cualquier contexto en el que se
encuentre el grabador @code{Slur_engraver}.  Siga el enlace a la
página del grabador @code{Slur_engraver}.  Al final del todo, dice que
el grabador @code{Slur_engraver} es parte de cinco contextos de voz,
incluido el contexto de voz estándar, @code{Voice}, por lo que nuestra
suposición era acertada.  Y a causa de que @code{Voice} es uno de los
contextos de más bajo nivel que se encuentra implícito sin ambigüedad
por el hecho de que estamos escribiendo notas, podemos omitirlo en
este lugar concreto.

@subheading Overriding once only

@cindex sobreescritura por una sola vez
@cindex once override
@funindex \once

Como puede ver, @emph{todas} las ligaduras son más gruesas en el
último ejemplo.  Pero ¿y si quisiéramos que solamente la primera
ligadura fuese más gruesa?  Esto se consigue con la instrucción o
prefijo @code{\once}.  Colocado inmediatamente antes de la instrucción
@code{\override} ocasiona que solamente cambie la ligadura que
comienza en la nota @strong{inmediata siguiente}.  Si la nota
inmediata siguiente no da inicio a una ligadura, la instrucción no
tiene niingún efecto en absoluto: no se recuerda hasta que se
encuentre alguna ligadura, sino que simplemente se ignora.  Así pues,
la instrucción que lleva @code{\once} se debe reposicionar de la forma
siguiente:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g | 
    g[( e]) e d[( f]) a | 
    a g 
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
Hemos hecho que ahora solamente la primera ligadura sea más gruesa.

La instrucción o prefijo @code{\once} también se puede usar antes de
la instrucción @code{\set}.

@subheading Reverting

@cindex revert
@cindex predeterminadas, devolver a las propiedades
@funindex \revert

Finalmente ¿y si quisiéramos que solamente las dos primeras ligaduras
fuesen más gruesas?  En fin; podríamos usar dos instrucciones, cada
una de ellas precedida por el prefijo @code{\once}, situadas
inmediatamente antes de cada una de las notas en que comienzan las
ligaduras:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    g[( e]) e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
o podríamos omitir la instrucción prefija @code{\once} y utilizar la
instrucción @code{\revert} (restablecer) para devolver la propiedad
del grosor, @code{thickness}, a su valor predeterminado después de la
segunda ligadura:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e]) 
    % Revert thickness of all following slurs to default of 1.2
    \revert Slur #'thickness
    e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond

@noindent
la instrucción @code{\revert} se puede utilizar para devolver
cualquier propiedad que se haya cambiado con @code{\override} a su
valor predeterminado.  Puede utilizar el método que mejor se adapte a
aquello que quere hacer.

Así finaliza nuestra introducción al manual de RFI, y el método básico
de trucaje.  A continuación, en las últimas secciones de este capítulo
encontrará varios ejemplos, en parte para introducirle en algunas de
las posibilidades adicionales del manual RFI, y en parte para
proporcionarle más práctica en cómo extraer información de él.  Estos
ejemplos irán conteniendo cada vez menos palabras de guía y
explicación.

@node Properties found in interfaces
@subsection Properties found in interfaces

@cindex propiedades de los interfaces
@cindex interfaces, propiedades

Suponga ahora que queremos imprimir la letra de la canción en cursiva.
¿Qué forma de instrucción @code{\override} necesitamos para hacerlo?
En primer lugar miramos en la página del RFI que relaciona todos los
objetos, @q{All layout objects}, como antes, y buscamos un objeto que
pueda conteolar la letra de la canción.  Encontramos @code{LyricText},
que parece adecuado.  Al seguir este enlace se presentan las
propiedades ajustables para el texto de la letra.  Estos incluyen
@code{font-series} y @code{font-size}, pero nada que pudiera aplicar
una forma cursiva.  Esto es porque la propiedad de la forma es común a
todos los objetos de fuente tipográfica, y por tanto, en vez de
incluirlo en cada uno de los objetos de preesentación, se agrupa junto
con otras propiedades comunes similares y se deposita en un
@strong{Interface}, el interface de las fuentes tipográficas
@code{font-interface}.

Por tanto, ahora necesitamos aprender cómo encontrar las propiedades
de los interfaces, y descubrir qué objetos usan estas propiedades de
interface.

Mire de nuevo la página del RFI que decribe a LyricText.  Al final de
la página hay una lista de enlaces (en las versiones de html del RFI)
a los interfaces que LyricText contempla.  La lista tiene siete
elementos, entre ellos @code{font-interface}.  Al seguir este enlace
llegamos a las propiedades asociadas con este interface, que también
son propiedades de todos los objetos que lo llevan, entre ellos
LyricText.

Ahora vemos todas las propiedades ajustables por el usuario que
controlan las tipografías, entre ellas @code{font-shape(symbol)},
donde @code{symbol} se puede establecer a @code{upright} (recta),
@code{italics} (cursiva)o @code{caps} (mayúsculas pequeñas).

Observará que @code{font-series} y @code{font-size} también se
encuentran aquí relacionadas.  Esto inmediatamente hace que surja la
pregunta: ¿Por qué están las propiedades comunes de tipografía
@code{font-series} y @code{font-size} relacionadas bajo
@code{LyricText} así como bajo el interface @code{font-interface} pero
@code{font-shape} no lo está?  La respuesta es que @code{font-series}
y @code{font-size} se cambian a partir de sus valores predeterminados
globales cuando se crea un objeto @code{LyricText}, pero
@code{font-shape} no lo hace.  Entonces los elementos de la lista
@code{LyricText} le dicen los valores para esas dos propiedades que
son de aplicación para @code{LyricText}.  Otros objetos que contemplan
@code{font-interface} establecerán dichas propiedades de forma
diferente cuando se crean.

Veamos si ahora podemos construir la instrucción @code{\override} para
cambiar la letra a cursiva.  El objeto es @code{LyricText}, la
propiedad es @code{font-shape} y el valor es @code{italic}.  Igual que
antes, omitiremos el contexto.

Como nota aparte, aunque una nota importante, observe que a causa de
que los valores de @code{font-shape} son símbolos, deben ir precedidos
de un apóstrofe, @code{'}.  Esa es la razón por la que se necesitan
apóstrofes antes de @code{thickness} en el ejemplo anterior y en
@code{font-shape}.  Los dos son también símbolos.  Los símbolos son
nombres especiales que son conocidos por LilyPond internamente.
Algunos de ellos son nombres de propiedades, como @code{thickness} o
@code{font-shape}, otros son en efecto valores especiales que se les
puede dar a las propiedades, como @code{italic}.  Observe la
distincion entre esto y las cadenas de texto arbitrarias, que
aparecerían entrecomilladas como @code{"a text string"}.

De acuerdo, entonces la instrucción @code{\override} que necesitamos
para imprimir la letra en cursiva sería

@example
\override LyricText #'font-shape = #'italic
@end example

@noindent
y debe colocarse justo delante de, y cerca de, la letra a la que debe
afectar, como esto:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    \override LyricText #'font-shape = #'italic
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond

@noindent
y toda la letra se imprime en cursiva.

@subheading Specifying the context in lyric mode
@cindex contexto, especificación en modo letra

En el caso de la letra, si intenta especificar el contexto en el
formato que acabamnos de dar, la instrucción no funcionará.  Una
sílaba escrita en el modo letra, «lyricmode» temina en un espacio, un
salto de línea o un dígito.  Cualquier otro carácter se incluye como
parte de la sílaba.  Por esta razón, un espacio o salto de línea debe
aparecer antes del último símbolo @code{@}} para evitar que se incluya
como parte de la sílaba final.  De forma similar, se deben insertar
espacios antes y después del punto, @q{.}, separando el nombre del
contexto del nombre del objeto, pues en caso contrario los dos nombres
se juntarán y el intérprete no podrá reconocerlos.  Así pues, la
instrucción será:

@example
\override Lyrics . LyricText #'font-shape = #'italic
@end example

@warning{Dentro de la letra, deje siempre espacios entre la sílaba
final y la llave de cierre.}

@warning{En las sobreescrituras con override dentro de la letra,
escriba siempre espacios antes y después del punto que separa el
nombre del contexto y el nombre del objeto.}

@node Types of properties
@subsection Types of properties

@cindex propiedades, tipos de

Hasta ahora hemos visto dos tipos de propiedad:: @code{número} y
@code{símbolo}.  Para que sea válido, el valor que se da a una
propiedad debe ser del tipo correcto y obedecer las reglas de dicho
tipo.  El tipo de la propiedad se muestra siempre entre paréntesis
después del nombre de la propiedad en el RFI.  He aquí una lista de
los tipos que podrá necesitar, junto con las reglas de dicho tipo, y
algunos ejemplos.  Debe escribir siempre un símbolo de almohadilla,
@code{#}, por supuesto, delante de estos valores cuando se introducen
en la instrucción @code{\override}.

@multitable @columnfractions .2 .45 .35
@headitem Tipo de propiedad
  @tab Reglas
  @tab Ejemplos
@item Booleano
  @tab Verdadero o Falso, representado por #t o #f
  @tab @code{#t}, @code{#f}
@item Dimensión (en espacios de pentagrama)
  @tab Un número decimal positivo (en unidades de espacios de pentagrama)
  @tab @code{2.5}, @code{0.34}
@item Dirección
  @tab Una constante válida de dirección o su equivalente numérico
  @tab @code{#LEFT}, @code{#CENTER}, @code{#UP},
       @code{1}, @code{-1}
@item Entero
  @tab Un número entero positivo
  @tab @code{3}, @code{1}
@item Lista
  @tab Un conjunto de elementos entre paréntesis separados por espacios y precedido de un apóstrofe
  @tab @code{'(left-edge staff-bar)}, @code{'(1)},
       @code{'(1.0 0.25 0.5)}
@item Marcado
  @tab Cualquier elemento válido de marcado de texto
  @tab @code{\markup @{ \italic "cresc." @}}
@item Momento
  @tab Una fracción de redonda construida con la función make-moment
  @tab @code{(ly:make-moment 1 4)},
       @code{(ly:make-moment 3 8)}
@item Número
  @tab Cualquier valor decimal positivo o negativo
  @tab @code{3.5}, @code{-2.45}
@item Pareja (de números)
  @tab Dos números separados por un @q{espacio . espacio}, encerrado entre paréntesis y precedido de un apóstrofe
  @tab @code{'(2 . 3.5)}, @code{'(0.1 . -3.2)}
@item Símbolo
  @tab Cualquiera del conjunto de símbolos premitidos para esa propiedad, precedido de un apóstrofe
  @tab @code{'italic}, @code{'inside}
@item Desconocido
  @tab Un procedimiento o @code{#f} (para no producir ninguna acción)
  @tab @code{bend::print}, @code{ly:text-interface::print},
       @code{#f}
@item Vector
  @tab Una lista de tres elementos encerrados entre paréntesis y precedida de una almohadilla, @code{#}.
  @tab @code{#(#t #t #f)}
@end multitable


@node Moving objects
@section Moving objects

Aunque pueda sorprenderle, LilyPond no es perfecto.  Ciertos
elementos de notación se pueden superponer, lo que es una lástima,
pero en casi todos los casos se resuelve fácilmente.

@c  FIXME: find a better example for 5.1 Moving Objects.  -gp
@c  yes, I want this TODO to be visible to end-users.  It's better
@c  than having nothing at all.
HACER: con las nuevas funcionalidades de espaciado en la versión 2.12, estos ejemplos específicos
ya no son de relevancia.  Sin embargo siguen demostrando las poderosas funcionalidades de lilypond,
así que quedan aquí hasta que alguien elabore unos ejemplos mejores.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
e4^\markup{ \italic ritenuto } g b e
@end lilypond

@cindex padding

La solución más fácil es aumentar la distancia entre el objeto
(texto en este caso, pero muy bien podrían ser digitaciones o dinámicas)
y la nota.  En LilyPond, esto se llama la propiedad
@code{padding} (relleno); se mide en espacios de pentagrama.  Para la mayor
parte de los objetos, este valor ronda la cantidad de 1.0 o menos (varía dependiendo del
objeto). Queremos aumentarlo, así que probaremos el valor 1.5

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'padding = #1.5
e4^\markup{ \italic ritenuto } g b e
@end lilypond

Esto tiene un mejor aspecto, pero no es suficiente.  Después de probar
con algunos valores, creemos que 2.3 es el mejor número en este caso. Sin embargo
esta cantidad es el mero resultado del ensayo y error y de mi gusto personal
acerca de la notación.  Pruebe el ejemplo anterior con 2.3... pero también con otros valores 
mayores (y menores).  ¿Cuál cree que queda mejor?

La propiedad @code{staff-padding} (relleno de pentagrama) está estrechamente relacionada.
@code{padding} controla la cantidad de espacio mínima entre un objeto y el objeto más cercano
(generalmente la nota o las líneas del pentagrama);
@code{staff-padding} controla la cantidad mínima de espacio entre un
objeto y el pentagrama.  Ello supone una sutil diferencia, pero podrá 
observar el comportamiento a continuación.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
c4^"piu mosso" b a b
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
\once \override TextScript #'staff-padding = #4.6
c4^"piu mosso" fis a g
\break
c'4^"piu mosso" b a b
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
\once \override TextScript #'staff-padding = #4.6
c4^"piu mosso" fis a g
@end lilypond

@cindex desplazamiento adicional

Otra solución nos proporciona un control absoluto sobre la situación del objeto: podemos
moverlo horizontal o verticalmente.  Se hace con la propiedad
@code{extra-offset} (desplazamiento adicional).  Es ligeramente más complicado y puede
causar otros problemas.  Cuando movemos objetos con @code{extra-offset},
el movimiento se hace después de que LilyPond haya colocado todos los demás objetos.
Esto significa
que el resultado podría entrar en conflicto con otros objetos.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'extra-offset = #'( 1.0 . -1.0 )
e4^\markup{ \italic ritenuto } g b e
@end lilypond

Con @code{extra-offset}, el primer número controla el movimiento
horizontal (negativo hacia la izquierda); el segundo número controla el movimiento
vertical (positivo hacia arriba).  Después de algunos ensayos, hemos decidido que los siguientes valores
son apropiados

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'extra-offset = #'( -1.6 . 1.0 )
e4^\markup{ \italic ritenuto } g b e
@end lilypond

@noindent
Una vez más, estos números son simplemente el resultado de algunos experimentos y
de observar la salida.  Quizá prefiera que el texto se encuentre algo más arriba,
o a la izquierda, o en cualquier dirección.  ¡Pruébelo y observe el resultado!

Una advertencia final: en esta sección hemos usado

@example
\once \override TextScript @dots{}
@end example

Esto altera la presentación del texto para la nota siguiente.  Si la nota no
tiene ningún texto, este truco no hace nada (y @strong{no} se queda esperando al
siguiente fragmento de texto).  Para cambiar el comportamiento permanentemente a partir
del comando, omita el @code{\once}.  Para detener este truco, use
@code{\revert} (revertir).  Todo esto se explica en profundidad en
@ruser{The \override command}.

@lilypond[quote,fragment,ragged-right,verbatim,relative=3]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
c4^"piu mosso" b
\once \override TextScript #'padding = #4.6
  a4 b
c4^"piu mosso" d e f
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
c4^"piu mosso" d e f
\break
\override TextScript #'padding = #4.6
c4^"piu mosso" d e f
c4^"piu mosso" d e f
\revert TextScript #'padding
c4^"piu mosso" d e f
@end lilypond

@seealso

En el presente manual: @ruser{The \override command}, @ruser{Common tweaks}.


@node Fixing overlapping notation
@section Fixing overlapping notation

En @ruser{Moving objects}, pudimos ver cómo mover un objeto @code{TextScript}.
El mismo mecanismo se puede usar para mover otros tipos de
objetos; simplemente sustituya @code{TextScript} con el nombre de
otro objeto.

Para encontrar el nombre del objeto, consulte la sección @q{@strong{véase también}} al
final de la página relevante dentro de la documentación.  Por ejemplo, al
final de @ruser{Dynamics}, vemos

@quotation
@seealso

Referencia del programa: @internalsref{DynamicText}, @internalsref{Hairpin}.
La posición vertical de estos símbolos se maneja por medio de
@internalsref{DynamicLineSpanner}.
@end quotation

@noindent
Así que para mover expresiones dinámicas verticalmente, usamos

@example
\override DynamicLineSpanner #'padding = #2.0
@end example

No podemos listar todos y cada uno de los objetos, pero presentamos a continuación una lista
de los objetos más comunes.

@multitable @columnfractions .33 .66
@headitem Tipo de objeto                        @tab Nombre del objeto
@item Expresiones dinámicas (verticalmente)     @tab @code{DynamicLineSpanner}
@item Expresiones dinámicas (horizontalmente)   @tab @code{DynamicText}
@item Ligaduras de unión                        @tab @code{Tie}
@item Ligaduras de expresión                    @tab @code{Slur}
@item Articulaciones                            @tab @code{Script}
@item Digitaciones                              @tab @code{Fingering}
@item Texto, p.ej. @code{^"text"}               @tab @code{TextScript}
@item Llamadas de ensayo o marcas de texto      @tab @code{RehearsalMark}
@end multitable


@node Common tweaks
@section Common tweaks

Algunas sustituciones son tan comunes que se proporcionan comandos preestablecidos
como atajos, como @code{\slurUp} (ligadura hacia arriba) y @code{\stemDown} (plica hacia abajo).  Estos
comandos se describen dentro de la Referencia de Notación bajo las secciones
correspondientes.

La lista completa de modificaciones disponibles para cada tipo de
objeto (como ligaduras o barras de corchea) están documentadas en la Referencia del
Programa.  Sin embargo, muchos objetos de la presentación comparten propiedades que se pueden
usar para aplicar trucos genéricos.

@itemize @bullet

@cindex relleno

@item
La propiedad @code{padding} (relleno) se puede establecer de forma que incremente
(o disminuya) la distancia entre símbolos que se imprimen encima
o debajo de las notas.  Se aplica a todos los objetos con
@code{side-position-interface}.

@lilypond[quote,fragment,relative=1,verbatim]
c2\fermata
\override Script #'padding = #3
b2\fermata
@end lilypond

@lilypond[quote,fragment,relative=1,verbatim]
% This will not work, see below:
\override MetronomeMark #'padding = #3
\tempo 4=120
c1
% This works:
\override Score.MetronomeMark #'padding = #3
\tempo 4=80
d1
@end lilypond

Observe en el segundo ejemplo cuán importante es determinar qué contexto
maneja un objeto determinado.  Debido a que el objeto @code{MetronomeMark} (indicación metronómica)
se maneja en el contexto @code{Score}, los cambios de propiedades dentro del
contexto @code{Voice} no se tendrán en cuenta.  Para ver más detalles, consulte
@ruser{Constructing a tweak}.

@cindex extra-offset (desplazamiento adicional)

@item
La propiedad @code{extra-offset} mueve objetos en la salida;
requiere una pareja de números.  El primer número
controla el movimiento horizontal, un número positivo moverá
el objeto hacia la derecha.  El segundo número controla el movimiento
vertical; un número positivo lo desplazará hacia arriba.  La
propiedad @code{extra-offset} es una funcionalidad de bajo nivel: el motor
de formateo es completamente olvidadizo respecto de estos desplazamientos.

En el ejemplo siguiente, la segunda digitación se desplaza un poco hacia
la izquierda y 1.8 espacios de pentagrama hacia abajo:

@lilypond[quote,fragment,relative=1,verbatim]
\stemUp
f-5
\once \override Fingering
    #'extra-offset = #'(-0.3 . -1.8)
f-5
@end lilypond

@item
El establecimiento de la propiedad @code{transparent} provocará que un objeto se imprima
con @q{tinta invisible}: el objeto no se imprime, pero se conserva todo el resto
de su comportamiento.  El objeto aún ocupa un espacio, toma parte en las colisiones,
y se le pueden adjuntar ligaduras de unión o de expresión y barras de corchea.

@cindex objetos transparentes
@cindex quitar objetos
@cindex ocultar objetos
@cindex objetos invisibles
El ejemplo siguiente demuestra cómo conectar distintas voces
utilizando ligaduras.  Normalmente las ligaduras sólo unen dos notas de la misma voz.
Al introducir una ligadura en una voz distinta,

@lilypond[quote,fragment,relative=2]
<< {
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

@noindent
y suprimiendo la primera plica hacia arriba en dicha voz, la ligadura parece cruzarse de una
voz a otra:


@lilypond[quote,fragment,relative=2,verbatim]
<< {
  \once \override Stem #'transparent = ##t
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

Para asegurarse de que la plica que hemos suprimido no aprieta demasiado a la
ligadura, también alargamos la plica, estableciendo su @code{length} (longitud) a
@code{8},

@lilypond[quote,fragment,relative=2,verbatim]
<< {
  \once \override Stem #'transparent = ##t
  \once \override Stem #'length = #8
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

@end itemize

@cindex Trucos, distancias
@cindex Distancias

Las distancias en LilyPond se miden en espacios de pentagrama, mientras que
las propiedades de grosor se miden en grosores de líneas de pentagrama.  Algunas
propiedades son diferentes; por ejemplo, el grosor de las barras de corchea
se mide en espacios de pentagrama.  Para más información, consulte la porción
correspondiente de la referencia del programa.


@menu
* Size of objects::             
@end menu

@node Size of objects
@subsection Size of objects

UNTRANSLATED NODE: IGNORE ME

@node Default files
@section Default files

La documentación de la Referencia del Programa contiene una gran cantidad de información
sobre LilyPond, pero más información aún se puede obtener a partir de la observación
de los archivos internos de LilyPond.

Algunos ajustes por omisión como las definiciones de las
@code{\header@{@}}s (encabezamientos) están almacenados en archivos @code{.ly}.
Otros ajustes como las definiciones de los comandos de marcado se almacenan
como archivos @code{.scm} (de Scheme).  Cae fuera del ámbito de presente manual
cualquier explicación más profunda; los usuarios están advertidos de que se necesita
una considerable cantidad de conocimientos técnicos
para comprender estos archivos.

@itemize @bullet

@item Linux: @file{@var{directorio_de_instalación}/lilypond/usr/share/lilypond/current/}

@item OSX:
@file{@var{carpeta_de_instalación}/LilyPond.app/Contents/Resources/share/lilypond/current/}.
Para llegar aquí, o bien entre con @code{cd} en este directorio desde el
Terminal, o haga control-clic sobre la aplicación LilyPond y elija
@q{Mostrar el Contenido del Paquete}.

@item Windows: @file{@var{carpeta_de_instalación}/LilyPond/usr/share/lilypond/current/}

@end itemize

Los directorios @file{ly/} y @file{scm/} son de especial interés.
Archivos como @file{ly/property-init.ly} y
@file{ly/declarations-init.ly} definen todos los trucos comunes.


@node Fitting music onto fewer pages
@section Fitting music onto fewer pages

A veces puede acabar con uno o dos pentagramas en una segunda página
(o tercera, o cuarta...).  Es fastidioso sobre todo si observa las
páginas anteriores y parece haber
espacio suficiente en ellas.

Al investigar asuntos relacionados con la presentación, la herramienta
@code{annotate-spacing} (anotar el espaciado) no tiene precio.
Este comando imprime los valores de algunos comandos de espaciado;
consulte @ruser{Displaying spacing} para ver más detalles.  A partir de
la salida de de @code{annotate-spacing}, podemos ver qué márgenes podríamos desear alterar.

Aparte de los márgenes, existen otras opciones para ahorrar espacio:

@itemize
@item
Puede indicarle a LilyPond que coloque los sistemas tan juntos como sea
posible (para que quepan tantos sistemas como sea posible sobre una página),
pero luego separar estos sistemas para que no haya ningún espacio vacío
al final de la página.

@example
\paper @{
  between-system-padding = #0.1
  between-system-space = #0.1
  ragged-last-bottom = ##f
  ragged-bottom = ##f
@}
@end example

@item
Puede forzar el número de sistemas (es decir, si LilyPond quiere
tipografiar la música con 11 sistemas, puede forzarlo 
para que use 10).

@example
\paper @{
  system-count = #10
@}
@end example

@item
Evite (o reduzca) el uso de objetos que aumenten el tamaño
vertical de un sistema.  Por ejemplo, las repeticiones con
primera y segunda vez necesitan espacio adicional.  Si
estas repeticiones abarcan dos sistemas, ocuparán más espacio
que un solo sistema con las repeticiones y otro sistema sin ellas.

Otro ejemplo es desplazar las expresiones dinámicas que se
@q{asoman por encima} de un sistema.

@lilypond[verbatim,quote,fragment]
\relative c' {
  e4 c g\f c
  \override DynamicLineSpanner #'padding = #-1.8
  \override DynamicText #'extra-offset = #'( -2.1 . 0)
  e4 c g\f c
}
@end lilypond

@item
Altere el espaciado horizontal por medio de @code{SpacingSpanner}.  Consulte
@ruser{Changing horizontal spacing} para ver más detalles.

@lilypond[verbatim,quote]
\score {
  \relative c'' {
    g4 e e2 | f4 d d2 | c4 d e f | g4 g g2 |
    g4 e e2 | f4 d d2 | c4 e g g | c,1 |
    d4 d d d | d4 e f2 | e4 e e e | e4 f g2 |
    g4 e e2 | f4 d d2 | c4 e g g | c,1 |
  }
  \layout {
    \context {
      \Score
      \override SpacingSpanner
                #'base-shortest-duration = #(ly:make-moment 1 4)
    }
  }
}
@end lilypond

@end itemize


@node Advanced tweaks with Scheme
@section Advanced tweaks with Scheme

Hemos visto cómo la salida de LilyPond se puede modificar de manera muy profunda utilizando
comandos como
@code{\override TextScript #'extra-offset = ( 1 . -1)}.  Pero
tenemos un potencial incluso mayor si utilizamos Scheme.  Para ver una explicación completa
de esto, consulte el @ruser{Scheme tutorial} e
@ruser{Interfaces for programmers}.

Podemos usar Scheme simplemente para sobreponer (@code{\override}) comandos,

@lilypond[quote,verbatim,ragged-right]
padText = #(define-music-function (parser location padding) (number?)
#{
  \once \override TextScript #'padding = #$padding
#})

\relative c''' {
  c4^"piu mosso" b a b
  \padText #1.8
  c4^"piu mosso" d e f
  \padText #2.6
  c4^"piu mosso" fis a g
}
@end lilypond

Podemos usarlo para crear comandos nuevos,

@lilypond[quote,verbatim,ragged-right]
tempoMark = #(define-music-function (parser location padding marktext)
                                    (number? string?)
#{
  \once \override Score . RehearsalMark #'padding = $padding
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $marktext }
#})

\relative c'' {
  c2 e
  \tempoMark #3.0 #"Allegro"
  g c
}
@end lilypond

E incluso se le pueden pasar expresiones musicales.

@lilypond[quote,verbatim,ragged-right]
pattern = #(define-music-function (parser location x y) (ly:music? ly:music?)
#{
  $x e8 a b $y b a e
#})

\relative c''{
  \pattern c8 c8\f
  \pattern {d16 dis} { ais16-> b\p }
}
@end lilypond


@node Avoiding tweaks with slower processing
@section Avoiding tweaks with slower processing

LilyPond puede llevar a cabo comprobaciones adicionales al tiempo que
procesa los archivos.  Estos comandos consumen tiempo, pero el
resultado puede necesitar menos trucos manuales.

@example
%%  asegura que las marcas de texto y letras de las canciones se encuentran dentro de los márgenes de la página
\override Score.PaperColumn #'keep-inside-line = ##t 
@end example




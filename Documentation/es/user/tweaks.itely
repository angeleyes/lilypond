@c -*- coding: utf-8; mode: texinfo; -*-
@c This file is part of lilypond.tely
@ignore
    Translation of GIT committish: 09959774607dd319f60a75ab1927981d7707feee

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  See TRANSLATION for details.
@end ignore

@node Tweaking output
@chapter Tweaking output

Este capítulo trata de cómo modificar la salida.  LilyPond es extremadamente
configurable; prácticamente todos los fragmentos de la salida se pueden cambiar.


@menu
* Tweaking basics::             
* The Internals Reference manual::  
* Appearance of objects::       
* Collisions of objects::
* Common tweaks::               
* Default files::               
* Fitting music onto fewer pages::  
* Avoiding tweaks with slower processing::  
* Advanced tweaks with Scheme::  
@end menu

@node Tweaking basics
@section Tweaking basics

@menu
* Introduction to tweaks::      
* Objects and interfaces::      
* Naming conventions of objects and properties::  
* Tweaking methods::            
@end menu

@node Introduction to tweaks
@subsection Introduction to tweaks

El @q{Trucaje} es un término de LilyPond que denota los diversos
métodos que el usuario tiene a su disposición para modificar el
proceso de interpretación del archivo de entrada y cambiar la
apariencia de la salida impresa.  Algunos trucos son muy fáciles de
usar; otros son más complejos.  Pero en su conjunto, los métodos de
trucaje disponibles posibilitan conseguir casi cualquier apariencia
que deseemos en la música impresa.

En esta sección vamos a estudiar los conceptos básicos que se
necesitan para comprender el trucaje.  Más tarde daremos un amplio
abanico de instrucciones listas para usar, que podrá simplemente
copiar para obtener el mismo efecto en sus partituras, y al mismo
tiempo mostraremos la forma de construir dichas instrucciones para que
pueda aprender cómo desarrollar sus propios trucos.

Antes de comenzar con este capítulo, quizá quiera echar un vistazo a
la sección @ref{Contexts and engravers}, pues los Contextos, los
Grabadores y las Propiedades que se contienen en ellos son
fundamentales para comprender y construir los trucos.

@node Objects and interfaces
@subsection Objects and interfaces

@cindex objetos
@cindex grobs
@cindex selectores
@cindex interfaces

El trucaje consiste en modificar el funcionamiento y estructura
interna del programa LilyPond, por lo que en primer lugar
introduciremos algunos términos que se usan para describir dichas
operaciones y estructuras internas.

El término @q{Objeto} es un término genérico que se usa para referirse
a la multitud de estructuras internas que LilyPond construye durante
el procesado de un archivo de entrada.  Así, cuando se encuentra una
instrucción como @code{\new Staff}, se construye un objeto nuevo del
tipo @code{Staff}.  Entonces, este objeto @code{Staff} contiene todas
las propiedades asociadas con ese pentagrama en particular, por
ejemplo, su nombre y su armadura, además de otros detalles de los
grabadores que se han asignado para que operen dentro del contexto del
pentagrama.  De forma similar, hay objetos que guardan las propieades
de todos los demás contextos, como objetos de @code{Voice}, objetos de
@code{Score}, objetos de @code{Lyrics}, así como objetos que
representan todos los elementos notacionales como líneas divisorias,
cabezas de las notas, ligaduras, indicaciones dinámicas, etc.  Cada
objeto tiene su propio conjunto de valores de propiedad.

Ciertos tipos de objetos reciben nombres especiales.  Los objetos que
representan elementos de notación sobre la salida impresa como cabezas
de notas, plicas, ligaduras de expresión y de unión, digitaciones,
claves, etc. reciben el nombre de @q{Objetos de presentación}, a
menudo conocidos como @q{Objetos gráficos}, o abreviadamente
@q{Grobs}.  Aún son objetos en el sentido genérico que hemos
mencionado, y también todos ellos tienen propiedades asociadas, como
su posición, tamaño, color,etc.

Ciertos objetos de presentación son aún más especializados.  Las
ligaduras de fraseo, los reguladores, las indicaciones de octava alta
y baja, y muchos otros objetos gráficos no están situados en un solo
lugar: tienen un punto de inicio, un punto de final, y quizá otras
propiedades relacionadas con su forma.  Los objetos con una forma
extendida como estos, reciben el nombre de «Objetos de extensión» o
@q{Spanners}.

Aún falta por explicar qué son los @q{Interfaces}.  Muchos objetos,
incluso aunque son bastante diferentes, comparten funcionalidades que
se deben procesar de la misma manera.  Por ejemplo, todos los objetos
gráficos tienen un color, un tamaño, una posición, etc., y todas estas
propiedades se procesan de la misma forma durante la interpretación
del archivo de entrada por parte de LilyPond.  Para simplificar estas
operaciones internas, estas acciones t propiedades comunes se agrupan
en un objeto llamado @code{grob-interface}, interface de grob.  Hay
muchas otras agrupaciones de propiedades comunes como ésta, y cada
unoa recibe un nombre que acaba en @code{interface}.  En total hay más
de 100 interfaces de éstos.  Veremos más adelante porqué esto es del
interés y de utilidad para el usuario.

Estos son, en fin, los términos principales relativos a los objetos
que vamos a utilizar en este capítulo.

@node Naming conventions of objects and properties
@subsection Naming conventions of objects and properties

Ya hemos visto ciertas convenciones de nomenclatura de objetos, en la
sección @ref{Contexts and engravers}.  En este lugar, para más fácil
referencia, presentamos una lista de los tipos de objetos y
propiedades más comunes, junto con las convenciones según las cuales
reciben su nombre, y un par de ejemplos de nombres reales.  Hemos
utilizado una «A» mayúscula para denotar cualquier carácter alfabético
en mayúsculas, y «aaa» para cualquier número de caracteres alfabéticos
en minúscula.  Otros caracteres se utilizan literalmente como están.

@multitable @columnfractions .33 .33 .33
@headitem Objeto o tipo de propiedad
  @tab Convención de nomenclatura
  @tab Ejemplo
@item Contextos
  @tab Aaaa o AaaaAaaaAaaa
  @tab Staff, GrandStaff
@item Objetos de presentación
  @tab Aaaa o AaaaAaaaAaaa
  @tab Slur, NoteHead
@item Grabadores
  @tab Aaaa_aaa_engraver
  @tab Clef_engraver, Note_heads_engraver
@item Interfaces
  @tab aaa-aaa-interface
  @tab grob-interface, break-aligned-interface 
@item Propiedades de contextos
  @tab aaa o aaaAaaaAaaa
  @tab alignAboveContext, skipBars
@item Propiedades de objetos de presentación
  @tab aaa o aaa-aaa-aaa
  @tab direction, beam-thickness
@end multitable

Como podremos ver en breve, las propiedades de distintos tipos de
objeto se modifican por parte de diferentes instrucciones; así pues,
es útil poder reconocer el tipo de objeto a partir de sus nombres de
propiedad.

@node Tweaking methods
@subsection Tweaking methods

@strong{La instrucción \override}

@cindex override, instrucción
@funindex \override

Ya hemos visto las instrucciones @code{\set} y @code{\with}, que se
usan para cambiar las propiedades de los @strong{contextos} y para
quitar y poner @strong{grabadores}, en @ref{Modifying context
properties} y @ref{Adding and removing engravers}.  Ahora debemos
examinar algunas instrucciones importantes más.

La instrucción que cambia las propiedades de los @strong{objetos de
presentación} es @code{\override}.  Puesto que esta instrucción debe
modificar propiedades internas que se encuentran en un lugar profundo
dentro de LilyPond, su sintaxis no es tan simple como la del resto de
las instrucciones que hemos visto hasta ahora.  Tiene que saber
exactamente qué propiedad de qué objeto y en qué contexto se debe
modificar, y cuál debe ser su nuevo valor.  Veamos cómo se hace.

La sintaxis genérica de esta instrucción es:

@example
\override @emph{contexto}.@emph{objeto_de_presentación} 
  #'@emph{propiedad_de_presentación} = #@emph{valor}
@end example

@noindent
Esto establecerá la propiedad de nombre
@emph{propiedad_de_presentación} del objeto de presentación con el
nombre @emph{objeto_de_presentación}, que es miembro del contexto
@emph{contexto}, al valor @emph{valor}.

El @emph{contexto} se puede omitir (y normalmente así es) cuando el
contexto requerido se encuentra implicado sin ambigüedad y es uno de
los contextos del nivel más bajo, es decir: @code{Voice},
@code{ChordNames} o @code{Lyrics}, y lo omitiremos en muchos de los
ejemplos siguientes.  Veremos más tarde cuándo se debe especificar.

Las últimas secciones tratan de forma exhaustiva las propiedades y sus
valores, pero para ilustrar el formato y utilización de estas
iinstrucciones usaremos sólo unas cuantas propiedades y valores
sencillos que sean fáciles de entender.

Por ahora no se preocupe por el @code{#'}, que debe anteponerse a la
propiedad de presentación, y el @code{#}, que debe preceder al valor.
Deben estar presentes siempre y de esa forma exacta.  Es la
instrucción de uso más común dentro del trucaje, y durante la mayor
parte del resto de este capítulo presentaremos ejemplos de cómo se
usa.  A continuación hay un ejemplo sencillo para cambiar el color de
una cabeza:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a b c
@end lilypond

@strong{La instrucción \revert}

@cindex revert, instrucción
@funindex \revert

Una vez sobreescrita, la proopiedad retiene su nuevo valor hasta que
se sobreescribe de nuevo o se encuentra una instrucción
@code{\revert}.  La instrucción @code{\revert} tiene la siguiente
sintaxis y ocasiona que el valor de la propiedad se devuelva a su
valor predeterminado original; observe que no es a su valor previo si
se han utilizado varias instrucciones @code{\override}.

@example
\revert @emph{contexto}.@emph{objeto_de_presentación} #'@emph{propiedad_de_presentación}
@end example

Una vez más, igual que @emph{contexto} dentro de la instrucción
@code{\override}, con frecuencia no es necesario especificar el
@emph{contexto}.  Se omitirá en muchos de los ejemplos siguientes.
Aquí devolvemos el color de la cabeza al valor predeterminado para las
dos últimas notas:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a
\revert NoteHead #'color
b c
@end lilypond

@strong{El prefijo \once}

Tanto la instrucción @code{\override} como @code{\set} se pueden
preceder por @code{\once}.  Esto ocasiona que la siguiente instrucción
@code{\override} o @code{\set} sea efectiva solamente durante el
tiempo musical en curso y antes de que la propiedad vuelva a tener
otra vez su valor predeterminado.  Utilizando el mismo ejemplo,
podemos cambiar el color de una sola nota de la siguiente manera:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\once \override NoteHead #'color = #red
e f g
\once \override NoteHead #'color = #green
a b c
@end lilypond

@strong{La instrucción \overrideProperty}

@cindex overrideProperty, instrucción
@funindex \overrideProperty

Hay otra forma para la instrucción de sobreescritura,
@code{\overrideProperty}, que ocasionalmente es necesaria.  La
mencionamos aquí con un propósito de exhaustividad, pero para ver más
detalles consulte @ruser{Difficult tweaks}.
@c Maybe explain in a later iteration  -td

@strong{La instrucción \tweak}

@cindex tweak, instrucción
@funindex \tweak

La última instrucción de trucaje que está disponible es @code{\tweak}.
Se debe utilizar para cambiar las propiedades de objetos que suceden
en el mismo momento musical, como las notas de un acorde.  El uso de
@code{\override} para la sobreescritura afectaría a todas las notas
del acorde, mientras que @code{\tweak} afecta solamente al siguiente
elemento del flujo de entrada.

He aquí un ejemplo.  Suponga que queremos cambiar el tamaño de la nota
intermedia (el Mi) en un acorde de Do mayor.  En primer lugar, veamos
lo que haría @code{\once \override}:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  \once \override NoteHead #'font-size = #-3
  <c e g>
  <c e g>
@end lilypond

Vemos que la sobreescritura con override afecta a @emph{todas} las
notas del acorde.  Esto es así porque todas las notas de un acorde
ocurren en el mismo @emph{momento musical}, y la acción de
@code{\once} es aplicar la sobreescritura a todos los oobjetos de
presentación del tipo especificado que ocurren en el mismo momento
musical que la propia instrucción de sobreescritura @code{\override}.

LA instrucción @code{\tweak} opera de una forma distinta.  Actúa sobre
el elemento inmediatamente siguiente dentro del flujjo de entrada.
Sin embargo, es efectivo solamente sobre objetos que se crean
directamente a partir del flujo de entrada, en esencia las cabezas y
las articulaciones (los objetos como las plicas y las alteraciones se
crean con posterioridad y no se pueden trucar de esta forma).  Es más,
cuando se aplica a las cabezas de las notas, éstas @emph{deben} estar
dentro de un acorde, es decir, dentro de ángulos simples, así que para
trucar una sola nota la instrucción @code{\tweak} se debe colocar
dentro de ángulos simples junto con la nota.

Así pues, volviendo a nuestro ejemplo, el tamaño de la nota intermedia
se cambiaría de la siguiente forma:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  <c \tweak #'font-size #-3 e g>4
@end lilypond

Observe que la sintaxis de @code{\tweak} es diferente de la de la
instrucción @code{\override}.  Ni el contexto ni el objeto de
presentación se deben especificar; de hecho, generaría un error
hacerlo.  Los dos están implícitos por el siguiente elemento del flujo
de entrada.  Así que la sintaxis genérica de la instrucción
@code{\tweak} es, simmplemente:

@example
\tweak #'@emph{propiedad_de_presentación} = #@emph{valor}
@end example

Una instrucción @code{\tweak} también se puede usar para modificar
sólo una de una serie de articulaciones, como se muestra aquí:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
a ^Black
  -\tweak #'color #red ^Red
  -\tweak #'color #green _Green
@end lilypond

Observe que la instrucción @code{\tweak} debe venir precedida de una
marca de articulación como si ella misma fuera una articulación.

@cindex grupos especiales anidados
@cindex tresillos anidados
@cindex corchete del grupo especial
@cindex grupo especial, corchete de
@cindex tresillo, corchete de
@funindex TupletBracket

La instrucción @code{\tweak} también se debe usar para cambiar la
apariencia de uno solo de un conjunto de grupos especiales anidados
que comiencen en el mismo instante musical.  En el siguiente ejemplo,
el corchete del tresillo largo y el primero de los tres corchetes
cortos empiezan en el mismo momento musical, y por ello cualquier
instrucción @code{\override} se aplicaría a los dos.  En el ejemplo se
usa @code{\tweak} para distinguir entre ellos.  La primera instrucción
@code{\tweak} especifica que el corchete del tresillo largo se debe
colocar por encima de las notas y el segundo especifica que el número
del tresillo se debe imprimir en rojo sobre el corchete del primer
tresillo corto.

@lilypond[quote,ragged-right,verbatim,fragment,relative=2]
\tweak #'direction #up
\times 4/3 {
  \tweak #'color #red
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
}
@end lilypond

Encontrará más detalles de la instrucción @code{\tweak} en
@ruser{Objects connected to the input}.

Si los grupos anidados no comienzan en el mismo momento, su apariencia
se puede modificar de la forma usual mediante instrucciones
@code{\override}:

@c NOTE Tuplet brackets collide if notes are high on staff
@c See issue 509
@lilypond[quote,ragged-right,verbatim,fragment,relative=1]
\times 2/3 { c8[ c c]}
\once \override TupletNumber 
  #'text = #tuplet-number::calc-fraction-text
\times 2/3 {
  c[ c]
  c[ c]
  \once \override TupletNumber #'transparent = ##t
  \times 2/3 { c8[ c c] }
\times 2/3 { c8[ c c]}
}
@end lilypond

@node The Internals Reference manual
@section The Internals Reference manual

@cindex Internals Reference

@menu
* Properties of layout objects::  
* Properties found in interfaces::  
* Types of properties::         
@end menu

@node Properties of layout objects
@subsection Properties of layout objects

@cindex propiedades de los objetos de presentación
@cindex propiedades de los grobs
@cindex grobs, propiedades de
@cindex presentación, propiedades de los objetos de

Suponga que tiene una partitura con una ligadura de expresión que para
su gusto es demasiado fina y quiere trazarla un poco más gruesa. ¿Cómo
debe proceder?  Ya sabe, por las afirmaciones anteriores acerca de la
flexibilidad de LilyPond, que tal posibilidad existe, y seguramente
piensa que una cierta instrucción de sobreescritura @code{\override}
será necesaria.  Pero ¿existe una propiedad de grosor para las
ligaduras? y, si la hay, ¿cómo se puede modificar?  Aquí es donde
interviene el Manual de Funcionamiento Interno.  Contiene toda la
información que puede necesitar para construir ésta y todas las demás
instrucciones @code{\override}, de sobreescritura.

Una advertencia antes de dirigir nuestra mirada a la referencia de
funcionamiento interno.  Éste es un documento de @strong{referencia},
lo que significa que hay pocas o ninguna explicación en él: su
propósito es presentar la información de forma precisa y concisa.  Por
tanto, podrá parecerle desalentador a primera vista.  ¡No se preocupe!
La guía y las explicaciones que presentamos aquí le permitirán extraer
la información de la referencia de funcionamiento interno por sí mismo
con tan sólo algo de práctica.

@cindex sobreescritura, ejemplo de
@cindex Referencia de Funcionamiento Interno, ejemplo de utilización

Utilicemos un ejemplo concreto con un sencillo fragmento de música
real:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g | 
    g[( e]) e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

Suponga ahora que decidimos que nos gustan las ligaduras algo más
gruesas.  ¿Es posible?  La ligadura es, ciertamente, un objeto de
presentación, así que la cuestión es @q{¿Hay una propiedad
perteneciente a las ligaduras de expresión que controle su grosor?}
Para responder a esta pregunta debemos mirar el manual de Referencia
de Funcionamiento Interno, abreviadamente RFI@footnote{@strong{IR}
(Internals Reference) en inglés}.

El RFI de la versión de LilyPond que está usando se puede encontrar en
la página web de LilyPond en @uref{http://lilypond.org}.  Vaya a la
página de la documentación y siga el enlace Manual de Referencia de
Funcionamiento Interno (RFI).  Para nuestros propósitos pedagógicos
sería mejor que utilizase la versión html, no la @q{en una sola
página} ni el PDF.  Para que los siguientes párrafos tengan algún
sentido deberá consultarlo realmente al tiempo que lee.

@c Link names in English as these pages are not yet translated
Bajo el encabezamiento @strong{Top} podrá ver cinco enlaces.
Seleccione el enlace @emph{Backend}, que es donde se encuentra la
información sobre los objetos de presentación.  Una vez allí, bajo el
encabezamiento @strong{Backend}, siga el enlace @emph{All layout
objects}.  La página que aparece relaciona todos los objetos de
presentación que se usan en su versión de LilyPond, en orden
alfabético.  Siga el enlace Slur (ligadura de expresión), y aparecerán
relacionadas las propiedades de las ligaduras de expresión o Slurs.

(Una forma alternativa de encontrar esta página es a partir de la
Referencia de la Notación.  En una de las páginas que tratan de las
ligaduras de expresión podrá encontrar un enlace al manual de
referencia del funcioonamiento interno.  Este enlace le llevará
directamente a esta página, aunque con frecuencia es más fácil ir
directamente al RFI y buscar allí.)

Esta página sobre las ligaduras de expresión dentro del manual RFI nos
dice en primer lugar que los objetos Slur se crean por el grabador
Slur_engraver.  A continuación relaciona los ajustes estándar.
Observe que @strong{no} están en orden alfabético.  Navegue hacia
abajo buscando una propiedad que pudiera controlar el grosor de las
ligaduras, y encontrará

@example
@code{thickness} (number)
     @code{1.2}
     Line thickness, generally measured in @code{line-thickness}
@end example

Esto promete ser una buena opción para cambiar el grosor.  Nos dice
que el valor de @code{thickness} es un simple @emph{número}, que el
valor predeterminado es 1.2, y que las unidades están dentro de otra
propiedad llamada @code{line-thickness}.

Como dijimos con anterioridad, existen entre pocas y ninguna
explicación en el RFI, pero ya tenemos información suficiente para
probar a cambiar el grosor de la ligadura.  Vemos que el nombre del
objeto de presentación es @code{Slur}, que el nombre de la propiedad
que debemos cambiar es @code{thickness} y que el nuevo valor debe ser
un número algo más grande que 1.2 si queremos hacer las ligaduras más
gruesas.

Ahora podemos construir la instrucción de sobreescritura
@code{\override} simplemente mediante la sustitución de los valores
que hemos encontrado para los nombres, omitiendo el contexto.
Usaremos un valor muy grande para el grosor al principio, para estar
seguros de que la instrucción está funcionando.  Obtenemos lo
siguiente:

@example
\override Slur #'thickness = #5.0
@end example 

¡No olvide el @code{#'} antes del nombre de la propiedad y @code{#}
antes del valor nuevo!

La pregunta final es @q{¿Dónde se debe colocar esta instrucción?}
Aunque nos falta seguridad y estamos todavía aprendiendo, la mejor
respuesta es: @q{Dentro de la música, antes de la primera ligadura y
cerca de ella.}  Hagámoslo así:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
y podemos ver que la ligadura, es sin duda, más pesada.

Así pues, ésta es la forma básica de construir instrucciones
@code{\override} o de sobreescritura.  Existen unas cuantas
complicaciones más con las que nos encontraremos en secciones
posteriores, pero ahora conoce todos los principios esenciales que
necesita para hacerlo por sí mismo (aunque aún necesita algo de
práctica).  La cual vendrá proporcionada por los ejemplos que vienen a
continuación.

@subheading Finding the context
@cindex contexto, encontrar

Pero en primer lugar ¿qué habría pasado si hubiésemos tenido que
especificar el contexto? ¿Cuál sería?  Podemos suponer que las
ligaduras están en el contexto de Voz, por estar claramente asociados
de manera estrecha con las líneas individuales de música, pero
¿podemos estar seguros?  Para averiguarlo, vayamos de nuevo al inicio
de la página del RFI que describe las ligaduras (Slur), donde dice
@q{Slur objects are created by: Slur engraver} («Los objetos de
ligadura de expresión se crean por: el grabador Slur»).  Así pues, las
ligaduras de expresión se crean en cualquier contexto en el que se
encuentre el grabador @code{Slur_engraver}.  Siga el enlace a la
página del grabador @code{Slur_engraver}.  Al final del todo, dice que
el grabador @code{Slur_engraver} es parte de cinco contextos de voz,
incluido el contexto de voz estándar, @code{Voice}, por lo que nuestra
suposición era acertada.  Y a causa de que @code{Voice} es uno de los
contextos de más bajo nivel que se encuentra implícito sin ambigüedad
por el hecho de que estamos escribiendo notas, podemos omitirlo en
este lugar concreto.

@subheading Overriding once only

@cindex sobreescritura por una sola vez
@cindex once override
@funindex \once

Como puede ver, @emph{todas} las ligaduras son más gruesas en el
último ejemplo.  Pero ¿y si quisiéramos que solamente la primera
ligadura fuese más gruesa?  Esto se consigue con la instrucción o
prefijo @code{\once}.  Colocado inmediatamente antes de la instrucción
@code{\override} ocasiona que solamente cambie la ligadura que
comienza en la nota @strong{inmediata siguiente}.  Si la nota
inmediata siguiente no da inicio a una ligadura, la instrucción no
tiene niingún efecto en absoluto: no se recuerda hasta que se
encuentre alguna ligadura, sino que simplemente se ignora.  Así pues,
la instrucción que lleva @code{\once} se debe reposicionar de la forma
siguiente:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g | 
    g[( e]) e d[( f]) a | 
    a g 
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
Hemos hecho que ahora solamente la primera ligadura sea más gruesa.

La instrucción o prefijo @code{\once} también se puede usar antes de
la instrucción @code{\set}.

@subheading Reverting

@cindex revert
@cindex predeterminadas, devolver a las propiedades
@funindex \revert

Finalmente ¿y si quisiéramos que solamente las dos primeras ligaduras
fuesen más gruesas?  En fin; podríamos usar dos instrucciones, cada
una de ellas precedida por el prefijo @code{\once}, situadas
inmediatamente antes de cada una de las notas en que comienzan las
ligaduras:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    g[( e]) e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond 

@noindent
o podríamos omitir la instrucción prefija @code{\once} y utilizar la
instrucción @code{\revert} (restablecer) para devolver la propiedad
del grosor, @code{thickness}, a su valor predeterminado después de la
segunda ligadura:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e]) 
    % Revert thickness of all following slurs to default of 1.2
    \revert Slur #'thickness
    e d[( f]) a | 
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond

@noindent
la instrucción @code{\revert} se puede utilizar para devolver
cualquier propiedad que se haya cambiado con @code{\override} a su
valor predeterminado.  Puede utilizar el método que mejor se adapte a
aquello que quere hacer.

Así finaliza nuestra introducción al manual de RFI, y el método básico
de trucaje.  A continuación, en las últimas secciones de este capítulo
encontrará varios ejemplos, en parte para introducirle en algunas de
las posibilidades adicionales del manual RFI, y en parte para
proporcionarle más práctica en cómo extraer información de él.  Estos
ejemplos irán conteniendo cada vez menos palabras de guía y
explicación.

@node Properties found in interfaces
@subsection Properties found in interfaces

@cindex propiedades de los interfaces
@cindex interfaces, propiedades

Suponga ahora que queremos imprimir la letra de la canción en cursiva.
¿Qué forma de instrucción @code{\override} necesitamos para hacerlo?
En primer lugar miramos en la página del RFI que relaciona todos los
objetos, @q{All layout objects}, como antes, y buscamos un objeto que
pueda conteolar la letra de la canción.  Encontramos @code{LyricText},
que parece adecuado.  Al seguir este enlace se presentan las
propiedades ajustables para el texto de la letra.  Estos incluyen
@code{font-series} y @code{font-size}, pero nada que pudiera aplicar
una forma cursiva.  Esto es porque la propiedad de la forma es común a
todos los objetos de fuente tipográfica, y por tanto, en vez de
incluirlo en cada uno de los objetos de preesentación, se agrupa junto
con otras propiedades comunes similares y se deposita en un
@strong{Interface}, el interface de las fuentes tipográficas
@code{font-interface}.

Por tanto, ahora necesitamos aprender cómo encontrar las propiedades
de los interfaces, y descubrir qué objetos usan estas propiedades de
interface.

Mire de nuevo la página del RFI que decribe a LyricText.  Al final de
la página hay una lista de enlaces (en las versiones de html del RFI)
a los interfaces que LyricText contempla.  La lista tiene siete
elementos, entre ellos @code{font-interface}.  Al seguir este enlace
llegamos a las propiedades asociadas con este interface, que también
son propiedades de todos los objetos que lo llevan, entre ellos
LyricText.

Ahora vemos todas las propiedades ajustables por el usuario que
controlan las tipografías, entre ellas @code{font-shape(symbol)},
donde @code{symbol} se puede establecer a @code{upright} (recta),
@code{italics} (cursiva)o @code{caps} (mayúsculas pequeñas).

Observará que @code{font-series} y @code{font-size} también se
encuentran aquí relacionadas.  Esto inmediatamente hace que surja la
pregunta: ¿Por qué están las propiedades comunes de tipografía
@code{font-series} y @code{font-size} relacionadas bajo
@code{LyricText} así como bajo el interface @code{font-interface} pero
@code{font-shape} no lo está?  La respuesta es que @code{font-series}
y @code{font-size} se cambian a partir de sus valores predeterminados
globales cuando se crea un objeto @code{LyricText}, pero
@code{font-shape} no lo hace.  Entonces los elementos de la lista
@code{LyricText} le dicen los valores para esas dos propiedades que
son de aplicación para @code{LyricText}.  Otros objetos que contemplan
@code{font-interface} establecerán dichas propiedades de forma
diferente cuando se crean.

Veamos si ahora podemos construir la instrucción @code{\override} para
cambiar la letra a cursiva.  El objeto es @code{LyricText}, la
propiedad es @code{font-shape} y el valor es @code{italic}.  Igual que
antes, omitiremos el contexto.

Como nota aparte, aunque una nota importante, observe que a causa de
que los valores de @code{font-shape} son símbolos, deben ir precedidos
de un apóstrofe, @code{'}.  Esa es la razón por la que se necesitan
apóstrofes antes de @code{thickness} en el ejemplo anterior y en
@code{font-shape}.  Los dos son también símbolos.  Los símbolos son
nombres especiales que son conocidos por LilyPond internamente.
Algunos de ellos son nombres de propiedades, como @code{thickness} o
@code{font-shape}, otros son en efecto valores especiales que se les
puede dar a las propiedades, como @code{italic}.  Observe la
distincion entre esto y las cadenas de texto arbitrarias, que
aparecerían entrecomilladas como @code{"a text string"}.

De acuerdo, entonces la instrucción @code{\override} que necesitamos
para imprimir la letra en cursiva sería

@example
\override LyricText #'font-shape = #'italic
@end example

@noindent
y debe colocarse justo delante de, y cerca de, la letra a la que debe
afectar, como esto:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    \override LyricText #'font-shape = #'italic
    The man who feels love's sweet e -- mo -- tion 
  }
}
@end lilypond

@noindent
y toda la letra se imprime en cursiva.

@subheading Specifying the context in lyric mode
@cindex contexto, especificación en modo letra

En el caso de la letra, si intenta especificar el contexto en el
formato que acabamnos de dar, la instrucción no funcionará.  Una
sílaba escrita en el modo letra, «lyricmode» temina en un espacio, un
salto de línea o un dígito.  Cualquier otro carácter se incluye como
parte de la sílaba.  Por esta razón, un espacio o salto de línea debe
aparecer antes del último símbolo @code{@}} para evitar que se incluya
como parte de la sílaba final.  De forma similar, se deben insertar
espacios antes y después del punto, @q{.}, separando el nombre del
contexto del nombre del objeto, pues en caso contrario los dos nombres
se juntarán y el intérprete no podrá reconocerlos.  Así pues, la
instrucción será:

@example
\override Lyrics . LyricText #'font-shape = #'italic
@end example

@warning{Dentro de la letra, deje siempre espacios entre la sílaba
final y la llave de cierre.}

@warning{En las sobreescrituras con override dentro de la letra,
escriba siempre espacios antes y después del punto que separa el
nombre del contexto y el nombre del objeto.}

@node Types of properties
@subsection Types of properties

@cindex propiedades, tipos de

Hasta ahora hemos visto dos tipos de propiedad:: @code{número} y
@code{símbolo}.  Para que sea válido, el valor que se da a una
propiedad debe ser del tipo correcto y obedecer las reglas de dicho
tipo.  El tipo de la propiedad se muestra siempre entre paréntesis
después del nombre de la propiedad en el RFI.  He aquí una lista de
los tipos que podrá necesitar, junto con las reglas de dicho tipo, y
algunos ejemplos.  Debe escribir siempre un símbolo de almohadilla,
@code{#}, por supuesto, delante de estos valores cuando se introducen
en la instrucción @code{\override}.

@multitable @columnfractions .2 .45 .35
@headitem Tipo de propiedad
  @tab Reglas
  @tab Ejemplos
@item Booleano
  @tab Verdadero o Falso, representado por #t o #f
  @tab @code{#t}, @code{#f}
@item Dimensión (en espacios de pentagrama)
  @tab Un número decimal positivo (en unidades de espacios de pentagrama)
  @tab @code{2.5}, @code{0.34}
@item Dirección
  @tab Una constante válida de dirección o su equivalente numérico
  @tab @code{#LEFT}, @code{#CENTER}, @code{#UP},
       @code{1}, @code{-1}
@item Entero
  @tab Un número entero positivo
  @tab @code{3}, @code{1}
@item Lista
  @tab Un conjunto de elementos entre paréntesis separados por espacios y precedido de un apóstrofe
  @tab @code{'(left-edge staff-bar)}, @code{'(1)},
       @code{'(1.0 0.25 0.5)}
@item Marcado
  @tab Cualquier elemento válido de marcado de texto
  @tab @code{\markup @{ \italic "cresc." @}}
@item Momento
  @tab Una fracción de redonda construida con la función make-moment
  @tab @code{(ly:make-moment 1 4)},
       @code{(ly:make-moment 3 8)}
@item Número
  @tab Cualquier valor decimal positivo o negativo
  @tab @code{3.5}, @code{-2.45}
@item Pareja (de números)
  @tab Dos números separados por un @q{espacio . espacio}, encerrado entre paréntesis y precedido de un apóstrofe
  @tab @code{'(2 . 3.5)}, @code{'(0.1 . -3.2)}
@item Símbolo
  @tab Cualquiera del conjunto de símbolos premitidos para esa propiedad, precedido de un apóstrofe
  @tab @code{'italic}, @code{'inside}
@item Desconocido
  @tab Un procedimiento o @code{#f} (para no producir ninguna acción)
  @tab @code{bend::print}, @code{ly:text-interface::print},
       @code{#f}
@item Vector
  @tab Una lista de tres elementos encerrados entre paréntesis y precedida de una almohadilla, @code{#}.
  @tab @code{#(#t #t #f)}
@end multitable

@node Appearance of objects
@section Appearance of objects

Ahora vamos a poner en práctica lo que hemos aprendido con unos
cuantos ejemplos que muestran cómo se pueden usar los trucos para
cambiar el aspecto de la música impresa.

@menu
* Visibility and color of objects::  
* Size of objects::             
* Length and thickness of objects::  
@end menu

@node Visibility and color of objects
@subsection Visibility and color of objects

Dentro de un uso educativo de la música, podríamos desear imprimir una
partitura con ciertos elementos omitidos como ejercicio para el
alumno, a quien se le pide que los complete.  A la manera de ejemplo
sencillo, supongamos que el ejercicio es escribir las líneas
divisorias que faltan en un fragmento musical.  Pero las líneas
divisorias normalmente se insertan automáticamente. ¿Cómo hacemos para
que no se impriman?

Antes de enredarnos con esto, recordemos que las propiedades de los
objetos se agrupan en lo que hemos llamado @emph{interfaces} (véase
@ref{Properties found in interfaces}).  Esto es simplemente agrupar
las propiedades que normalmente se necesitan juntas: si una de ellas
se necesita para un objeto, también las otras.  Así, ciertos objetos
necesitan las propiedades de algunos interfaces, otros necesitan las
de otros interfaces.  Los interfaces que contienen las propiedades que
un determinado grob necesita se ecuentran relacionadas en el manual
RFI al final de la página que describe dicho grob, y esas propiedades
se pueden ver mirando dichos interfaces.

Hemos explicado cómo encontrar información sobre los grobs en
@ref{Properties of layout objects}.  Usando el mismo enfoque, vamos al
RFI para biscar el objeto de presentación que imprime las líneas
divisorias.  A través del enlace @emph{Backend} y @emph{All layout
objects} encontramos que hay un objeto de presentación llamado
@code{BarLine}.  Entre sus propiedades se encuentran dos que controlan
la visibilidad: @code{break-visibility} y @code{stencil}.  Las líneas
divisorias también contemplan un número de interfaces, entre ellos el
@code{grob-interface}, donde podemos encontrar las propiedades
@code{transparent} y @code{color}.  Todas ellas pueden afectar la
visibilidad de las barras de compás (y, por supuesto, por extensión,
tambén la de muchos otros objetos de presentación).  Vamos a
considerar cada uno de ellos por orden.

@subheading stencil
@cindex stencil (sello), propiedad

Esta propiedad controla la apariencia de las barras de compás mediante
la especificación del símbolo (o «glifo») que se debe imprimir.  Igual
que como otras muchas propiedades, se puede establecer de forma que no
imprima nada ajustando su valor a @code{#f}.  Vamos a probarlo, como
antes, omitiendo el Contexto implícito, @code{Voice}:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Las barras de compás todavía se imprimen.  ¿Qué es lo que está mal?
Vuelva al RFI y mire de nuevo la página que ofrece las propiedades del
objeto BarLine.  Al principio de la página dice @qq{Barline objects
are created by: Bar_engraver} (los objetos Barline se crean por el
grabador Bar_engraver).  Vaya a la página del grabador
@code{Bar_engraver} siguiendo el enlace.  Al final da una lista de
contextos en los que el grabador de líneas divisorias opera.  Todos
ellos son del tipo @code{Staff}, y así la razón de que la instrucción
@code{\override} no funcionara como esperábamos, es porque
@code{Barline} no se encuentra en el contexto predeterminado
@code{Voice}.  Si el contexto se especifica mal, la instrucción
simplemente no funciona.  No se produce ningún mensaje de error, y no
se registra nada en el archivo log de registro.  Vamos a intentar
corregirlo escribiendo el contexto correcto:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Ahora las barras de compás han desaparecido.

@subheading break-visibility

@cindex break-visibility property

Vemos en las propiedades de @code{BarLine} que aparecen en el RFI que
la propiedad @code{break-visibility} requiere un vector de tres
valores booleanos.  Controlan respectivamente si las barras de compás
se imprimen al final de una línea, en mitad de una línea, y al
principio de las líneas.  Para nuestro ejemplo, queremos que todas las
barras de compás se supriman, por lo que el valor que necesitamos es
@code{#(#f #f #f)}.  Vamos a probarlo, recordando incluir el contexto
de @code{Staff}.  Observa también que al escribir este valor tenemos
dos símbolos de almohadilla antes del paréntesis de apertura.  Se
necesita uno como parte del valor para introducir un vector, y se
necesita otro más, como siempre, para precered el propio valor dentro
de la instrucción @code{\override}.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'break-visibility = ##(#f #f #f)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Y podemos ver que esto también quita todas las líneas divisorias.

@subheading transparent
@cindex transparente, propiedad

En la relación de propiedades que se especifican en la página del
@code{grob-interface} del RFI podemos ver que la propiedad
@code{transparent} es un valor booleano.  Esto se debe establecer a
@code{#t} para hacer que el grob sea transparente.  En el ejemplo
siguiente vamos a hacer que la indicación de compás, y no las líneas
divisorias, sea transparente.  Para hacerlo tenemos que buscar el
nombre del grob de la indicación de compás.  Volviendo a la página
@q{All layout objects} del RFI, buscamos las propiedades del objeto de
presentación @code{TimeSignature}.  Se produce por parte del grabador
@code{Time_signature_engraver} que como puede comprobar vive dentro
del contexto de @code{Staff} y también contempla el interface
@code{grob-interface}.  Así pues, la instrucción que hace transparente
a la indicación de compás es:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'transparent = ##t
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
El compás ya no está, pero esta instrucción deja una separación en el
lugar donde antes estaba la indicación de compás.  Quizá esto es lo
que queremos para un ejercicio en que el alumno deba escribirlo, pero
en otras circunstancias esta separación podría no ser deseable.  En
vez de eso, para quitarla, el stencil o «sello» de la indicación de
compás se debe establecer al valor @code{#f}:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
y la diferencia es obvia: al establecer el sello al valor @code{#f}
quitamos el objeto por completo; al hacer el objeto @code{transparent}
lo dejamos donde está, pero lo hacemos invisible.

@subheading color
@cindex color, propiedad

PAra finalizar, podríamos hacer invisibles las barras de compás
pintándolas de color blanco.  El interface @code{grob-interface}
especifica que la propiedad del color es una lista, pero no hay
ninguna explicación sobre lo que debe ir en esa lista.  La lista que
requiere es realmente una lista de valores en unidades internas, pero
para evitar tener que saber cuáles son, se ofrecen varias vías para la
especificación de los colores.  La primera forma es utilizar uno de
los colores @q{normales} que están relacionados en la primera tabla de
la @ruser{List of colors}.  Para poner las líneas divisorias de color
blanco, escribimos:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #white
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
y de nuevo podemos comprobar que las barras de compás no son visibles.
Observe que @emph{white} no viene precedido de un apóstrofe: no es un
símbolo, sino una @emph{función}.  Cuando se invoca, proporciona la
lista de valores internos que se requieren para establecer el color a
blanco.  Los otros colores de la lista normal también son funciones.
Para convencerse de que esto funciona, quizá quiera cambiar el color a
una de las otras funciones de la lista.

@cindex colores de X11
@cindex X11, colores de

La segunda forma de cambiar el color es utilizar la lista de nombres
de colores de X11 que aparecen en la segunda lista de @ruser{List of
colors}.  Sin embargo, éstos deben ir precedidos de otra función, que
convierte los nombres de colores de X11 en la lista de valores
internos, @code{x11-color}, de la siguiente manera:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(x11-color 'white)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Observe que en este caso la función @code{x11-color} toma un símbolo
como argumento, así que el símbolo debe ir precedido de un apóstrofe y
los dos deben ir entre paréntesis.

@cindex rgb, colores
@cindex color, rgb

Aún hay una tercera función, que convierte valores RGB en colores
internos: la función @code{rgb-color}.  Toma tres argumentos que dan
las intensidades de rojo, verde y azul.  Cada uno de ellos puede tomar
valores entre 0 y 1.  Por lo tanto, para establecer el color a rojo el
valor debe ser @code{(rgb-color 1 0 0)} y para blanco debe ser
@code{(rgb-color 1 1 1)}:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(rgb-color 1 1 1)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Finalmente, existe también una escala de grises como parte del
conjunto de colores de X11.  Varían desde el negro, @code{'grey0'},
hsta el blanco, @code{'grey100}, en pasos de 1.  Vamos a ilustrar esto
estableciendo todos los objetos de presentación de nuestro ejemplo a
varias gradaciones de gris:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.StaffSymbol   #'color = #(x11-color 'grey30)
  \override Staff.TimeSignature #'color = #(x11-color 'grey60)
  \override Staff.Clef          #'color = #(x11-color 'grey60)
  \override Voice.NoteHead      #'color = #(x11-color 'grey85)
  \override Voice.Stem          #'color = #(x11-color 'grey85)
  \override Staff.BarLine       #'color = #(x11-color 'grey10)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Observe los contextos asociados con cada uno de los objetos de
presentación.  Es importante que estén correctamente escritos, o las
instrucciones ¡no funcionarán!  Recuerde que el contexto es aquel en
que se encuentra el grabador correspondiente.  El contesto
predeterminado para los grabadores puede encontrarse empezando por el
objeto de presentación, de ahí al grabador que lo produce, y en la
página del grabador del RFI aparece en qué contexto se puede encontrar
normalmente el grabador.


@node Size of objects
@subsection Size of objects

Empezaremos examinando de nuevo un ejemplo anterior (véase
@ref{Nesting music expressions}) que nos mostraba cómo introducir un
pentagrama temporal, como en un @rglos{ossia}.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
       \relative g' {
         r4 g8 g c4 c8 d |
         e4 r8
         <<
           { f c c }
           \new Staff \with {
             alignAboveContext = "main" }
           { f8 f c }
         >>
         r4 |
       }
     }
@end lilypond

Los fragmentos de Ossia se escriben normalmente sin clave ni compás, y
por lo normal se imprimen más pequeños que el pentagrama principal.
Ya sabemos cómo quitar la clave y el compás: simplemente establecemos
el sello de cada uno de ellos a @code{#f}, como sigue:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = "main" 
      }
      {
        \override Staff.Clef #'stencil = ##f
        \override Staff.TimeSignature #'stencil = ##f
        { f8 f c }
      }
    >>
    r4 |
  }
}
@end lilypond

@noindent
donde el par de llaves adicional después de la cláusula @code{\with}
es necesario para asegurar que la sobreescritura encerrada y la música
se aplican al pentagrama de ossia.

Pero ¿cuál es la diferencia entre modificar el contexto de pentagrama
usando @code{\with} y modificar los sellos de clave y de compás con
\override?  La diferencia principal es que los cambios que se realizan
enuna cláusula @code{\with} se hacen en el momento en que se crea el
contexto, y permanecen activos como valores @strong{predeterminados}
durante toda la duración de dicho contexto, mientras que las
instrucciones @code{\set} o @code{\override} incluidas dentro de la
música son dinámicas: hacen cambios sincronizados con un punto
concreto de la música.  Si los cambios se deshacen o se devuelven
mediante @code{\unset} o @code{\revert} volverán a su valor
predeterminado que será el establecido en la cláusula @code{\with}, o
si no se ha establecido ninguno en este lugar, los valores
predeterminados normales.

Ciertas propiedades de contexto se pueden modificar solamente dentro
de cláusulas @code{\with}.  Son aquellas propiedades que no se pueden
cambiar después de que el contexto se ha creado.
@code{alignAboveContext} y su compañero, @code{alignBelowContext}, son
dos de tales propiedades: una vez que el pentagrama se ha creado, su
alineación está decidida y no tendría sentido intentar cambiarla más
tarde.

Los valores predeterminados de las propiedades de los objetos de
presentación también se pueden establever dentro de cláusulas
@code{\with}.  Simplemente utilice la instrucción @code{\override}
normal dejando aparte el nombre del contextom ya que está definido sin
ambigüedad como el contexto que la cláusula @code{\with} está
modificando.  De hecho, se producirá un error si se especifica un
contexto en este lugar.

Así pues, podemos reemplazar el ejemplo anterior con

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = "main" 
        % Don't print clefs in this staff
        \override Clef #'stencil = ##f
        % Don't print time signatures in this staff
        \override TimeSignature #'stencil = ##f
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

Finalmente llegamos a la forma de cambiar el tamaño de los objetos de
presentación.

Ciertos objetos de presentación se crean como glifos sacados de una
fuente tipográfica.  Entre ellos se encuentran las cabezas,
alteraciones, elementos de marcado, claves, indicaciones de compás,
indicaciones dinámicas y la letra de las canciones.  Su tamaño se
cambia mediante la modificación de la propiedad @code{font-size}, como
veremos en breve.  Otros objetos de presentación como ligaduras de
unión y de expresión (en general, objetos de extensión) se trazan
individualmente, por lo que no hay un tamaño de tipografía
@code{font-size} asociado a ellos.  Estos objetos generalmente derivan
su tamaño de los objetos a los que están adosados, y por ello
normalmente no hay necesidad de cambiarles el tamaño manualmente.  Aún
otras propiedades como la longitud de las plicas y las barras de
compás, el grosor de las barras de corchea y otras líneas, y la
separación de las líneas del pentagrama se deben modificar de otras
formas especiales.

Volviendo al ejemplo del ossia, vamos a cambiar en primer lugar el
tamaño de la tipografía.  Podemos hacerlo de dos formas.  Podemos
cambiar el tamaño de las tipografías de cada uno de los tipos de
objeto como las cabezas (@code{NoteHead}s) con instrucciones como

@example
\override NoteHead #'font-size = #-2
@end example

o podemos cambiar el tamaño de todas las tipografías estableciendo una
propiedad especial, @code{fontSize}, utilizando @code{\set}, o
mediante su inclusión dentro de una cláusula @code{\with} (pero sin el
@code{\set}).

@example
\set fontSize = #-2
@end example

Los dos enunciados producirían una reducción del tamaño de la
tipografía en dos pasos a partir de su valor previo, donde cada paso
reduce o aumenta el tamaño aproximadamente en un 12%.

Vamos a probarlo en nuestro ejemplo del ossia:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = "main" 
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        % Reduce all font sizes by ~24%
        fontSize = #-2
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

Aún no está demasiado bien.  Las cabezas y los corchetes de las notas
son más pequeños, pero las plicas son demasiado largas en proporción,
y las líneas del pentagrama están demasiado separadas entre sí.  Se
debe reducir su escala en proporción a la reducción de la tipografía.
El siguiente apartado trata sobre cómo se hace esto.

@node Length and thickness of objects
@subsection Length and thickness of objects

@cindex distancias
@cindex grosor
@cindex longitud
@cindex magstep
@cindex tamaño, cambiar
@cindex plica, cambiar la longitud
@cindex pentagrama, cambiar la separación de las líneas

Las distancias y longitudes en LilyPond se miden generalmente en
espacios de pentagrama, la distancia entre líneas adyacentes de la
pauta (o de manera ocasional medios espacios), mientras que la mayoría
de las propiedades de @code{thickness} (grosor) se miden en unidades
de una propiedad interna llamada @code{line-thickness.}  Por ejemplo,
de forma predeterminada, a las líneas de los reguladores se les da un
grosor de 1 unidad de @code{line-thickness}, mientras que el
@code{thickness} de una plica es 1.3.  Observe sin embargo que ciertas
propiedades de grosor son diferentes; por ejemplo, el grosor de las
barras de corchea se mide en espacios de pentagrama.

Entonces ¿cómo se tienen que escalar las longitudes en proporción al
tamaño de la tipografía?  Se puede hacer con la ayuda de una función
especial que se llama @code{magstep}, pensada especialmente para este
propósito.  Toma un argumento, el cambio de tamaño de la tipografía
(#-2 en nuestro ejemplo) y devuelve un factor de escalado adecuado
para reducir otros objetos en la misma proporción.  Se usa de la
siguiente forma:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = "main" 
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        fontSize = #-2
        % Reduce stem length and line spacing to match
        \override StaffSymbol #'staff-space = #(magstep -2)
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

@noindent
Puesto que la longitud de las plicas y muchas otras propiedades
relacionadas con la longitudse calculan siempre con relación al valor
de la propiedad @code{staff-space}, su longitud también ve reducida su
escala automáticamente.  Observe que esto afecta solamente a la escala
vertical del ossia: la escala horizontal se determina por medio de la
disposición de la música principal con el objeto de mantenerse en
sincronía con ella, de forma que no resulte afectada por ninguno de
estos cambios de tamaño.  Por supuesto, si la escala de toda la música
principal se cambiase de esta forma, entonces el espaciado horizontal
se vería afectado.  Trataremos de esto más tarde en la sección sobre
la disposición.

Esto, en fin, completa la creación de un ossia.  Los tamaños y
longitudes del resto de los objetos se pueden modificar de manera
análoga.

Para cambios de escala pequeños, como en el ejemplo de arriba, el
grosor de las diversas líneas dibujadas como divisorias, barras de
corchea, reguladores, ligaduras, etc, no requieren normalmente ningún
ajuste global.  Si el grosor de cualquier objeto de presentación en
particular necesita ajustarse, se puede hacer mejor mediante la
sobreescritura de su propiedad @code{thickness}.  Anteriormente
mostramos un ejemplo de cambio de grosor en las ligaduras, en
@ref{Properties of layout objects}.  El grosor de todos los objetos
trazados (es decir, aquellos que no se producen a partir de una
tipografía) se pueden cambiar de la misma forma.


@node Collisions of objects
@section Collisions of objects

@menu
* Moving objects::
* Fixing overlapping notation::
* Real music example::
@end menu

@node Moving objects
@subsection Moving objects

Aunque pueda sorprenderle, LilyPond no es perfecto.  Ciertos elementos
de notación se pueden superponer, lo que es una lástima, pero en casi
todos los casos se resuelve fácilmente.

@c  FIXME: find a better example for 5.1 Moving Objects.  -gp
@c  yes, I want this TODO to be visible to end-users.  It's better
@c  than having nothing at all.
HACER: con las nuevas funcionalidades de espaciado en la versión 2.12, estos ejemplos específicos
ya no son de relevancia.  Sin embargo siguen demostrando las poderosas funcionalidades de lilypond,
así que quedan aquí hasta que alguien elabore unos ejemplos mejores.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
e4^\markup{ \italic ritenuto } g b e
@end lilypond

@cindex padding

La solución más fácil es aumentar la distancia entre el objeto
(texto en este caso, pero muy bien podrían ser digitaciones o dinámicas)
y la nota.  En LilyPond, esto se llama la propiedad
@code{padding} (relleno); se mide en espacios de pentagrama.  Para la mayor
parte de los objetos, este valor ronda la cantidad de 1.0 o menos (varía dependiendo del
objeto). Queremos aumentarlo, así que probaremos el valor 1.5

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'padding = #1.5
e4^\markup{ \italic ritenuto } g b e
@end lilypond

Esto tiene un mejor aspecto, pero no es suficiente.  Después de probar
con algunos valores, creemos que 2.3 es el mejor número en este caso. Sin embargo
esta cantidad es el mero resultado del ensayo y error y de mi gusto personal
acerca de la notación.  Pruebe el ejemplo anterior con 2.3... pero también con otros valores 
mayores (y menores).  ¿Cuál cree que queda mejor?

La propiedad @code{staff-padding} (relleno de pentagrama) está estrechamente relacionada.
@code{padding} controla la cantidad de espacio mínima entre un objeto y el objeto más cercano
(generalmente la nota o las líneas del pentagrama);
@code{staff-padding} controla la cantidad mínima de espacio entre un
objeto y el pentagrama.  Ello supone una sutil diferencia, pero podrá 
observar el comportamiento a continuación.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
c4^"piu mosso" b a b
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
\once \override TextScript #'staff-padding = #4.6
c4^"piu mosso" fis a g
\break
c'4^"piu mosso" b a b
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
\once \override TextScript #'staff-padding = #4.6
c4^"piu mosso" fis a g
@end lilypond

@cindex desplazamiento adicional

Otra solución nos proporciona un control absoluto sobre la situación del objeto: podemos
moverlo horizontal o verticalmente.  Se hace con la propiedad
@code{extra-offset} (desplazamiento adicional).  Es ligeramente más complicado y puede
causar otros problemas.  Cuando movemos objetos con @code{extra-offset},
el movimiento se hace después de que LilyPond haya colocado todos los demás objetos.
Esto significa
que el resultado podría entrar en conflicto con otros objetos.

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'extra-offset = #'( 1.0 . -1.0 )
e4^\markup{ \italic ritenuto } g b e
@end lilypond

Con @code{extra-offset}, el primer número controla el movimiento
horizontal (negativo hacia la izquierda); el segundo número controla el movimiento
vertical (positivo hacia arriba).  Después de algunos ensayos, hemos decidido que los siguientes valores
son apropiados

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
\once \override TextScript #'extra-offset = #'( -1.6 . 1.0 )
e4^\markup{ \italic ritenuto } g b e
@end lilypond

@noindent
Una vez más, estos números son simplemente el resultado de algunos experimentos y
de observar la salida.  Quizá prefiera que el texto se encuentre algo más arriba,
o a la izquierda, o en cualquier dirección.  ¡Pruébelo y observe el resultado!

Una advertencia final: en esta sección hemos usado

@example
\once \override TextScript @dots{}
@end example

Esto altera la presentación del texto para la nota siguiente.  Si la nota no
tiene ningún texto, este truco no hace nada (y @strong{no} se queda esperando al
siguiente fragmento de texto).  Para cambiar el comportamiento permanentemente a partir
del comando, omita el @code{\once}.  Para detener este truco, use
@code{\revert} (revertir).  Todo esto se explica en profundidad en
@ruser{The \override command}.

@lilypond[quote,fragment,ragged-right,verbatim,relative=3]
  % temporary code to break this example:
  \override TextScript #'outside-staff-priority = ##f
c4^"piu mosso" b
\once \override TextScript #'padding = #4.6
  a4 b
c4^"piu mosso" d e f
\once \override TextScript #'padding = #4.6
c4^"piu mosso" d e f
c4^"piu mosso" d e f
\break
\override TextScript #'padding = #4.6
c4^"piu mosso" d e f
c4^"piu mosso" d e f
\revert TextScript #'padding
c4^"piu mosso" d e f
@end lilypond

@seealso

En el presente manual: @ruser{The \override command}, @ruser{Common tweaks}.


@node Fixing overlapping notation
@subsection Fixing overlapping notation

En @ruser{Moving objects}, pudimos ver cómo mover un objeto @code{TextScript}.
El mismo mecanismo se puede usar para mover otros tipos de
objetos; simplemente sustituya @code{TextScript} con el nombre de
otro objeto.

Para encontrar el nombre del objeto, consulte la sección @q{@strong{véase también}} al
final de la página relevante dentro de la documentación.  Por ejemplo, al
final de @ruser{Dynamics}, vemos

@quotation
@seealso

Referencia del programa: @internalsref{DynamicText}, @internalsref{Hairpin}.
La posición vertical de estos símbolos se maneja por medio de
@internalsref{DynamicLineSpanner}.
@end quotation

@noindent
Así que para mover expresiones dinámicas verticalmente, usamos

@example
\override DynamicLineSpanner #'padding = #2.0
@end example

No podemos listar todos y cada uno de los objetos, pero presentamos a continuación una lista
de los objetos más comunes.

@multitable @columnfractions .33 .66
@headitem Tipo de objeto                        @tab Nombre del objeto
@item Expresiones dinámicas (verticalmente)     @tab @code{DynamicLineSpanner}
@item Expresiones dinámicas (horizontalmente)   @tab @code{DynamicText}
@item Ligaduras de unión                        @tab @code{Tie}
@item Ligaduras de expresión                    @tab @code{Slur}
@item Articulaciones                            @tab @code{Script}
@item Digitaciones                              @tab @code{Fingering}
@item Texto, p.ej. @code{^"text"}               @tab @code{TextScript}
@item Llamadas de ensayo o marcas de texto      @tab @code{RehearsalMark}
@end multitable

@node Real music example
@subsection Real music example

UNTRANSLATED NODE: IGNORE ME

@node Common tweaks
@section Common tweaks

Algunas sustituciones son tan comunes que se proporcionan comandos preestablecidos
como atajos, como @code{\slurUp} (ligadura hacia arriba) y @code{\stemDown} (plica hacia abajo).  Estos
comandos se describen dentro de la Referencia de Notación bajo las secciones
correspondientes.

La lista completa de modificaciones disponibles para cada tipo de
objeto (como ligaduras o barras de corchea) están documentadas en la Referencia del
Programa.  Sin embargo, muchos objetos de la presentación comparten propiedades que se pueden
usar para aplicar trucos genéricos.

@itemize @bullet

@cindex relleno

@item
La propiedad @code{padding} (relleno) se puede establecer de forma que incremente
(o disminuya) la distancia entre símbolos que se imprimen encima
o debajo de las notas.  Se aplica a todos los objetos con
@code{side-position-interface}.

@lilypond[quote,fragment,relative=1,verbatim]
c2\fermata
\override Script #'padding = #3
b2\fermata
@end lilypond

@lilypond[quote,fragment,relative=1,verbatim]
% This will not work, see below:
\override MetronomeMark #'padding = #3
\tempo 4=120
c1
% This works:
\override Score.MetronomeMark #'padding = #3
\tempo 4=80
d1
@end lilypond

Observe en el segundo ejemplo cuán importante es determinar qué contexto
maneja un objeto determinado.  Debido a que el objeto @code{MetronomeMark} (indicación metronómica)
se maneja en el contexto @code{Score}, los cambios de propiedades dentro del
contexto @code{Voice} no se tendrán en cuenta.  Para ver más detalles, consulte
@ruser{Constructing a tweak}.

@cindex extra-offset (desplazamiento adicional)

@item
La propiedad @code{extra-offset} mueve objetos en la salida;
requiere una pareja de números.  El primer número
controla el movimiento horizontal, un número positivo moverá
el objeto hacia la derecha.  El segundo número controla el movimiento
vertical; un número positivo lo desplazará hacia arriba.  La
propiedad @code{extra-offset} es una funcionalidad de bajo nivel: el motor
de formateo es completamente olvidadizo respecto de estos desplazamientos.

En el ejemplo siguiente, la segunda digitación se desplaza un poco hacia
la izquierda y 1.8 espacios de pentagrama hacia abajo:

@lilypond[quote,fragment,relative=1,verbatim]
\stemUp
f-5
\once \override Fingering
    #'extra-offset = #'(-0.3 . -1.8)
f-5
@end lilypond

@item
El establecimiento de la propiedad @code{transparent} provocará que un objeto se imprima
con @q{tinta invisible}: el objeto no se imprime, pero se conserva todo el resto
de su comportamiento.  El objeto aún ocupa un espacio, toma parte en las colisiones,
y se le pueden adjuntar ligaduras de unión o de expresión y barras de corchea.

@cindex objetos transparentes
@cindex quitar objetos
@cindex ocultar objetos
@cindex objetos invisibles
El ejemplo siguiente demuestra cómo conectar distintas voces
utilizando ligaduras.  Normalmente las ligaduras sólo unen dos notas de la misma voz.
Al introducir una ligadura en una voz distinta,

@lilypond[quote,fragment,relative=2]
<< {
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

@noindent
y suprimiendo la primera plica hacia arriba en dicha voz, la ligadura parece cruzarse de una
voz a otra:


@lilypond[quote,fragment,relative=2,verbatim]
<< {
  \once \override Stem #'transparent = ##t
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

Para asegurarse de que la plica que hemos suprimido no aprieta demasiado a la
ligadura, también alargamos la plica, estableciendo su @code{length} (longitud) a
@code{8},

@lilypond[quote,fragment,relative=2,verbatim]
<< {
  \once \override Stem #'transparent = ##t
  \once \override Stem #'length = #8
  b8~ b8\noBeam
} \\ {
  b[ g8]
} >>
@end lilypond

@end itemize

@cindex Trucos, distancias
@cindex Distancias

Las distancias en LilyPond se miden en espacios de pentagrama, mientras que
las propiedades de grosor se miden en grosores de líneas de pentagrama.  Algunas
propiedades son diferentes; por ejemplo, el grosor de las barras de corchea
se mide en espacios de pentagrama.  Para más información, consulte la porción
correspondiente de la referencia del programa.



@node Default files
@section Default files

La documentación de la Referencia del Programa contiene una gran cantidad de información
sobre LilyPond, pero más información aún se puede obtener a partir de la observación
de los archivos internos de LilyPond.

Algunos ajustes por omisión como las definiciones de las
@code{\header@{@}}s (encabezamientos) están almacenados en archivos @code{.ly}.
Otros ajustes como las definiciones de los comandos de marcado se almacenan
como archivos @code{.scm} (de Scheme).  Cae fuera del ámbito de presente manual
cualquier explicación más profunda; los usuarios están advertidos de que se necesita
una considerable cantidad de conocimientos técnicos
para comprender estos archivos.

@itemize @bullet

@item Linux: @file{@var{directorio_de_instalación}/lilypond/usr/share/lilypond/current/}

@item OSX:
@file{@var{carpeta_de_instalación}/LilyPond.app/Contents/Resources/share/lilypond/current/}.
Para llegar aquí, o bien entre con @code{cd} en este directorio desde el
Terminal, o haga control-clic sobre la aplicación LilyPond y elija
@q{Mostrar el Contenido del Paquete}.

@item Windows: @file{@var{carpeta_de_instalación}/LilyPond/usr/share/lilypond/current/}

@end itemize

Los directorios @file{ly/} y @file{scm/} son de especial interés.
Archivos como @file{ly/property-init.ly} y
@file{ly/declarations-init.ly} definen todos los trucos comunes.


@node Fitting music onto fewer pages
@section Fitting music onto fewer pages

A veces puede acabar con uno o dos pentagramas en una segunda página
(o tercera, o cuarta...).  Es fastidioso sobre todo si observa las
páginas anteriores y parece haber
espacio suficiente en ellas.

Al investigar asuntos relacionados con la presentación, la herramienta
@code{annotate-spacing} (anotar el espaciado) no tiene precio.
Este comando imprime los valores de algunos comandos de espaciado;
consulte @ruser{Displaying spacing} para ver más detalles.  A partir de
la salida de de @code{annotate-spacing}, podemos ver qué márgenes podríamos desear alterar.

Aparte de los márgenes, existen otras opciones para ahorrar espacio:

@itemize
@item
Puede indicarle a LilyPond que coloque los sistemas tan juntos como sea
posible (para que quepan tantos sistemas como sea posible sobre una página),
pero luego separar estos sistemas para que no haya ningún espacio vacío
al final de la página.

@example
\paper @{
  between-system-padding = #0.1
  between-system-space = #0.1
  ragged-last-bottom = ##f
  ragged-bottom = ##f
@}
@end example

@item
Puede forzar el número de sistemas (es decir, si LilyPond quiere
tipografiar la música con 11 sistemas, puede forzarlo 
para que use 10).

@example
\paper @{
  system-count = #10
@}
@end example

@item
Evite (o reduzca) el uso de objetos que aumenten el tamaño
vertical de un sistema.  Por ejemplo, las repeticiones con
primera y segunda vez necesitan espacio adicional.  Si
estas repeticiones abarcan dos sistemas, ocuparán más espacio
que un solo sistema con las repeticiones y otro sistema sin ellas.

Otro ejemplo es desplazar las expresiones dinámicas que se
@q{asoman por encima} de un sistema.

@lilypond[verbatim,quote,fragment]
\relative c' {
  e4 c g\f c
  \override DynamicLineSpanner #'padding = #-1.8
  \override DynamicText #'extra-offset = #'( -2.1 . 0)
  e4 c g\f c
}
@end lilypond

@item
Altere el espaciado horizontal por medio de @code{SpacingSpanner}.  Consulte
@ruser{Changing horizontal spacing} para ver más detalles.

@lilypond[verbatim,quote]
\score {
  \relative c'' {
    g4 e e2 | f4 d d2 | c4 d e f | g4 g g2 |
    g4 e e2 | f4 d d2 | c4 e g g | c,1 |
    d4 d d d | d4 e f2 | e4 e e e | e4 f g2 |
    g4 e e2 | f4 d d2 | c4 e g g | c,1 |
  }
  \layout {
    \context {
      \Score
      \override SpacingSpanner
                #'base-shortest-duration = #(ly:make-moment 1 4)
    }
  }
}
@end lilypond

@end itemize

@node Avoiding tweaks with slower processing
@section Avoiding tweaks with slower processing

LilyPond puede llevar a cabo comprobaciones adicionales al tiempo que
procesa los archivos.  Estos comandos consumen tiempo, pero el
resultado puede necesitar menos trucos manuales.

@example
%%  asegura que las marcas de texto y letras de las canciones se encuentran dentro de los márgenes de la página
\override Score.PaperColumn #'keep-inside-line = ##t 
@end example

@node Advanced tweaks with Scheme
@section Advanced tweaks with Scheme

Hemos visto cómo la salida de LilyPond se puede modificar de manera muy profunda utilizando
comandos como
@code{\override TextScript #'extra-offset = ( 1 . -1)}.  Pero
tenemos un potencial incluso mayor si utilizamos Scheme.  Para ver una explicación completa
de esto, consulte el @ruser{Scheme tutorial} e
@ruser{Interfaces for programmers}.

Podemos usar Scheme simplemente para sobreponer (@code{\override}) comandos,

@lilypond[quote,verbatim,ragged-right]
padText = #(define-music-function (parser location padding) (number?)
#{
  \once \override TextScript #'padding = #$padding
#})

\relative c''' {
  c4^"piu mosso" b a b
  \padText #1.8
  c4^"piu mosso" d e f
  \padText #2.6
  c4^"piu mosso" fis a g
}
@end lilypond

Podemos usarlo para crear comandos nuevos,

@lilypond[quote,verbatim,ragged-right]
tempoMark = #(define-music-function (parser location padding marktext)
                                    (number? string?)
#{
  \once \override Score . RehearsalMark #'padding = $padding
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $marktext }
#})

\relative c'' {
  c2 e
  \tempoMark #3.0 #"Allegro"
  g c
}
@end lilypond

E incluso se le pueden pasar expresiones musicales.

@lilypond[quote,verbatim,ragged-right]
pattern = #(define-music-function (parser location x y) (ly:music? ly:music?)
#{
  $x e8 a b $y b a e
#})

\relative c''{
  \pattern c8 c8\f
  \pattern {d16 dis} { ais16-> b\p }
}
@end lilypond






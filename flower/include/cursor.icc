/*
  cursor.icc -- implement Cursor

  source file of the Flower Library

  (c)  1997--1999 Han-Wen Nienhuys <hanwen@cs.uu.nl>
  Jan Nieuwenhuizen <janneke@gnu.org>
*/


#ifndef CURSOR_ICC
#define CURSOR_ICC



#include <assert.h>

/**
   Initialisation of Cursor.. Set pointer and list fields.  
 */
template<class T>
inline
Cursor<T>::Cursor (const List<T> & list, Link<T>* p )
{
  list_l_ =  (List<T> *) &list;	// damn const
  if (list.size())
      pointer_ = p ? p : list.top_;
  else
      pointer_ = p;
}



template<class T>
inline
Cursor<T>::Cursor (const Cursor<T>& cursor) 
{
  list_l_= cursor.list_l_;
  pointer_ = cursor.pointer_;
}

template<class T>
inline T&
Cursor<T>::thing()
{
  assert (pointer_);
  return pointer_->thing();
}

template<class T>
Cursor<T>
Cursor<T>::operator =(const Cursor<T>& c)
{   
  assert (list_l_ == c.list_l_);
  pointer_ = c.pointer_;
  return *this;
}

template<class T>
inline void
Cursor<T>::add (const T& th)
{
  list_l_->add (th, *this);
}

template<class T>
inline void
Cursor<T>::insert (const T& th)
{
  list_l_->insert (th, *this);
}

template<class T>
inline List<T> *
Cursor<T>::list_l() const
{
  return list_l_;		// ugh!
}

template<class T>
inline Link<T>*
Cursor<T>::pointer()
{
  return pointer_;
}

template<class T>
inline bool
Cursor<T>::backward() const
{
  return (pointer_ != 0);
}

template<class T>
inline bool
Cursor<T>::forward() const
{
  return (pointer_ != 0);
}

template<class T>
inline bool
Cursor<T>::ok() const
{
  return (pointer_ != 0);
}
template<class T>
inline void
Cursor<T>::next() 
{
  assert (pointer_);
  pointer_ = pointer_->next();
}

template<class T>
inline Cursor<T> 
Cursor<T>::operator ++(int)    
{
  Cursor<T> r (*this);
  next();
  return r;
}

template<class T>
inline void
Cursor<T>::previous() 
{
  assert (pointer_);
  pointer_ = pointer_->previous();
}

template<class T>
inline Cursor<T>
Cursor<T>::operator --(int)
{
  Cursor<T> r (*this);
  previous();
  return r;
}


#endif // CURSOR_ICC

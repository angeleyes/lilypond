/*
  cursor.icc -- implement Cursor

  source file of the Flower Library

  (c)  1997--1998 Han-Wen Nienhuys <hanwen@stack.nl>
*/


#ifndef CURSOR_ICC
#define CURSOR_ICC



#include <assert.h>

// untested
template<class T>
inline
Cursor<T>::Cursor()
 :   list_(*(List<T> *)0)	// ugh
{
  pointer_ = 0;
}


template<class T>
inline
Cursor<T>::Cursor (const List<T>& list, Link<T>* pointer) : 
  list_((List<T>&) list)
{
  if (list.size())
      pointer_ = pointer ? pointer : list.top_;
  else
      pointer_ = pointer;
}

template<class T>
inline
Cursor<T>::Cursor (const Cursor<T>& cursor) :
  list_(cursor.list_)
{
  pointer_ = cursor.pointer_;
}

template<class T>
inline T&
Cursor<T>::thing()
{
  assert (pointer_);
  return pointer_->thing();
}

template<class T>
Cursor<T>
Cursor<T>::operator =(const Cursor<T>& c)
{   
  assert (&list_ == &c.list_);
  pointer_ = c.pointer_;
  return *this;
}

template<class T>
inline void
Cursor<T>::add (const T& th)
{
  list_.add (th, *this);
}

template<class T>
inline void
Cursor<T>::insert (const T& th)
{
  list_.insert (th, *this);
}

template<class T>
inline  List<T>&
Cursor<T>::list() const
{
  return list_;
}

template<class T>
inline Link<T>*
Cursor<T>::pointer()
{
  return pointer_;
}

template<class T>
inline bool
Cursor<T>::backward() const
{
  return (pointer_ != 0);
}

template<class T>
inline bool
Cursor<T>::forward() const
{
  return (pointer_ != 0);
}

template<class T>
inline bool
Cursor<T>::ok() const
{
  return (pointer_ != 0);
}
template<class T>
inline void
Cursor<T>::next() 
{
  assert (pointer_);
  pointer_ = pointer_->next();
}

template<class T>
inline Cursor<T> 
Cursor<T>::operator ++(int)    
{
  Cursor<T> r (*this);
  next();
  return r;
}

template<class T>
inline void
Cursor<T>::previous() 
{
  assert (pointer_);
  pointer_ = pointer_->previous();
}

template<class T>
inline Cursor<T>
Cursor<T>::operator --(int)
{
  Cursor<T> r (*this);
  previous();
  return r;
}


#endif // CURSOR_ICC

/*
  (c) 1995--2006  Han-Wen Nienhuys  <hanwen@xs4all.nl>

  Distributed under GNU GPL
*/

#if 0
#include "std-vector.hh"
#ifdef INLINE
#undef INLINE
#endif

#define INLINE
#endif

/*
  functions with loops don't inline
*/

template<class T> INLINE void
arrcpy (T *dest, T const *src, vsize count)
{
  for (vsize i_shadows_local = 0; i_shadows_local < count; i_shadows_local++)
#ifdef __powerpc__
    {
      /*
	urg: wierd egcs-1.1.2-12c (stock LinuxPPC R5) bug on ppc
	bug report filed
	fixed in egcs-1.1.2-12f
	ftp://dev.linuxppc.org/users/fsirl/R5/RPMS/ppc/
      */
      *dest = *src;
      dest++, src++;
    }
#else
  *dest++ = *src++;
#endif
}

template<class T> INLINE void
Array<T>::insert (iterator b, T k)
{
  vsize j = b - array_;
#if !STD_VECTOR
    assert (j >= 0 && j <= size_);
#else
    assert (j <= size_);
#endif
  resize (size_ + 1);
  for (vsize i = size_ - 1; i > j; i--)
    array_[i] = array_[i - 1];
  array_[j] = k;
}

template<typename T> INLINE void
vector_sort (Array<T> &v, int (*compare) (T const &, T const &),
	     vsize lower=-1, vsize upper=-1)
{
  if (lower < 0)
    {
      lower = 0;
      upper = v.size () - 1;
    }
  if (lower >= upper)
    return;
  v.swap (lower, (lower + upper) / 2);
  vsize last = lower;
  for (vsize i = lower +1; i <= upper; i++)
    if (compare (v.array_[i], v.array_[lower]) < 0)
      v.swap (++last, i);
  v.swap (lower, last);
  vector_sort (v, compare, lower, last - 1);
  vector_sort (v, compare, last + 1, upper);
}

template<class T> INLINE void
Array<T>::reverse ()
{
  vsize h = size_ / 2;
  for (vsize i = 0, j = size_ - 1; i < h; i++, j--)
    swap (i, j);
}

template<class T> INLINE
void
Array<T>::OK () const
{
#if !STD_VECTOR
  assert (max_ >= size_ && size_ >= 0);
#else
  assert (max_ >= size_);
#endif
  if (max_)
    assert (array_);
}

template<class T> INLINE
T *
Array<T>::remove_array ()
{
  T *p = array_;
  size_ = 0;
  max_ = 0;
  array_ = 0;
  return p;
}

template<class T> INLINE
Array<T>::Array (const_iterator b, const_iterator e)
{
  vsize n = e - b;
  array_ = new T[n];
  max_ = size_ = n;
  arrcpy (array_, b, n);
}

template<class T>
void
binary_search_bounds (Array<T> const &table,
		      T const &key, int (*compare) (T const &, T const &),
		      vsize *lo,
		      vsize *hi)
{
  int cmp;
  int result;

  /* binary search */
  do
    {
      cmp = (*lo + *hi) / 2;

      result = (*compare) (key, table[cmp]);

      if (result < 0)
	*hi = cmp;
      else
	*lo = cmp;
    }
  while (*hi - *lo > 1);
}

/*
  lookup with binsearch, return array index.
*/
template<class T>
vsize
binary_search (Array<T> const &table,
	       T const &key, int (*compare) (T const &, T const &),
	       vsize lo=0,
	       vsize hi=VPOS)
{
  if (hi == VPOS)
    hi = table.size ();

  binary_search_bounds (table, key, compare, &lo, &hi);

  if (! (*compare) (key, table[lo]))
    return lo;

  /* not found */
  return VPOS;
}

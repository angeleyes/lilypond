%  -*-Fundamental-*-
% feta-bolletjes.mf --  implement noteheads
% 
% source file of LilyPond's pretty-but-neat music font
% 
% (c) 1997--2004 Jan Nieuwenhuizen <janneke@gnu.org>
% & Han-Wen Nienhuys <hanwen@cs.uu.nl>
% & Juergen Reuter <reuter@ipd.uka.de>
% 

test_outlines := 0;


% most beautiful noteheads are pronounced, not circular, 
% and not even symmetric.
% These examples are inspired by [Wanske], see literature list



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE HEAD VARIABLES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
save black_notehead_width, noteheight,
	slash_thick, slash_slope, overdone_heads;
numeric black_notehead_width, noteheight, slash_thick;


fet_begingroup("noteheads");



% slope of slash. From scm/grob-description.scm. How to auto-copy?
slash_slope := 1.7; 

% thickness of slash lines. quarter notes get 1.5slt width.
slash_thick# := 2/3*0.48staff_space#;


%
% Hand-engraved music often has balls extending above and below
% the lines.  If you like that, modify overdone heads (unit:
% stafflinethickness)
%
overdone_heads = 0.0;
noteheight#:=staff_space#+ (1 + overdone_heads) *stafflinethickness#;

define_pixels(slash_thick, noteheight);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% SLANT moves both extremes on the long axis (by SLANT * ELLIPTICITY,
% so SLANT = -1, puts the extreme on the long axis next to the short axis one.)
%

def draw_outside_ellipse (expr ellipticity, tilt, superness,
			  slant) =
	save attachment_y;
	save p;
	path p;

	p := superellipse ((ellipticity, 0), (-slant * ellipticity, 1.0),
			(- ellipticity, 0), (slant * ellipticity, -1.0), superness);

	p := p rotated tilt;

	save top_point, right_point;
	pair top_point, right_point;

	top_point := directionpoint left of p;
	right_point := directionpoint up of p;

	save scaling, width, height;

	scaling# = noteheight# /(2 ypart (top_point));
	width# := 2 xpart (right_point) * scaling#;

	define_pixels (width, scaling);
	
	set_char_box (0, width#, noteheight#/2, noteheight#/2);

	% attachment Y
	charwy := ypart (right_point) * scaling#;
	charwx := width# ;

	p := p scaled scaling shifted (width/2, 0) ;
	if test_outlines = 1:
		pickup pencircle scaled 1 ; draw p;
	else:
		fill p;
	fi;
enddef;


def undraw_inside_ellipse (expr ellipticity, tilt, superness, clearance,
			center) =
begingroup
	save p;
	path p;

	p := superellipse ((ellipticity, 0), (0, 1.0),
			(- ellipticity, 0), (0, -1.0), superness);

	p := p rotated tilt;

	save top_point, right_point;
	pair top_point, right_point;

	top_point := directionpoint left of p;
	right_point := directionpoint up of p;

	save height, scaling;

	height# = staff_space# + stafflinethickness# - clearance;
	scaling# = height# /(2 ypart (top_point));

	define_pixels (scaling);
	p := (p scaled scaling) shifted center;

	if test_outlines = 1:
		pickup pencircle scaled 1; draw p;
	else:
		unfill p;
	fi
endgroup;
enddef;





%
% dimensions aren't entirely right.
%
fet_beginchar ("Brevis notehead", "s-1");
	save stemthick, fudge;
	define_pixels (stemthick);
	fudge = blot_diameter / 2;
	stemthick# = 2 stafflinethickness#;

	draw_outside_ellipse (1.80, 0, 0.707, 0);
	undraw_inside_ellipse (1.30, 125, 0.68, 2 stafflinethickness#,
				(w /2, 0));

	pickup pencircle scaled stemthick;

	bot y1 = -d;
	top y2 = h;
	rt x1 - fudge = 0;
	x1 = x2;

	fudge + lft x3 = w;
	x4 = x3;
	y4 = y2;
	y3 = y1;

	draw_gridline(z1,z2,stemthick);
	draw_gridline(z3,z4,stemthick);

fet_endchar;



fet_beginchar("Whole notehead", "s0")
	draw_outside_ellipse (1.80 - puff_up_factor / 3.0, 0, 0.707, 0);
	undraw_inside_ellipse (1.30, 125 - puff_up_factor *10,
			0.68, 2 stafflinethickness#,
			(w /2, 0));

%	draw_staff_outline (-2, 2, 0.5);

fet_endchar;


fet_beginchar("Half notehead", "s1")
	draw_outside_ellipse (1.53 - puff_up_factor / 3.0, 34, 0.66, 0.17);
	undraw_inside_ellipse (3.25, 33, 0.81,
		2.5 stafflinethickness#, (w/2, 0));

fet_endchar;
	
fet_beginchar("Quart notehead", "s2")

	% used to have 32. With 31, they are slightly bolder.
	draw_outside_ellipse (1.49 - puff_up_factor / 3.0, 31, 0.707, 0);
	black_notehead_width# := charwd;
fet_endchar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


fet_beginchar("Whole diamondhead", "s0diamond")
	draw_outside_ellipse (1.80, 0, 0.495, 0);
	undraw_inside_ellipse (1.30, 125, 0.6,
			.4 staff_space# +  stafflinethickness#,
				(w /2, 0));

fet_endchar;

fet_beginchar("Half diamondhead", "s1diamond")

	draw_outside_ellipse (1.50, 34, 0.49, 0.17);
	undraw_inside_ellipse (3.5, 33, 0.80,
		.3 staff_space# + 1.5 stafflinethickness#, (w/2, 0));

fet_endchar;

fet_beginchar("Quart diamondhead", "s2diamond")
	draw_outside_ellipse (1.80, 35, 0.495, -0.25);
fet_endchar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





def define_triangle_shape(expr stemdir) =
	save triangle,kern; path triangle;
	save width, depth, height;
	save left_point, height, width, origin;
	save left_up_dir, exact_right_point, exact_down_point;
	pair exact_down_point, exact_left_point, origin, left_up_dir, exact_right_point;
	save pen_thick;

	pen_thick# = stafflinethickness#  + .1 staff_space#;
	define_pixels(pen_thick, llap);

	left_up_dir = llap# * dir (90 + tilt);

	xpart (left_up_dir) * xs - (pen_thick# * xs)/2 + xpart origin = 0;
	ypart origin = 0;

	exact_left_point := origin + (left_up_dir xscaled xs);
	exact_down_point := origin + (left_up_dir rotated 120 xscaled xs);
	exact_right_point := origin + (left_up_dir rotated 240 xscaled xs);

	height# = ypart (exact_left_point + origin) + pen_thick#/2;
	depth# = -ypart (exact_down_point + origin) + pen_thick#/2;
	width# = xpart (exact_right_point - exact_left_point) + pen_thick# * xs;

	set_char_box(0, width#, depth#, height#);
	
	z0 = (hround_pixels (xpart origin), 0);
	z1 = z0 + llap * dir(90+tilt) xscaled xs;  
	z2 = z0 + (llap * dir(90+tilt + 120) xscaled xs);
	z3 = z0 + (llap * dir(90+tilt + 240) xscaled xs);

	z12 = caveness[.5[z1,z2],z3];
	z23 = caveness[.5[z2,z3],z1];
	z31 = caveness[.5[z3,z1],z2];

	triangle = z1 .. z12 .. z2 ..
		    z2 .. z23 .. z3 ..
		    z3 .. z31 .. z1 ..
		    cycle;
	pickup pencircle scaled pen_thick xscaled xs;
	labels(1,2,12,23,31,3);


	% attachment Y
	if stemdir = 1:
		charwy := ypart exact_right_point;
		charwx := xpart exact_right_point;
	else:
		charwy := - ypart exact_down_point;
		charwx := (width# - xpart exact_down_point);
	fi
enddef;

fet_beginchar("Whole trianglehead", "0triangle")
	save hei,xs;
	save llap;
	save tilt;

	tilt = 40;
	llap# = 3/4noteheight#;

	xs = 1.5;
	caveness:=0.1;
	define_triangle_shape(1);
	draw triangle;
fet_endchar;


def draw_closed_triangle_head(expr dir) =
	save hei,xs;
	save llap;
	save tilt;

	tilt = 40;
	llap# = 2/3noteheight#;
	xs = 1.2;
	caveness:=0.1;
	define_triangle_shape(dir);
	draw triangle;
enddef;

fet_beginchar("Half trianglehead", "d1triangle")
	draw_closed_triangle_head(-1);
fet_endchar;

fet_beginchar("Half trianglehead", "u1triangle")
	draw_closed_triangle_head(1);
fet_endchar;

def draw_closed_triangle_head(expr dir) = 
	save hei,xs;
	save llap;
	save tilt;
	tilt = 40;
	llap# = 2/3noteheight#;
	xs = 1.0;
	caveness:=0.1;
	define_triangle_shape(dir);
	filldraw triangle;
enddef;

fet_beginchar("Quart trianglehead", "u2triangle")
	draw_closed_triangle_head(1);
fet_endchar;

fet_beginchar("Quart trianglehead", "d2triangle")
	draw_closed_triangle_head(-1);
fet_endchar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% slash heads are for indicating improvisation. They are  
% twice as high as normal heads.
%
def draw_slash(expr hwid_hash) =
	save exact_height;
	save ne_dir;
	pair ne_dir;
	exact_height =  staff_space# + stafflinethickness#/2;

	set_char_box (0, 2 exact_height / slash_slope + hwid_hash,
			exact_height, exact_height);

	charwx := charwd;
	charwy := charht;

	clearxy;
	pickup pencircle scaled blot_diameter;

	bot y1 = - d;
	top y2 = h;
	lft x1 = 0;
	lft x2 = 2 h / slash_slope;
	
	rt x3 = w;
	y3 = y2;
	y4 = y1;
	x3- x2 = x4 - x1;

	ne_dir := unitvector( z3  - z4);
	filldraw z1 --- z2 --- z3 --- z4 --- cycle;

	if hwid_hash > 2 slash_thick#:
		save th;

		th = slash_thick - blot_diameter;
		y6 = y7;
		y5 = y8;
		y3 - y7 = th;
		y5 - y1 = th;
		z6 - z5 = whatever * ne_dir;
		z8 - z7 = whatever * ne_dir;

		z5  = z1 + whatever * ne_dir + th * (ne_dir rotated -90);
		z8  = z4 + whatever * ne_dir + th * (ne_dir rotated 90);

		unfill
			z5 -- z6 -- z7 -- z8 -- cycle;
	fi
	labels (range 1 thru 10);
enddef;

fet_beginchar("Whole slashhead","s0slash")
	draw_slash(4 slash_thick# + 0.5 staff_space#);
fet_endchar;

fet_beginchar("Half slashhead","s1slash")
	draw_slash(3.0 slash_thick# + 0.15 staff_space#);
fet_endchar;

fet_beginchar("Quart slashhead","s2slash")
	draw_slash(1.5 slash_thick#);
fet_endchar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% thick is the distance between the NE/SW parallel lines in the cross
% (distance between centres of lines)
% in stafflinethickness def
%
def draw_cross(expr thick) =
	save pent, slant, ne_dir;
	pair ne_dir;
	save crz; path crz;

	pen_thick# := 1.2 stafflinethickness#;
	define_pixels (pen_thick);
	pickup pencircle scaled pen_thick;

	top y3 = h;
	ne_dir := unitvector ((1, (2 h -pen_thick)/(w - pen_thick)));
	rt x4 = w/2;
	y5 = 0;
	z4 - z5 = whatever * ne_dir;
	x6 = 0;
	z6 - z3 = whatever * ne_dir;
	z3 - z4 = whatever * (ne_dir yscaled -1);

	z4 - z3 = whatever * (ne_dir) + (ne_dir rotated -90) * thick * stafflinethickness;

 	x1 = charwd/2 - .5 pen_thick#;
	z1 = whatever * ne_dir + thick/2 * stafflinethickness# * (ne_dir rotated -90);

	
	labels (1,2,3,4,5,6);

	crz = (z6 -- z3 -- z4 -- z5) ;

	draw crz shifted(w/2,0);
	draw crz xscaled -1 shifted(w/2,0);
	draw crz yscaled -1 shifted(w/2,0);
	draw crz scaled -1 shifted(w/2,0);

	charwx := charwd;
	charwy := y1;
	z12 = (charwx * hppp, y1 * vppp);
	labels (12);
enddef;

fet_beginchar("Whole Crossed notehead", "s0cross")
	wid# := black_notehead_width#+4stafflinethickness#;
	hei# := noteheight#+stafflinethickness#;
	set_char_box(0, wid#,hei#/2,hei#/2);
	
	draw_cross (3.75);
fet_endchar;

fet_beginchar("Half Crossed notehead", "s1cross")
	wid# := black_notehead_width#+2 stafflinethickness#;
	hei# := noteheight#+stafflinethickness#/2;
	set_char_box(0, wid#,hei#/2,hei#/2);
	draw_cross(3.0);
fet_endchar;

fet_beginchar("Crossed notehead", "s2cross")
	wid# := black_notehead_width#;
	hei# := noteheight#;
	set_char_box(0, wid#,hei#/2,hei#/2);
	draw_cross(1.0);
fet_endchar;

fet_beginchar("X-Circled notehead", "s2xcircle")
	wid# := black_notehead_width#*sqrt(sqrt2);
	hei# := noteheight#*sqrt(sqrt2);
	set_char_box(0, wid#,hei#/2,hei#/2);
	cthick := (1.2+1/4)*stafflinethickness;
	cxr := w/2-cthick/2;
	cyr := h-cthick/2;
	pickup pencircle scaled cthick;
	draw fullcircle xscaled 2cxr yscaled 2cyr shifted (w/2,0);
	xpos := cxr/sqrt2;
	ypos := cyr/sqrt2;
	draw (-xpos+w/2,-ypos) -- (xpos+w/2,ypos);
	draw (-xpos+w/2,ypos) -- (xpos+w/2,-ypos);

	charwx := charwd ; 
	charwy := 0 ;

	z12 = (charwx * hppp , charwy * vppp );
	labels (12);
fet_endchar;




%%%%%%%%
%
%
% SOLFA SHAPED NOTES
%
%


def generic_draw_solfa_note_shape =
  save a,beta,black,white;
  path black, white;

  pickup pencircle scaled stafflinethickness;
  2 beta# = noteheight#;
  a# = a_b*beta#;
  wid# := 2a#+stafflinethickness#;
  hei# := noteheight#+stafflinethickness#;
  set_char_box(0, wid#,0.5 hei#, 0.5 hei#);

  define_pixels(a,beta);

  black = noteshape xscaled a yscaled beta shifted (a+stafflinethickness/2,0);
  filldraw black;

  if (solid=false):
    white = noteishape xscaled (a*ai_a) yscaled (beta*bi_b)
                       shifted ((dx+1)*(a+stafflinethickness/2),
				dy*(beta+stafflinethickness/2));
    unfill white;
  fi;
enddef;  

def draw_solfa_note_shape =
  save solid; boolean solid;
  solid=false;
  generic_draw_solfa_note_shape;
enddef;
def draw_solfa_quarter_note_shape =
  save solid; boolean solid;
  solid=true;
  generic_draw_solfa_note_shape;
enddef;

% do - equilateral triangle: (0,-h/2) -- (w/2,h/2) -- (w,-h/2) -- cycle;
% stem attachment: -h/2

save triangle; path triangle;
triangle := (-1,-1) -- (0,1) -- (1,-1) -- cycle;




save solfa_pen_thick;
solfa_pen_thick# = 2 stafflinethickness#;
define_pixels (solfa_pen_thick);

def draw_do_head (expr width_factor, dir) =
	save p ;
	path p;
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	
	pickup pencircle scaled solfa_pen_thick;

	bot y1 =  -d ;
	y1 = y2;
	lft x1 = 0;
	rt x2 = w;
	top y3 = h;
	x3 =.5[x1,x2];

	p := z1 -- z2 -- z3 -- cycle;

	charwx := charwd;
	charwy := - chardp + 0.5 stafflinethickness#;
	if dir = -1:
		charwy := - charwy;
	fi;
enddef;

fet_beginchar("Whole dohead", "s0do")
	draw_do_head (1.8, 1);
	draw p;
fet_endchar;


fet_beginchar("Half dohead", "d1do")
	draw_do_head (1.5, -1);
	draw p;
fet_endchar;

fet_beginchar("Half dohead", "s1do")
	draw_do_head (1.5, 1);
	draw p;
fet_endchar;

fet_beginchar("Quart dohead", "d2do")
	draw_do_head (1.55, -1);
	filldraw p;
fet_endchar;


fet_beginchar("Quart dohead", "s2do")
	draw_do_head (1.55, 1);
	filldraw p;
fet_endchar;

  
% re - flat top, curved bottom:
%                (0,h/2) {dir -90} .. (w/2,-h/2) .. {dir 90} (w,h/2) -- cycle;
% (broader along the base and with more vertical sides for half and
% whole notes)
% stem attachment: h/2



def draw_re_head (expr width_factor, dir) =
	save p ;
	path p;
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	
	pickup pencircle scaled solfa_pen_thick;

	save curve_start;
	curve_start = 0.7;
	lft x1 = 0;
	y1 = y5;
	x1 = x2;
	y2 = curve_start [y3,y1];
	bot y3 = - d;
	x3 = .5 [x2,x4];
	rt x4 = w;
	y4 = y2;
	top y5 = h;
	x5 = x4;
	labels (range 1 thru 5);
	p := z1 --- z2 .. z3{right} .. z4 --- z5 --- cycle;

	charwx := charwd;
	charwy := curve_start [-chardp, charht];
	if dir = -1:
		charwy := - charwy;
	fi;
enddef;

fet_beginchar("Whole rehead", "s0re")
	draw_re_head (1.8,1);
	draw p;
fet_endchar;


fet_beginchar("Half up rehead", "u1re")
	draw_re_head (1.5, 1);
	draw p;
fet_endchar;

fet_beginchar("Half down rehead", "d1re")
	draw_re_head (1.5, -1);
	draw p;
fet_endchar;


fet_beginchar("Quart rehead", "u2re")
	draw_re_head (1.55, 1);
	filldraw p;
fet_endchar;

fet_beginchar("Quart rehead", "d2re")
	draw_re_head (1.55, -1);
	filldraw p;
fet_endchar;




def draw_mi_head (expr width_factor) =
	save path_out, path_in;
	path path_out, path_in;
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	
	pickup pencircle scaled solfa_pen_thick;


	lft x1 = 0;
	y1 = 0;
	bot y2 = -d;
	x2 = .5 [x1, x3];
	rt x3 = w;
	x4 = x2;
	y3 = y1;
	top y4 = h;

	z6 - z5 = whatever * (z2 - z1);
	z8 - z7 = whatever * (z2 - z1);
	z8 - z5 = whatever * (z4 - z1);
	z6 - z7 = whatever * (z4 - z1);

	z5 = whatever [z1, z4] + (unitvector (z4 - z1) rotated -90 scaled 0.5 solfa_pen_thick);
	z5 = whatever [z1, z2] + (unitvector (z2 - z1) rotated 90 scaled 0.75 solfa_pen_thick);

	z5 - z1 = -(z7 - z3);
	
	labels (range 1 thru 8);
	path_out := z1 -- z2 -- z3 -- z4 -- cycle;
	path_in := z5 -- z6 -- z7 -- z8 -- cycle;
%	path_in := z5 -- z1 --cycle;
enddef;

fet_beginchar("Whole mihead", "s0mi")
	draw_mi_head (1.8);
	filldraw path_out;
	unfill path_in;
fet_endchar;


fet_beginchar("Half mihead", "s1mi")
	draw_mi_head (1.6);
	filldraw path_out;
	unfill path_in;
fet_endchar;


fet_beginchar("Quart mihead", "s2mi")
	draw_mi_head (1.65);
	filldraw path_out;
fet_endchar;




def draw_fa_head (expr width_factor) =
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	save p_down, p_up;
	path p_up, p_down;
	
	pickup pencircle scaled solfa_pen_thick;

	lft x1 = 0;
	top y1 = h;

	rt x2 = w;
	y2 = y1;
	bot y3 = -d;
	x3 = x2;

	y4 = y3;
	x4 = x1;

	labels(range 1 thru 4);

	p_up := z1 -- z2 -- z3 --cycle;
	p_down := z1 -- z4 -- z3 --cycle;

	charwy := 0.0;
	charwx := charwd;
enddef;


fet_beginchar("Whole fa up head", "d0fa")
	draw_fa_head (1.8);
	draw p_up;
fet_endchar;

fet_beginchar("Whole fa down head", "u0fa")
	draw_fa_head (1.8);
	draw p_down;
fet_endchar;

fet_beginchar("half fa up head", "d1fa")
	draw_fa_head (1.5);
	draw p_up;
fet_endchar;

fet_beginchar("Half fa down head", "u1fa")
	draw_fa_head (1.5);
	draw p_down;
fet_endchar;

fet_beginchar("Quarter fa up head", "u2fa")
	draw_fa_head (1.55);
	filldraw p_up;
fet_endchar;

fet_beginchar("Quarter fa down head", "d2fa")
	draw_fa_head (1.55);
	filldraw p_down;
fet_endchar;


def draw_la_head (expr width_factor) =
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	save p;
	path p;
	
	pickup pencircle scaled solfa_pen_thick;

	lft x1 = 0;
	top y1 = h;

	rt x2 = w;
	y2 = y1;
	bot y3 = -d;
	x3 = x2;

	y4 = y3;
	x4 = x1;

	labels(range 1 thru 4);

	p := z1 -- z2 -- z3 -- z4 -- cycle;
enddef;

fet_beginchar("Whole lahead", "s0la")
	draw_la_head (1.8);
	draw p;
fet_endchar;


fet_beginchar("Half lahead", "s1la")
	draw_la_head (1.5);
	draw p;
fet_endchar;


fet_beginchar("Quart lahead", "s2la")
	draw_la_head (1.55);
	filldraw p;
fet_endchar;



def draw_ti_head (expr width_factor, dir) =
	set_char_box(0, width_factor * noteheight#, 0.5 noteheight#, 0.5 noteheight#);
	save p;
	path p;
	save cone_height;
	cone_height = 0.64;

	pickup pencircle scaled solfa_pen_thick;

	x1 = .5 [x2, x4];
	bot y1 = -d;
	lft x2 = 0;
	y2 = cone_height [y1,y3];
	rt x4 = w;
	y4 = y2;
	x3 = x1;
	top y3 = h;
	
	labels(range 1 thru 4);

	p := z1 -- z2  .. z3{right} .. z4 -- cycle;
	charwx := charwd;
	charwy := cone_height [-chardp, charht];
	if dir = - 1:
		charwy := - charwy;
	fi;
enddef;

fet_beginchar("Whole up tihead", "s0ti")
	draw_ti_head (1.8, 1);
	draw p;
fet_endchar;


fet_beginchar("Half up tihead", "u1ti")
	draw_ti_head (1.5, 1);
	draw p;
fet_endchar;

fet_beginchar("Half down tihead", "d1ti")
	draw_ti_head (1.5, -1);
	draw p;
fet_endchar;



fet_beginchar("Quart up tihead", "u2ti")
	draw_ti_head (1.55, 1);
	filldraw p;
fet_endchar;


fet_beginchar("Quart down tihead", "d2ti")
	draw_ti_head (1.55, -1);
	filldraw p;
fet_endchar;



fet_endgroup("noteheads");


%
% we derive black_notehead_width# from the quarter head,
% so we have to define black_notehead_width (pixel qty)  
% after the black_notehead_width# itself. Let's keep it outside the group as well.
% 
define_pixels(black_notehead_width);





% -%-Fundamental-%- -*-Metafont-*-
% parmesan-heads.mf -- implement ancient note heads
% 
% source file of LilyPond's pretty-but-neat music font
% 
% (c) 2001--2006 Juergen Reuter <reuter@ipd.uka.de>
% 
% Neo-mensural heads originally by
% Christian Mondrup and Mats Bengtsson
% 

save black_notehead_width;
numeric black_notehead_width;

fet_begingroup ("noteheads")

%
% character aligment:
%
%   The head is assumed to be vertically centered around (0, 0).
%   The left-most edge of the head should touch the vertical line
%   that goes though the point (0, 0).
%
% set_char_box() conventions:
%
% * breapth: Ignored (as far as I know).  Should be set to 0.
%
% * width: Should match the head's width.
%
% * depth: Should match the bottom edge of the head.  Affects vertical
%   collision handling.
%
% * height: Should match the top edge of the head.  Affects vertical
%   collision handling.
%
% TODO: should depth/height include appendages/stems?

overdone_heads = 0;
noteheight# := staff_space# + (1 + overdone_heads) * stafflinethickness#;
define_pixels (noteheight);


%%%%%%%%
%
%
%
% MENSURAL NOTATION
%
%
%

def draw_neomensural_brevis (expr brevwid) =
	save beamheight, head_width;
	save holeheight, stem_width;
	save serif_size, serif_protrude;

	head_width# = brevwid;
	holeheight = 3 stafflinethickness;
	stem_width = 1.4 stafflinethickness;

	define_pixels (head_width);

	set_char_box (0, head_width#,
		      noteheight# / 2, noteheight# / 2);
	
	2 beamheight + holeheight = noteheight;
	serif_size = (holeheight - stafflinethickness) / 2;
	serif_protrude = 1.5 serif_size;

	z1l = (0, 0);
	z2l = (0, -stafflinethickness / 2);
	z3r = z2r + serif_size * (1, -1);
	y4r = y3r;
	x4r = head_width / 2;
	z5l = z3l + (-serif_size, -serif_protrude);

	penpos1 (stem_width, 0);
	penpos2 (stem_width, 0);
	penpos3 (beamheight, 90);
	penpos4 (beamheight, 90);
	penpos5 (stem_width, 180);

	save pat_in, pat_out;
	path pat_in, pat_out;

	pat_out := z4l
		   -- z3l{left}
		   .. z5l{down}
		   .. z5r{up}
		   -- z1l;
	pat_out := pat_out
		   -- reverse pat_out yscaled -1;
	pat_out := pat_out
		   -- reverse pat_out shifted (-x4r, 0)
				      xscaled -1
				      shifted (x4l, 0)
		   -- cycle;
	fill pat_out;

	pat_in := z4r
		  -- z3r{left}
		  .. z2r{up}
		  -- z1r;
	pat_in := pat_in
		  -- reverse pat_in yscaled -1;
	pat_in := pat_in
		  -- reverse pat_in shifted (-x4r, 0)
				    xscaled -1
				    shifted (x4l, 0)
		  -- cycle;
	unfill pat_in;

	penlabels (1, 2, 3, 4, 5);
enddef;


%%% This head does not seem to be used anywhere.  Junk me?  -- jr
def draw_neomensural_left_stemmed_head (expr wid) =
	draw_neomensural_brevis (wid);

	x6 = x7 = stem_width / 2;
	y6 = y5;
	y7 = y5 - 2.25 staff_space;

	z17 = (x7, y7 - stem_width / 2);

	penpos6 (stem_width, 0);
	penpos7 (stem_width, 0);

	fill z7l
	     -- z6l
	     -- z6r
	     -- z7r
	     .. z17
	     .. cycle;

	penlabels (6, 7);
	labels (17);
enddef;


%%% This head does not seem to be used anywhere.  Junk me?  -- jr
fet_beginchar ("Left stemmed notehead", "slneomensural");
	draw_neomensural_left_stemmed_head (2 staff_space#);
fet_endchar;


%
% Find point on `curve' which gives the tangent between point `p'
% and `curve'.  To guide the search, two auxiliary points must be
% specified, `p_in' and `p_out'.  The line between `p' and `p_in'
% must intersect `curve', while the line between `p' and `p_out'
% must not.
%
def find_tangent (expr p, curve, p_in, p_out) =
	begingroup;
	save mid, t, t_good, in, out;
	pair mid, in, out;

	in := p_in;
	out := p_out;

	forever:
		mid := 0.5 [in, out];
		exitif abs (out - mid) <= eps;
		t := xpart (curve intersectiontimes (p -- mid));
		if (t > 0):
			in := mid;
			t_good := t;
		else:
			out := mid;
		fi;
	endfor;

	point t_good of curve
	endgroup
enddef;


%
% Some sources (eg. Musix/OpusTeX) think that the appendage should be on
% the left, some say right.  Right wins democratically.
%
def draw_neomensural_longa (expr wid) =
	draw_neomensural_brevis (wid);

	save theta;

	x7r = head_width;
	y7 = y5;
	z6 - z7 = (stem_width / 2, -staff_space);
	theta = angle (z6 - z7) + 90;

	penpos7 (stem_width, 0);
	penpos6 (1.2 stem_width, theta);
	
	z7' = find_tangent (z6l, pat_out,
			    (x7l + 0.5 stem_width, y7l),
			    (x7l - 0.5 stem_width, y7l));

	fill z7r
	     .. z6r{z6 - z7}
	     .. {z7 - z6}z6l
	     -- z7'
	     -- cycle;

	penlabels (6, 7);
	labels (7');
enddef;


%
% En wij presenteren U: de opvolgster van Emily
%
% (ze is wel breed)
% 
fet_beginchar ("Neo-mensural maxima notehead", "s-3neomensural");
	draw_neomensural_longa (2.6 staff_space#);
fet_endchar;


fet_beginchar ("Neo-mensural longa notehead", "s-2neomensural");
	draw_neomensural_longa (2 staff_space#);
fet_endchar;


fet_beginchar ("Neo-mensural brevis notehead", "s-1neomensural");
	draw_neomensural_brevis (2 staff_space#);
fet_endchar;


def draw_neomensural_black_head (expr wid, height) =
	save head_width;
	save ne, nw, ne_dist, nw_dist;
	pair ne, nw, ne_dist, nw_dist;

	head_width# = wid;

	set_char_box (0, head_width#,
		      height / 2, height / 2);
	
	charwx := head_width# / 2;
	charwy := height / 2;

	y3 = y1 = 0;
	x2 = x4 = (x1 + x3) / 2;

	pickup pencircle scaled blot_diameter;

	top y2 = h;
	bot y4 = -d;
	lft x1 = 0;
	rt x3 = w;

	ne := unitvector (z2 - z1);
	nw_dist := (ne rotated 90) * 0.5 blot_diameter;
	nw := unitvector (z2 - z3);
	ne_dist := (nw rotated -90) * 0.5 blot_diameter;

	fill lft z1{up}
	     .. (z1 + nw_dist){ne}
	     -- (z2 + nw_dist){ne}
	     .. top z2{right}
	     .. (z2 + ne_dist){-nw}
	     -- (z3 + ne_dist){-nw}
	     .. rt z3{down}
	     .. (z3 - nw_dist){-ne}
	     -- (z4 - nw_dist){-ne}
	     .. bot z4{left}
	     .. (z4 - ne_dist){nw}
	     -- (z1 - ne_dist){nw}
	     .. cycle;

	labels (1, 2, 3, 4);
enddef;


def draw_neomensural_open_head (expr wid, height)=
	draw_neomensural_black_head (wid, height);

	save diamNW, diamSW;

	diamNW = length (z2 - z1) + blot_diameter;
	diamSW = length (z4 - z1) + blot_diameter;
	
	save hole_widthNW, hole_widthSW;

	hole_widthNW = 0.34 diamNW ;
	hole_widthSW + 2.6 linethickness = diamSW;

	(z7 + z5) / 2 = (w / 2, 0);
	(z8 + z6) / 2 = (w / 2, 0);
	z6 - z5 = hole_widthNW * unitvector (z2 - z1);
	z7 - z6 = hole_widthSW * unitvector (z4 - z1);

	unfill z5
	       -- z6
	       -- z7
	       -- z8
	       -- cycle;

	labels (5, 6, 7, 8);
enddef;


%
% WL says the thin lines should be thinner.
%
fet_beginchar ("Harmonic notehead (Neo-mensural open)", "s0harmonic");
	draw_neomensural_open_head (1.3 staff_space#, 1.3 noteheight#);
	charwx := head_width#;
	charwy := 0;
fet_endchar;


fet_beginchar ("Harmonic notehead (Neo-mensural black)", "s2harmonic");
	draw_neomensural_black_head (1.3 staff_space#, 1.3 noteheight#);
	charwx := head_width#;
	charwy := 0;
fet_endchar;


fet_beginchar ("Neo-mensural semibrevis head", "s0neomensural");
	draw_neomensural_open_head (staff_space#, noteheight#);
fet_endchar;


fet_beginchar ("Neo-mensural minima head", "s1neomensural");
	draw_neomensural_open_head (staff_space#, noteheight#);
fet_endchar;


fet_beginchar ("Neo-mensural semiminima head", "s2neomensural");
	draw_neomensural_black_head (staff_space#, noteheight#);
fet_endchar;


def draw_mensural_brevis (expr wid) =
	% TODO.  For the moment, fall back to draw_neomensural_brevis.
	draw_neomensural_brevis (wid);
enddef;


%%% This head does not seem to be used anywhere.  Junk me?  -- jr
def draw_mensural_left_stemmed_head (expr wid) =
	draw_mensural_brevis (wid);

	x6 = x7 = stem_width / 2;
	y6 = y5;
	y7 = y5 - 2.25 staff_space;

	z17 = (x7, y7 - stem_width / 2);

	penpos6 (stem_width, 0);
	penpos7 (stem_width, 0);

	fill z7l
	     -- z6l
	     -- z6r
	     -- z7r
	     .. z17
	     .. cycle;

	penlabels (6, 7);
	labels (17);
enddef;


def draw_mensural_longa (expr wid) =
	draw_mensural_brevis (wid);

	x6 = x7 = head_width - stem_width / 2;
	y6 = y5;
	y7 = y5 - 2.25 staff_space;

	z17 = (x7, y7 - stem_width / 2);

	penpos6 (stem_width, 0);
	penpos7 (stem_width, 0);

	fill z7l
	     -- z6l
	     -- z6r
	     -- z7r
	     .. z17
	     .. cycle;

	penlabels (6, 7);
	labels (17);
enddef;


%%% This head does not seem to be used anywhere.  Junk me?  -- jr
fet_beginchar ("Mensural left stemmed notehead", "slmensural");
	draw_mensural_left_stemmed_head (staff_space#);
fet_endchar;


fet_beginchar ("Mensural maxima notehead", "s-3mensural");
	draw_mensural_longa (2.0 staff_space#);
fet_endchar;


fet_beginchar ("Mensural longa notehead", "s-2mensural");
	draw_mensural_longa (staff_space#);
fet_endchar;


fet_beginchar ("Mensural brevis notehead", "s-1mensural");
	draw_mensural_brevis (staff_space#);
fet_endchar;


%
% Shift `curve' along the line given by the auxiliary points `p_in'
% and `p_out' until `line' is a tangent, and return the shift.
% If `curve' is shifted to position `p_in', it must intersect
% `line', while shifted to `p_out' it must not.
%
def find_tangent_shift (expr line, curve, p_in, p_out) =
	begingroup;
	save mid, t, t_good, in, out;
	pair mid, in, out;

	in := p_in;
	out := p_out;

	forever:
		mid := 0.5 [in, out];
		exitif abs (out - mid) <= eps;
		t := xpart ((curve shifted mid) intersectiontimes line);
		if (t > 0):
			in := mid;
			t_good := t;
		else:
			out := mid;
		fi;
	endfor;

	mid
	endgroup
enddef;


def draw_diamond_head (expr head_h, pen_w, pen_h, angle, open) =
	save head_width, head_height;
	save ellipse, ellipse_r;
	path ellipse, ellipse_r;

	head_height# = head_h;
	head_width# / head_height# = tand (angle);

	set_char_box (0, head_width#,
		      head_height# / 2, head_height# / 2);

	charwx := head_width# / 2;
	charwy := head_height# / 2 - linethickness#;

	define_pixels (head_width, head_height);

	ellipse := reverse fullcircle
		     xscaled (max (blot_diameter, pen_w * head_width))
		     yscaled (max (blot_diameter, pen_h * head_width))
		     rotated -angle;
	ellipse_r := ellipse rotated 180;

	z1 = find_tangent_shift (((0, h) -- (0, -h)), ellipse,
				 (0, 0), (w / 2, 0));
	z2 = find_tangent_shift (((0, h) -- (w, h)), ellipse,
				 (w / 2, h), (w / 2, 0));
	z3 = find_tangent_shift (((w, h) -- (w, -h)), ellipse,
				 (w, 0), (w / 2, 0));
	z4 = find_tangent_shift (((0, -h) -- (w, -h)), ellipse,
				 (w / 2, -h), (w / 2, 0));

	fill (subpath (directiontime (z1 - z4) of ellipse,
		       directiontime (z2 - z1) of ellipse)
	       of ellipse) shifted z1
	     -- (subpath (directiontime (z2 - z1) of ellipse,
			  directiontime (z3 - z2) of ellipse)
		  of ellipse) shifted z2
	     -- (subpath (directiontime (z3 - z2) of ellipse_r,
			  directiontime (z4 - z3) of ellipse_r)
		  of ellipse_r) shifted z3
	     -- (subpath (directiontime (z4 - z3) of ellipse_r,
			  directiontime (z1 - z4) of ellipse_r)
		  of ellipse_r) shifted z4
	     -- cycle;

	if open:
		save l;
		path l[];

		l12 := (directionpoint (z1 - z2) of ellipse) shifted z1
			-- (directionpoint (z1 - z2) of ellipse) shifted z2;
		l23 := (directionpoint (z2 - z3) of ellipse) shifted z2
			-- (directionpoint (z2 - z3) of ellipse) shifted z3;
		l34 := (directionpoint (z3 - z4) of ellipse) shifted z3
			-- (directionpoint (z3 - z4) of ellipse) shifted z4;
		l41 := (directionpoint (z4 - z1) of ellipse) shifted z4
			-- (directionpoint (z4 - z1) of ellipse) shifted z1;

		unfill l12 intersectionpoint l23
		       -- l23 intersectionpoint l34
		       -- l34 intersectionpoint l41
		       -- l41 intersectionpoint l12
		       -- cycle;
	fi;

	labels (1, 2, 3, 4);
enddef;


fet_beginchar ("Mensural semibrevis head", "s0mensural");
	draw_diamond_head (staff_space#, 0.15, 0.30, 30, true);
fet_endchar;


fet_beginchar ("Mensural minima head", "s1mensural");
	draw_diamond_head (staff_space#, 0.15, 0.30, 30, true);
fet_endchar;


fet_beginchar ("Mensural semiminima head", "s2mensural");
	draw_diamond_head (staff_space#, 0.15, 0.30, 30, false);
fet_endchar;


fet_beginchar ("Petrucci semibrevis head", "s0petrucci");
%	draw_diamond_head (1.8 staff_space#, 0.15, 0.40, 30, true);
	draw_neomensural_open_head (staff_space#, 1.8 staff_space#);
fet_endchar;


fet_beginchar ("Petrucci minima head", "s1petrucci");
%	draw_diamond_head (1.8 staff_space#, 0.15, 0.40, 30, true);
	draw_neomensural_open_head (staff_space#, 1.8 staff_space#);
fet_endchar;


fet_beginchar ("Petrucci semiminima head", "s2petrucci");
%	draw_diamond_head (1.8 staff_space#, 0.15, 0.40, 30, false);
	draw_neomensural_black_head (staff_space#, 1.8 staff_space#);
fet_endchar;


%%%%%%%%
%
%
%
% EDITIO VATICANA (including solesmes extensions)
%
%
%

% parameterized punctum
def punctum_char (expr verbose_name, internal_name,
		       left_stem, right_stem, linea, cavum,
		       straight, auctum, rev_auctum, d_up,
		       eccentric, up_shift, down_shift, mag) =
	fet_beginchar (verbose_name, "s" & internal_name);
		save a_b, b_h, a_w;

		a_b := 1.54; % b_h * a_b / a_w = wd / ht
		b_h := 0.85;
		a_w := 1.09;

		save a, beta, ht, wd;

		ht# = noteheight# * mag;
		2 beta# = ht# * b_h;
		a# = beta# * a_b;
		wd# = 2 a# / a_w;
		black_notehead_width# := wd#;

		% direction
		save d_, d_sign;
		pair d_;

		if d_up:
			d_ := up;
			d_sign# := 1;
		else:
			d_ := down;
			d_sign# := -1;
		fi;

		% convexity and eccentricity
		save u_convexity, u_eccentricity;

		if straight:
			u_convexity# := -0.01 ht#;
			u_eccentricity# := 0.0 ht#; % dummy
		elseif auctum:
			u_convexity# := -0.03 ht#;
			u_eccentricity# := +0.25 ht#;
		elseif rev_auctum:
			u_convexity# := -0.10 ht#;
			u_eccentricity# := -0.12 ht#;
		else:
			u_convexity# := -0.05 ht#;
			u_eccentricity# := 0.0 ht#; % dummy
		fi;

		save convexity, eccentricity;

		convexity# := d_sign# * u_convexity#;
		eccentricity# := d_sign# * u_eccentricity#;

		% y shift offset
		save yoffs;

		if up_shift:
			yoffs# := 0.08 ht#;
		elseif down_shift:
			yoffs# := -0.11 ht#;
		else:
			yoffs# := 0.00 ht#;
		fi;

		define_pixels (convexity, eccentricity, yoffs, ht, wd);

		pickup pencircle scaled linethickness;

		path p;
		save height, yoffs_bt;

		height# = 0.47 ht#;
		yoffs_bt# = yoffs# - 0.5 height# - 0.25 convexity#;

		define_pixels (height, yoffs_bt);

		x1 = x6;
		x2 = x5;
		x3 = x4;
		y1 + height = y6;
		y2 + height = y5;
		y3 + height = y4;

		save box_top, box_bt;

		if auctum or rev_auctum:
			z1 = (0.00 wd + linethickness / 2,
			       yoffs_bt);
			z2 = (0.21 wd,
			       yoffs_bt + 1.0 convexity);
			z3 = (0.42 wd - linethickness/ 2,
			       yoffs_bt + 1.0 eccentricity);
			box_top# = height# + yoffs_bt# +
				max (0, 1.0 convexity#, 1.0 eccentricity#);
			box_bt# = yoffs_bt# +
				min (0, 1.0 convexity#, 1.0 eccentricity#);
			p = z1
			    .. {right}z2
			    .. {d_}z3
			    -- z4{-d_}
			    .. z5{left}
			    .. z6
			    -- cycle;
		elseif eccentric:
			z1 = (0.00 wd + linethickness / 2,
			       yoffs_bt - 1.0 convexity);
			z2 = (0.08 wd,
			       yoffs_bt + 1.4 convexity);
			z3 = (0.42 wd - linethickness / 2,
			       yoffs_bt - 1.0 convexity);
			box_top# = height# + yoffs_bt# +
				max (-1.0 convexity#, 1.4 convexity#, 0);
			box_bt# = yoffs_bt# +
				min (-1.0 convexity#, 1.4 convexity#, 0);
			p = z1{d_}
			    .. z2{right}
			    .. z3
			    -- z4
			    .. {left}z5
			    .. {-d_}z6
			    -- cycle;
		else:
			z1 = (0.00 wd + linethickness / 2,
			       yoffs_bt);
			z2 = (0.21 wd,
			       yoffs_bt + 1.0 convexity);
			z3 = (0.42 wd - linethickness / 2,
			       yoffs_bt);
			box_top# = height# + yoffs_bt# +
				max (0, 1.0 convexity#);
			box_bt# = yoffs_bt# +
				min (0, 1.0 convexity#);
			p = z1
			    .. z2
			    .. z3
			    -- z4
			    .. z5
			    .. z6
			    -- cycle;
		fi;

		labels (1, 2, 3, 4, 5, 6);

		if cavum:
			draw p;
		else:
			filldraw p;
		fi;

		pickup pencircle scaled 0.6 linethickness;

		save stem_bt;

		if left_stem:
			z11 = (0.00 wd + 0.6 linethickness / 2, yoffs);
			z12 = (0.00 wd + 0.6 linethickness / 2, yoffs - 1.1 ht);
			draw z11
			     -- z12;
			stem_bt# = yoffs# - 1.1 ht#;
		elseif right_stem:
			z11 = (0.42 wd - 0.6 linethickness / 2, yoffs);
			z12 = (0.42 wd - 0.6 linethickness / 2, yoffs - 1.5 ht);
			draw z11
			     -- z12;
			stem_bt# = yoffs# - 1.5 ht#;
		else:
			stem_bt# = 0;
		fi;

		set_char_box (0.00 wd#, 0.42 wd#,
			      max (0, -box_bt#, -stem_bt#) + linethickness# / 2,
			      max (0, box_top#) + linethickness# / 2);

		if linea:
			save linea_width, linea_height;

			linea_width# = 0.6 linethickness#;
			linea_height# = 0.7 ht#;

			define_pixels (linea_width, linea_height);

			draw_block ((-0.10 wd - linea_width / 2,
				     -linea_height / 2),
				    (-0.10 wd + linea_width / 2,
				     +linea_height / 2));
			draw_block ((+0.52 wd - linea_width / 2,
				     -linea_height / 2),
				    (+0.52 wd + linea_width / 2,
				     +linea_height / 2));

			set_char_box (0,
				      0.62 wd# + linea_width#,
				      linea_height# / 2,
				      linea_height# / 2);

			currentpicture := currentpicture
				shifted (0.10 wd + linea_width / 2, 0);
		fi;
	fet_endchar;
enddef;


% parameterized punctum inclinatum
def inclinatum_char (expr verbose_name, internal_name,
		     small, stropha, auctum) =

	fet_beginchar (verbose_name, "s" & internal_name)
		save ht, alpha;
		alpha# = 35;
		if small:
			ht# = 0.50 noteheight#;
		else:
			ht# = 0.80 noteheight#;
		fi;

		draw_diamond_head (ht#, 0, 0, alpha#, false);

		if stropha:
			pickup pencircle
				xscaled (0.25*head_height)
				yscaled (0.55*head_height)
				rotated alpha#;
			save za, off_angle; pair za;
			off_angle := 15;
			za = (0, -0.25*head_height)
				rotated -(alpha# + off_angle)
				shifted (0.48 head_width, -0.02 head_width);
			undrawdot za;
		fi;

		if auctum:
			pickup pencircle scaled linethickness;
			save za, zb, zc;
			pair za, zb, zc;
			za = (0, -0.5 head_height + linethickness);
			zb = 0.6 (za + zc);
			zc = za + (0.52 head_width, 0);
			draw za{(0,-1) rotated alpha#} .. {right}zb{right} ..
			     {(0,1) rotated -alpha#}zc;
		fi;
	fet_endchar;
enddef;

% punctum
punctum_char ("Ed. Vat. punctum", "vaticana.punctum",
	      false, false, false, false, false,
	      false, false, false, false, false, false, 1.0);

% punctum cavum (for OpusTeX compatibility)
punctum_char ("Ed. Vat. punctum cavum", "vaticana.punctum.cavum",
	      false, false, false, true, false,
	      false, false, false, false, false, false, 1.0);

% linea punctum (for OpusTeX compatibility)
punctum_char ("Ed. Vat. linea punctum", "vaticana.linea.punctum",
	      false, false, true, false, false,
	      false, false, false, false, false, false, 1.0);

% linea punctum cavum (for OpusTeX compatibility)
punctum_char ("Ed. Vat. linea punctum cavum", "vaticana.linea.punctum.cavum",
	      false, false, true, true, false,
	      false, false, false, false, false, false, 1.0);

% punctum inclinatum
inclinatum_char ("Ed. Vat. inclinatum", "vaticana.inclinatum",
		 false, false, false);

% pes lower punctum
punctum_char ("Ed. Vat. pes lower punctum", "vaticana.lpes",
	      false, false, false, false, true,
	      false, false, true, false, false, false, 1.0);

% pes lower punctum
punctum_char ("Ed. Vat. pes var lower punctum", "vaticana.vlpes",
	      false, false, false, false, true,
	      false, false, true, false, false, true, 1.0);

% pes upper punctum
punctum_char ("Ed. Vat. pes upper punctum", "vaticana.upes", 
	      false, false, false, false, true,
	      false, false, false, false, false, false, 1.0);

% pes upper punctum (shifted variation)
%
% This note head is used instead of the regular pes upper punctum to
% avoid collision with the lower punctum note of the pes when the upper
% punctum sits directly on top of the lower punctum.
%
punctum_char ("Ed. Vat. var pes upper punctum", "vaticana.vupes",
	      false, false, false, false, true,
	      false, false, false, false, true, false, 1.0);

% small punctum as used in epiphonus
punctum_char ("Ed. Vat. plica", "vaticana.plica", 
	      false, false, false, false, false,
	      false, false, false, false, false, false, 0.6);

% small punctum as used in epiphonus
punctum_char ("Ed. Vat. var plica", "vaticana.vplica", 
	      false, false, false, false, false,
	      false, true, false, false, false, true, 0.6);

% eccentric punctum as used in epiphonus
punctum_char ("Ed. Vat. epiphonus", "vaticana.epiphonus", 
	      false, false, false, false, false,
	      false, false, true, true, false, false, 1.0);

% eccentric punctum as used in epiphonus (shifted variation)
%
% This note head is used instead of the regular epiphonus punctum to
% avoid collision with the plica head when the plica sits directly on
% top of the lower head.
%
punctum_char ("Ed. Vat. var epiphonus", "vaticana.vepiphonus",
	      false, false, false, false, false,
	      false, false, true, true, false, true, 1.0);

% small punctum as used in cephalicus
punctum_char ("Ed. Vat. rev. plica", "vaticana.reverse.plica",
	      false, false, false, false, false,
	      false, false, true, false, false, false, 0.6);

% small punctum as used in cephalicus
punctum_char ("Ed. Vat. rev. var plica", "vaticana.reverse.vplica",
	      false, false, false, false, false,
	      false, true, true, false, false, true, 0.6);

% eccentric punctum as used in cephalicus; without left stem
punctum_char ("Ed. Vat. cephalicus", "vaticana.inner.cephalicus",
	      false, false, false, false, false,
	      false, false, false, true, false, false, 1.0);

% eccentric punctum as used in cephalicus; with left stem
punctum_char ("Ed. Vat. cephalicus", "vaticana.cephalicus",
	      true, false, false, false, false,
	      false, false, false, true, false, false, 1.0);

% quilisma
fet_beginchar ("Ed. Vat. quilisma", "svaticana.quilisma")
	save a_b, b_h, a_w;

	a_b:=1.54; % b_h*a_b/a_w = wd/ht
	b_h:=0.85;
	a_w:=1.09;

	save a, beta, ht, wd;
	ht# = noteheight#;
	2 beta# = ht# * b_h;
	a# = beta#*a_b;
	wd# = 2 a# / a_w;
	set_char_box (0, 0.42 wd#, 0.28 ht#, 0.36 ht#);
	black_notehead_width# := wd#;

	define_pixels (ht, wd);
	pickup pencircle xscaled linethickness yscaled 0.44 ht;
	lft x1 = 0.00 wd; bot y1 = -0.28 ht;
	x2 = 0.11 wd;     y2 = -0.14 ht;
	x3 = 0.12 wd;     y3 = +0.03 ht;
	x4 = 0.25 wd;     y4 = -0.09 ht;
	x5 = 0.26 wd;     y5 = +0.08 ht;
	x6 = 0.40 wd;     y6 = -0.04 ht;
	rt x7 = 0.42 wd;  top y7 = +0.36 ht;
	draw z1 .. z2 -- z3 .. z4 -- z5 .. z6 -- z7;
fet_endchar;

% solesmes punctum inclinatum parvum
inclinatum_char ("Solesmes punctum inclinatum parvum", "solesmes.incl.parvum",
		 true, false, false);

% solesmes punctum auctum ascendens
punctum_char ("Solesmes punctum auctum ascendens", "solesmes.auct.asc",
	      false, false, false, false, false,
	      true, false, true, false, false, false, 1.0);

% solesmes punctum auctum descendens
punctum_char ("Solesmes punctum auctum descendens", "solesmes.auct.desc",
	      false, false, false, false, false,
	      true, false, false, false, false, false, 1.0);

% solesmes punctum inclinatum auctum
inclinatum_char ("Solesmes punctum incl. auctum", "solesmes.incl.auctum",
		 false, false, true);

% solesmes stropha
inclinatum_char ("Solesmes stropha", "solesmes.stropha",
		 false, true, false);

% solesmes stropha aucta
inclinatum_char ("Solesmes stropha aucta", "solesmes.stropha.aucta",
		 false, true, true);

% solesmes oriscus
fet_beginchar ("Solesmes oriscus", "ssolesmes.oriscus")
	save a_b, b_h, a_w;

	a_b := 1.54; % b_h*a_b/a_w = wd/ht
	b_h := 0.85;
	a_w := 1.09;

	save a, beta, ht, wd;
	ht# = noteheight#;
	2 beta# = ht# * b_h;
	a# = beta# * a_b;
	wd# = 2 a# / a_w;
	black_notehead_width# := wd#;

	save convexity;
	convexity# = +0.05 ht#;

	define_pixels (ht, wd, convexity);
	pickup pencircle xscaled blot_diameter yscaled 0.50 ht;
	lft x1 = 0.00 wd; y1 = -convexity;
	x2 = 0.16 wd;     y2 = +convexity;
	x3 = 0.33 wd;     y3 = -convexity;
	rt x4 = 0.50 wd;  y4 = +convexity;
	draw z1 .. z2 .. z3 .. z4;
	set_char_box (0.00 wd#, 0.50 wd#,
		      0.25 ht# + convexity#, 0.25 ht# + convexity#);
fet_endchar;

%%%%%%%%
%
%
%
% EDITIO MEDICAEA
%
%
%

% inclinatum
fet_beginchar ("Ed. Med. inclinatum", "smedicaea.inclinatum")
	draw_diamond_head (1.2 staff_space#, 0, 0, 35, false);
fet_endchar;


% parametrized punctum
def punctum_char (expr verbose_name, internal_name,
		       left_up_stem, left_down_stem) =
	fet_beginchar (verbose_name, "s" & internal_name);
		save a, beta, ht, wd;

		ht# = 2 staff_space#;
		wd# = ht#;
		black_notehead_width# := wd#;

		define_pixels (ht, wd);

		pickup pencircle xscaled blot_diameter
				 yscaled 0.50 ht;

		z1 = (0.00 wd + blot_diameter / 2, 0);
		z2 = (0.4 wd - blot_diameter / 2, 0);

		draw z1
		     .. z2;

		pickup pencircle xscaled linethickness
				 yscaled blot_diameter;

		if left_down_stem:
			z4 = (0.00 wd + linethickness / 2, blot_diameter / 2);
			z5 = (0.00 wd + linethickness / 2, -1.25 ht);

			draw z4
			     .. z5;
			set_char_box (0.0, 0.4 wd#, 1.25 ht#, 0.25 ht#);
		elseif left_up_stem:
			z4 = (0.00 wd + linethickness / 2, blot_diameter / 2);
			z5 = (0.00 wd + linethickness / 2, +1.25 ht);

			draw z4
			     .. z5;
			set_char_box (0.0, 0.4 wd#, 0.25 ht#, 1.25 ht#);
		else:
			set_char_box (0.0, 0.4 wd#, 0.25 ht#, 0.25 ht#);
		fi;

	fet_endchar;
enddef;


% punctum
punctum_char ("Ed. Med. punctum", "medicaea.punctum", 
	      false, false);


% left up-stemmed punctum
punctum_char ("Ed. Med. reverse virga", "medicaea.rvirga",
	      true, false);


% virga (i.e. left down-stemmed punctum)
punctum_char ("Ed. Med. virga", "medicaea.virga", 
	      false, true);

%%%%%%%%
%
%
%
% HUFNAGEL
%
%
%

% punctum
% parametrized punctum
def punctum_char (expr verbose_name, internal_name,
		       down_stem) =
	fet_beginchar (verbose_name, "s" & internal_name);
		save alpha;

		alpha# = 55;
		draw_diamond_head (staff_space#, 0, 0, alpha#, false);
		if down_stem:
			pickup pencircle xscaled blot_diameter
					 yscaled 0.7 staff_space
					 rotated -alpha#;

			save za, zb;
			pair za, zb;

			za = (head_width / 2, 0);
			bot zb = (head_width / 2, -1.5 staff_space);

			draw za
			     -- zb;
			set_char_box (0, head_width#,
				      1.5 staff_space#, head_height# / 2);
		fi;
	fet_endchar;
enddef;

% punctum
punctum_char ("Hufnagel punctum", "hufnagel.punctum", false)

% virga
punctum_char ("Hufnagel virga", "hufnagel.virga",  true)

% pes lower punctum
fet_beginchar ("Hufnagel pes lower punctum", "shufnagel.lpes")
	save width, height, alpha;
	width# = 2*staff_space#;
	height# = 0.7*staff_space#;
	alpha# = 35;

	set_char_box (0, width#, height#/2, height#/2);

	pickup pencircle scaled linethickness;
	define_pixels (width, height);

	rt x3 = -lft x1 = width/2;
	y2 = y3 = height/2;
	y1 = y4 = -height/2;
	tand (alpha#) * (y2 - y1) = x2 - x1 = x3 - x4;

	filldraw z1 -- z2 -- z3 -- z4 -- cycle;

	currentpicture := currentpicture shifted (width/2, 0);
fet_endchar;

fet_endgroup ("noteheads")

%!PS-Adobe-1.0: music-drawing-routines.ps
%
% Functions for direct and embedded PostScript

% Careful with double % as comment prefix.
% Any %%X comment is interpreted as DSC comments.

% TODO: use dicts or prefixes to prevent namespace pollution.

% Emulation code from Postscript Language Reference.

/*SF
{
	exch findfont exch
	dup type /arraytype eq
		{makefont}
		{scalefont}
	ifelse
	setfont
} bind def

/languagelevel where
	{pop languagelevel}
	{1}
ifelse

2 lt
	{ /selectfont /*SF load def }
if

% end emulation code

/pdfmark where
{pop} {userdict /pdfmark /cleartomark load put} ifelse


% llx lly urx ury URI
/mark_URI
% It's possible to eliminate the coordinate variables by doing [ /Rect [ 7 3
% roll.  That is, however, kind of ugly.  It would be nice if this procedure
% were only included when PDF marks are enabled.
{
    /command exch def
    /ury exch def
    /urx exch def
    /lly exch def
    /llx exch def
    [
	/Rect [ llx lly urx ury ]
	
	/Border [ 0 0 0 ]

        /Action
	    <<
		/Subtype /URI
		/URI command
	    >>
        /Subtype /Link
    /ANN
    pdfmark
}
bind def

% from adobe tech note 5002. 
/BeginEPSF { %def
    /b4_Inc_state save def % Save state for cleanup
    /dict_count countdictstack def % Count objects on dict stack
    /op_count count 1 sub def % Count objects on operand stack
    userdict begin % Push userdict on dict stack
    /showpage { } def % Redefine showpage, { } = null proc
    0 setgray 0 setlinecap % Prepare graphics state
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    /languagelevel where % If level not equal to 1 then
    {pop languagelevel % set strokeadjust and
    1 ne % overprint to their defaults.
      {false setstrokeadjust false setoverprint
      } if
    } if
} bind def

/EndEPSF { %def
  count op_count sub {pop} repeat % Clean up stacks
  countdictstack dict_count sub {end} repeat
  b4_Inc_state restore
} bind def 


%<font> <encoding> <name> reencode-font
/reencode-font
{
    /name exch def
    /encoding exch def
    dup length
    dict begin {
	1 index /FID ne {def} {pop
	pop} ifelse
    }
    forall
    /Encoding encoding
    def currentdict
    end
    name exch definefont
} bind def



/set_tex_dimen
{
	cvr def
} bind def


/stroke_and_fill {
	gsave
		stroke
	grestore
	fill
} bind def

/draw_round_box % x y width height blot
{
	setlinewidth
	0 setlinecap
	1 setlinejoin

	currentdict /testing known {
		%% outline only, for testing:
	}{
		4 copy
		rectfill
	} ifelse
	rectstroke
} bind def

/draw_polygon % fill? x(n) y(n) x(n-1) y(n-1) ... x(0) y(0) n blot
{
	setlinewidth %set to blot

	0 setlinecap
	1 setlinejoin

	3 1 roll
	moveto % x(0) y(0)
	{ lineto } repeat % n times
	closepath 
	{ %fill?
		stroke_and_fill
	}{
		stroke
	} ifelse
} bind def

/draw_repeat_slash % x-width width height
{
	2 index % duplicate x-width
	1 setlinecap
	1 setlinejoin
	
	0 0 moveto
	  0  rlineto % x-width 0
	     rlineto % width height
	neg 0 rlineto % -x-width 0
	closepath fill
} bind def

% this is for drawing slurs.
/draw_bezier_sandwich  % thickness controls
{
    % round ending and round beginning
    1 setlinejoin 1 setlinecap
	setlinewidth
	moveto
	curveto
	lineto
	curveto
	closepath
	stroke_and_fill
} bind def

/draw_dot % x1 y2 R
{
%	0 360 arc fill stroke
	0 360 arc closepath stroke_and_fill
} bind def

/draw_circle % F R T
{
	setlinewidth
	dup 0 moveto
	0 exch 0 exch
	0 360 arc closepath
		{ stroke_and_fill } 
		{ stroke }
	ifelse
} bind def


% JUNKME. use color & circle. 
/draw_white_dot % x1 y2 R
{
%	0 360 arc fill stroke
	0 360 arc closepath % fill stroke
gsave
 1 setgray fill
grestore
%	0 360 arc closepath % fill stroke
  0.05 setlinewidth 0 setgray stroke
} bind def


% JUNKME: Use color.  
/draw_white_text  % text scale font
{
  exch selectfont
  1 setgray
  0 0 moveto
  %-0.05 -0.05 moveto
  % text
  show
} bind def


/draw_dashed_line % dash thickness dx dy
{
	1 setlinecap
	1 setlinejoin
	setdash
	setlinewidth
	0 0 moveto
	lineto
	stroke
} bind def

/draw_dashed_slur % dash thickness controls
{
	1 setlinecap
	1 setlinejoin
	setdash
	setlinewidth
	8 -2 roll
	moveto
	curveto
	stroke
} bind def

/print_glyphs {
	{
		currentpoint
		3 2 roll
		glyphshow
		moveto
		rmoveto
	}repeat
}bind def
%end music-drawing-routines.ps

%!PS-Adobe-1.0: music-drawing-routines.ps
%
% Functions for direct and embedded PostScript

% Careful with double % as comment prefix.
% Any %%X comment is interpreted as DSC comments.

% TODO: use dicts or prefixes to prevent namespace pollution.

/pdfmark where
{pop} {userdict /pdfmark /cleartomark load put} ifelse

% from adobe tech note 5002. 
/BeginEPSF { %def
    /b4_Inc_state save def % Save state for cleanup
    /dict_count countdictstack def % Count objects on dict stack
    /op_count count 1 sub def % Count objects on operand stack
    userdict begin % Push userdict on dict stack
    /showpage { } def % Redefine showpage, { } = null proc
    0 setgray 0 setlinecap % Prepare graphics state
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    /languagelevel where % If level not equal to 1 then
    {pop languagelevel % set strokeadjust and
    1 ne % overprint to their defaults.
      {false setstrokeadjust false setoverprint
      } if
    } if
} bind def


/EndEPSF { %def
  count op_count sub {pop} repeat % Clean up stacks
  countdictstack dict_count sub {end} repeat
  b4_Inc_state restore
} bind def 


%<font> <encoding> <name> reencode-font
/reencode-font
{
    /name exch def
    /encoding exch def
    dup length
    dict begin {
	1 index /FID ne {def} {pop
	pop} ifelse
    }
    forall
    /Encoding encoding
    def currentdict
    end
    name exch definefont
} bind def


% llx lly urx ury URI
/mark_URI
{
    /command exch def
    /ury exch def
    /urx exch def
    /lly exch def
    /llx exch def
    [
	/Rect [ llx lly urx ury ]
	/Border [ 0 0 0 ]

        /Action
	    <<
		/Subtype /URI
		/URI command
	    >>
        /Subtype /Link
    /ANN
    pdfmark
}
bind def

/set_tex_dimen
{
	cvr def
} bind def



/euclidean_length
{
	1 copy mul exch 1 copy mul add sqrt
} bind def

% FIXME.  translate to middle of box.
% Nice rectangle with rounded corners
/draw_box % breapth width depth height
{
%	currentdict /testing known {
		%% real thin lines for testing
		/blot 0.005 def
%	}{
%		/blot blot-diameter def
%	} ifelse

	0 setlinecap
	blot setlinewidth
	1 setlinejoin

	blot 2 div sub /h exch def
	blot 2 div sub /d exch def
	blot 2 div sub /w exch def
	blot 2 div sub /b exch def

	b neg d neg moveto
	b w add 0 rlineto
	0 d h add rlineto
	b w add neg 0 rlineto
	0 d h add neg rlineto

	currentdict /testing known {
		%% outline only, for testing:
		stroke
	}{
		closepath gsave stroke grestore fill
	} ifelse
} bind def


/draw_round_box % breapth width depth height blot
{
	/blot exch def

	0 setlinecap
	blot setlinewidth
	1 setlinejoin

	blot 2 div sub /h exch def
	blot 2 div sub /d exch def
	blot 2 div sub /w exch def
	blot 2 div sub /b exch def

	b neg d neg moveto
	b w add 0 rlineto
	0 d h add rlineto
	b w add neg 0 rlineto
	0 d h add neg rlineto

	currentdict /testing known {
		%% outline only, for testing:
		stroke
	}{
		closepath gsave stroke grestore fill
	} ifelse
} bind def

/draw_polygon % x(n) y(n) x(n-1) y(n-1) ... x(1) y(1) n blot fill
{
	/fillp exch def
	/blot exch def

	0 setlinecap
	blot setlinewidth
	1 setlinejoin

	/points exch def
	2 copy
	moveto
	1 1 points { pop lineto } for
	closepath 
	fillp {
		gsave stroke grestore fill
	}{
		stroke
	} ifelse
} bind def

/draw_repeat_slash % width slope thick
{
	1 setlinecap
	1 setlinejoin

	/beamthick exch def
	/slope exch def
	/width exch def
	beamthick beamthick slope div euclidean_length
	  /xwid exch def
	0 0 moveto
	xwid 0  rlineto
	width slope width mul rlineto
	xwid neg 0 rlineto
      %  width neg width angle sin mul neg rlineto
	closepath fill
} bind def

% this is for drawing slurs.
/draw_bezier_sandwich  % thickness controls
{
    % round ending and round beginning
    1 setlinejoin 1 setlinecap
	setlinewidth
	moveto
	curveto
	lineto
	curveto
	closepath
	gsave
	fill
	grestore
	stroke
} bind def

/draw_dot % x1 y2 R
{
%	0 360 arc fill stroke
	0 360 arc closepath fill stroke
} bind def

/draw_circle % R T F
{
	/filled exch def
	setlinewidth
	dup 0 moveto
	0 exch 0 exch
	0 360 arc closepath
	gsave stroke grestore
	filled { fill } if 
} bind def


% JUNKME. use color & circle. 
/draw_white_dot % x1 y2 R
{
%	0 360 arc fill stroke
	0 360 arc closepath % fill stroke
gsave
 1 setgray fill
grestore
%	0 360 arc closepath % fill stroke
  0.05 setlinewidth 0 setgray stroke
} bind def


% JUNKME: Use color.  
/draw_white_text  % text scale font
{
  exch selectfont
  1 setgray
  0 0 moveto
  %-0.05 -0.05 moveto
  % text
  show
} bind def


/draw_dashed_line % dash thickness dx dy
{
	1 setlinecap
	1 setlinejoin
	setdash
	setlinewidth
	0 0 moveto
	lineto
	stroke
} bind def

/draw_dashed_slur % dash thickness controls
{
	1 setlinecap
	1 setlinejoin
	setdash
	setlinewidth
	8 -2 roll
	moveto
	curveto
	stroke
} bind def

/print_letter {
	currentpoint
	3 2 roll
	glyphshow
	moveto
} bind def

/print_glyphs {
	-1 1
	{
		3 mul -3 roll
		print_letter
		rmoveto
	}for
}bind def
%end music-drawing-routines.ps

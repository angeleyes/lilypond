%!PS-Adobe-1.0: music-drawing-routines.ps
%
% Functions for direct and embedded PostScript


% FIXME: set with individual symbols
% round cappings 
1 setlinecap

/euclidean_length  
{ 
	1 copy mul exch 1 copy mul add sqrt 
} bind def 

% FIXME.  translate to middle of box.
% Nice rectangle with rounded corners
% FIXME: linewidth hardcoded.  check: too round?
/draw_box % breapth width depth height
{
	%% FIXME: hardcoded
	currentdict /testing known {
		%% real thin lines for testing
		/l 0.005 def
	}{
		/l 0.05 def
	} ifelse

	0 setlinecap
	l setlinewidth
	1 setlinejoin

	l 2 div sub /h exch def
	l 2 div sub /d exch def

	%% UGH huh?
	%% Where does this correction come from?
	%% Why don't we need this in x direction?
	h l 2 div sub /h exch def
	d l 2 div sub /d exch def

	l 2 div sub /w exch def
	l 2 div sub /b exch def

	b neg d neg moveto
	b w add 0 rlineto
	0 d h add rlineto
	b w add neg 0 rlineto
	0 d h add neg rlineto

	currentdict /testing known {
		%% outline only, for testing:
		stroke
	}{
		closepath gsave stroke grestore fill
	} ifelse
} bind def

% Nice beam with rounded corners
% FIXME: linewidth hardcoded.  check: too round?
/draw_beam % slope width thick 
{
	%% FIXME: hardcoded
	currentdict /testing known {
		%% real thin lines for testing
		/l 0.01 def
	}{
		/l 0.1 def
	} ifelse
	l 2 div setlinewidth

 	0 setlinecap
	1 setlinejoin

	l sub /t exch def
	l sub /w exch def
	w mul /h exch def

	l 2 div t 2 div neg moveto
	w h rlineto
	0 t rlineto
	w neg h neg rlineto
	0 t neg rlineto

	currentdict /testing known {
		%% outline only, for testing:
		stroke
	}{
		closepath gsave stroke grestore fill
	} ifelse
} bind def 

/draw_repeat_slash % width slope thick
{
  /beamthick exch def
  /slope exch def
  /width exch def
  beamthick beamthick slope div euclidean_length
    /xwid exch def 
  0 0 moveto
  xwid 0  rlineto
  width slope width mul rlineto
  xwid neg 0 rlineto
%  width neg width angle sin mul neg rlineto
  closepath fill
} bind def

/draw_hairpin % width start_h end_h thick
{
  setlinewidth
  /end_h exch def 
  /start_h exch def
  /wid exch def
  0 start_h moveto
  wid end_h lineto
  stroke
  0 start_h neg moveto
  wid end_h neg lineto
  stroke
} bind def

/draw_tuplet % height gap dx dy thick dir 
{ 
	/dir exch def 
	setlinewidth 
	1 setlinecap 
	1 setlinejoin 
	/tuplet_dy exch def 
	/tuplet_dx exch def 
	/tuplet_gapx exch def 
	/tuplet_h exch def 
	tuplet_dy tuplet_dx div tuplet_gapx mul /tuplet_gapy exch def 


	0 tuplet_h neg dir mul moveto 
	0 0 lineto  
	tuplet_dx tuplet_gapx sub 2 div  
		tuplet_dy tuplet_gapy sub 2 div  lineto 
	tuplet_dx tuplet_gapx add 2 div  
		tuplet_dy tuplet_gapy add 2 div  moveto 
	tuplet_dx tuplet_dy lineto 
	tuplet_dx tuplet_dy tuplet_h dir neg mul add lineto 
	stroke 
} bind def 

/draw_ez_ball % ch letter_col ball_col font
{
	% font
	findfont 0.7 scalefont setfont 
	0.1 setlinewidth
	0 0 moveto
	0 setgray
	0.5 0 0.5 0 360 arc closepath fill stroke
	% ball_col
	1 eq {
		0.01 setlinewidth
		1 setgray
		0.5 0 0.4 0 360 arc closepath
		fill stroke
	} if 
	% letter_col
	setgray
	% 0.25 is empiric centering. Change to taste
	0.25 -0.25 moveto
	% ch
	show
} bind def

% Simple, but does it work everywhere?
% Han-Wen reports that one printer (brand?) at cs.uu.nl chokes on this,
% reverted for now -- jcn
%
% The filled circles are drawn by setting the linewidth
% to 2*radius and drawing a point.
/simple_draw_ez_ball % ch letter_col ball_col font
{
	% font
	findfont 0.85 scalefont setfont
	/origin { 0.45 0 } def
	0 setgray
	1.1 setlinewidth
	origin moveto
	origin lineto stroke
	% ball_col
 	setgray
	0.9 setlinewidth
	origin moveto
	origin lineto stroke
	% letter_col
	setgray
	% 0.25 is empiric centering. Change to taste
	origin moveto
	-0.28 -0.30 rmoveto
	% ch
	show
} bind def

/draw_volta % h w thick vert_start vert_end 
{ 
	/vert_end exch def 
	/vert_start exch def 
	setlinewidth 
	/volta_w exch def 
 	/volta_h exch def 
	1 setlinecap 
	1 setlinejoin 
	vert_start 0 eq { 
		0 0 moveto 
		0 volta_h lineto 
	} if 
	0 volta_h moveto 
	volta_w volta_h lineto 
	vert_end 0 eq { 
		volta_w 0 lineto 
	} if 
	stroke 
} bind def 

% this is for drawing slurs. 
/draw_bezier_sandwich  % thickness controls 
{ 
	setlinewidth 
	moveto 
	curveto 
	lineto 
	curveto 
	gsave 
	fill 
	grestore 
	stroke 
} bind def 

/draw_dashed_line % dash thickness dx dy
{ 
	1 setlinecap 
	1 setlinejoin 
	setdash 
	setlinewidth 
	0 0 moveto
	lineto
	stroke 
} bind def 

/draw_dashed_slur % dash thickness controls
{ 
	1 setlinecap 
	1 setlinejoin 
	setdash 
	setlinewidth 
	8 -2 roll 
	moveto 
	curveto 
	stroke 
} bind def 



/bracket_traject 
{ 
	/traject_ds exch def 
	/traject_alpha exch def 
	traject_ds traject_alpha sin mul add 
	exch 
	traject_ds traject_alpha cos mul add 
	exch 
} bind def 



/half_bracket
{ 
%6 
	0 0 
%5a 
	bracket_thick arch_height add half_height arch_thick sub arch_width add 
	arch_angle arch_height -0.15 mul bracket_traject 
%5b 
	bracket_thick 0.5 mul half_height 
	0 arch_height 0.5 mul bracket_traject 
%5c 
	0 half_height 
%4a 
	bracket_thick half_height arch_thick sub 
	0 arch_height 0.4 mul bracket_traject 
%4b 
	bracket_thick arch_height add half_height arch_thick sub arch_width add 
	arch_angle arch_height -0.25 mul bracket_traject 
%4c 
	bracket_thick arch_height add half_height arch_thick sub arch_width add 
%3 
	bracket_thick half_height arch_thick sub 
%2 
	bracket_thick 0 
%1 
	0 0 
} bind def 

/draw_half_bracket { 
	moveto 
	lineto 
	lineto 
	curveto 
	curveto 
	lineto 
	gsave 
	fill 
	grestore 
} bind def 

/draw_bracket % arch_angle arch_width arch_height bracket_height arch_thick bracket_thick
{ 
	% urg

	/bracket_thick exch def
	/arch_thick exch def
	/bracket_height exch def
	/arch_height exch def
	/arch_width exch def
	/arch_angle exch def

	bracket_height 2 div bracket_thick add /half_height exch def 
	bracket_thick 0.5 mul setlinewidth
	1 setlinecap 
	1 setlinejoin 
	half_bracket 
	20 copy 
	1 -1 scale 
	draw_half_bracket 
	stroke 
	1 -1 scale 
	draw_half_bracket 
	stroke 
} bind def 

